msgid ""
msgstr ""
"Project-Id-Version: solidity-test\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-01-13 16:47+0100\n"
"PO-Revision-Date: 2022-01-13 16:14\n"
"Last-Translator: \n"
"Language-Team: Portuguese, Brazilian\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Crowdin-Project: solidity-test\n"
"X-Crowdin-Project-ID: 494285\n"
"X-Crowdin-Language: pt-BR\n"
"X-Crowdin-File: solidity-by-example.po\n"
"X-Crowdin-File-ID: 37\n"
"Language: pt_BR\n"

#: ../../solidity-by-example.rst:3 897cecfb49304115ab6872e996105d1f
msgid "Solidity by Example"
msgstr ""

#: ../../examples/voting.rst:7 f475ad606fa2423fbc86974b8a4e8ded
msgid "Voting"
msgstr ""

#: ../../examples/voting.rst:9 e26eee9cda7f4362ba1f5dd1382f278f
msgid "The following contract is quite complex, but showcases a lot of Solidity's features. It implements a voting contract. Of course, the main problems of electronic voting is how to assign voting rights to the correct persons and how to prevent manipulation. We will not solve all problems here, but at least we will show how delegated voting can be done so that vote counting is **automatic and completely transparent** at the same time."
msgstr ""

#: ../../examples/voting.rst:19 d8ef2dec29984970950f62e291bb42a7
msgid "The idea is to create one contract per ballot, providing a short name for each option. Then the creator of the contract who serves as chairperson will give the right to vote to each address individually."
msgstr ""

#: ../../examples/voting.rst:25 b9436efb1d244f239d1b96f30023888a
msgid "The persons behind the addresses can then choose to either vote themselves or to delegate their vote to a person they trust."
msgstr ""

#: ../../examples/voting.rst:29 7fd2a52c301c4245962d089d0450eca5
msgid "At the end of the voting time, ``winningProposal()`` will return the proposal with the largest number of votes."
msgstr ""

#: ../../examples/voting.rst:188 47cc2442dc90455196b33c1a82bad23d
msgid "Possible Improvements"
msgstr ""

#: ../../examples/voting.rst:190 f0382583fa2f4dbb846afb606b06aa0b
msgid "Currently, many transactions are needed to assign the rights to vote to all participants. Can you think of a better way?"
msgstr ""

#: ../../examples/blind-auction.rst:5 ../../examples/blind-auction.rst:168
#: 7f1a0a7cbe224afe94c887462fed4a12 ed1abfdb0e424d378cc4ae5a1f142ece
msgid "Blind Auction"
msgstr ""

#: ../../examples/blind-auction.rst:7 52d706586640469c8fdcae3e1f82d6fb
msgid "In this section, we will show how easy it is to create a completely blind auction contract on Ethereum.  We will start with an open auction where everyone can see the bids that are made and then extend this contract into a blind auction where it is not possible to see the actual bid until the bidding period ends."
msgstr ""

#: ../../examples/blind-auction.rst:16 e6d46fe818524bc9bdf0f8fdc4a86497
msgid "Simple Open Auction"
msgstr ""

#: ../../examples/blind-auction.rst:18 a50ea6d220754730b7bdef03cb2e2d2f
msgid "The general idea of the following simple auction contract is that everyone can send their bids during a bidding period. The bids already include sending money / Ether in order to bind the bidders to their bid. If the highest bid is raised, the previous highest bidder gets their money back.  After the end of the bidding period, the contract has to be called manually for the beneficiary to receive their money - contracts cannot activate themselves."
msgstr ""

#: ../../examples/blind-auction.rst:170 97eda57c73ed49ff92fc9d5b59749ca7
msgid "The previous open auction is extended to a blind auction in the following. The advantage of a blind auction is that there is no time pressure towards the end of the bidding period. Creating a blind auction on a transparent computing platform might sound like a contradiction, but cryptography comes to the rescue."
msgstr ""

#: ../../examples/blind-auction.rst:176 845cbad3ba45412ab73aef3f31d28413
msgid "During the **bidding period**, a bidder does not actually send their bid, but only a hashed version of it.  Since it is currently considered practically impossible to find two (sufficiently long) values whose hash values are equal, the bidder commits to the bid by that.  After the end of the bidding period, the bidders have to reveal their bids: They send their values unencrypted and the contract checks that the hash value is the same as the one provided during the bidding period."
msgstr ""

#: ../../examples/blind-auction.rst:184 8f9bf67ffa434c469340d62c6d1c57da
msgid "Another challenge is how to make the auction **binding and blind** at the same time: The only way to prevent the bidder from just not sending the money after they won the auction is to make them send it together with the bid. Since value transfers cannot be blinded in Ethereum, anyone can see the value."
msgstr ""

#: ../../examples/blind-auction.rst:189 2b4f0716b30e483f91a9cd62baec24ee
msgid "The following contract solves this problem by accepting any value that is larger than the highest bid. Since this can of course only be checked during the reveal phase, some bids might be **invalid**, and this is on purpose (it even provides an explicit flag to place invalid bids with high value transfers): Bidders can confuse competition by placing several high or low invalid bids."
msgstr ""

#: ../../examples/safe-remote.rst:5 4049623971654814bb581059295b2734
msgid "Safe Remote Purchase"
msgstr ""

#: ../../examples/safe-remote.rst:7 7d667f727a254a74b60aa3db20e71c26
msgid "Purchasing goods remotely currently requires multiple parties that need to trust each other. The simplest configuration involves a seller and a buyer. The buyer would like to receive an item from the seller and the seller would like to get money (or an equivalent) in return. The problematic part is the shipment here: There is no way to determine for sure that the item arrived at the buyer."
msgstr ""

#: ../../examples/safe-remote.rst:13 a22552484bdf47c0884295c4b4bd7caa
msgid "There are multiple ways to solve this problem, but all fall short in one or the other way. In the following example, both parties have to put twice the value of the item into the contract as escrow. As soon as this happened, the money will stay locked inside the contract until the buyer confirms that they received the item. After that, the buyer is returned the value (half of their deposit) and the seller gets three times the value (their deposit plus the value). The idea behind this is that both parties have an incentive to resolve the situation or otherwise their money is locked forever."
msgstr ""

#: ../../examples/safe-remote.rst:22 36c860a54d0f416f97460369dce7be4f
msgid "This contract of course does not solve the problem, but gives an overview of how you can use state machine-like constructs inside a contract."
msgstr ""

#: ../../examples/micropayment.rst:3 45e097c42da14cc2be20a3ce7f5b8d44
msgid "Micropayment Channel"
msgstr ""

#: ../../examples/micropayment.rst:5 b54bfead703a42f1a32f10857aa3a638
msgid "In this section we will learn how to build an example implementation of a payment channel. It uses cryptographic signatures to make repeated transfers of Ether between the same parties secure, instantaneous, and without transaction fees. For the example, we need to understand how to sign and verify signatures, and setup the payment channel."
msgstr ""

#: ../../examples/micropayment.rst:12 fdfe1b4d77284c18bea3fb5162f44a47
msgid "Creating and verifying signatures"
msgstr ""

#: ../../examples/micropayment.rst:14 db67c2e45b304a88bea97639910e2f7e
msgid "Imagine Alice wants to send some Ether to Bob, i.e. Alice is the sender and Bob is the recipient."
msgstr ""

#: ../../examples/micropayment.rst:17 89f91f03fe184306a4237ae735d54d57
msgid "Alice only needs to send cryptographically signed messages off-chain (e.g. via email) to Bob and it is similar to writing checks."
msgstr ""

#: ../../examples/micropayment.rst:20 bde79ce2aad6434da5b44c9adbd87504
msgid "Alice and Bob use signatures to authorise transactions, which is possible with smart contracts on Ethereum. Alice will build a simple smart contract that lets her transmit Ether, but instead of calling a function herself to initiate a payment, she will let Bob do that, and therefore pay the transaction fee."
msgstr ""

#: ../../examples/micropayment.rst:24 7c9ea6ca9e9e40cf9b1e0963daafeb22
msgid "The contract will work as follows:"
msgstr ""

#: ../../examples/micropayment.rst:26 9e468c5bd0bd4116a071953c6625ab0b
msgid "Alice deploys the ``ReceiverPays`` contract, attaching enough Ether to cover the payments that will be made."
msgstr ""

#: ../../examples/micropayment.rst:27 87c0b65a256f40b7a32eeed103afbb11
msgid "Alice authorises a payment by signing a message with her private key."
msgstr ""

#: ../../examples/micropayment.rst:28 786fd0bb09a0449ca9b6d73692545706
msgid "Alice sends the cryptographically signed message to Bob. The message does not need to be kept secret (explained later), and the mechanism for sending it does not matter."
msgstr ""

#: ../../examples/micropayment.rst:30 2a81719b792a4a34a1bf0ffadebb7991
msgid "Bob claims his payment by presenting the signed message to the smart contract, it verifies the authenticity of the message and then releases the funds."
msgstr ""

#: ../../examples/micropayment.rst:34 f0a8fd547fd044848b4d1a1e95eb5ec2
msgid "Creating the signature"
msgstr ""

#: ../../examples/micropayment.rst:36 7b920b658a9141069f0d1fa7fa9650db
msgid "Alice does not need to interact with the Ethereum network to sign the transaction, the process is completely offline. In this tutorial, we will sign messages in the browser using `web3.js <https://github.com/ethereum/web3.js>`_ and `MetaMask <https://metamask.io>`_, using the method described in `EIP-712 <https://github.com/ethereum/EIPs/pull/712>`_, as it provides a number of other security benefits."
msgstr ""

#: ../../examples/micropayment.rst:50 819cff18f7fe4c6f93ff182988ebfb61
msgid "The ``web3.eth.personal.sign`` prepends the length of the message to the signed data. Since we hash first, the message will always be exactly 32 bytes long, and thus this length prefix is always the same."
msgstr ""

#: ../../examples/micropayment.rst:56 86572949c78e4d0b84bcd5fe88991cc7
msgid "What to Sign"
msgstr ""

#: ../../examples/micropayment.rst:58 ab93ce3748a9416282aeca87d1c8dbd1
msgid "For a contract that fulfils payments, the signed message must include:"
msgstr ""

#: ../../examples/micropayment.rst:60 4e1e2d16e9884ece97000b925df841e5
msgid "The recipient's address."
msgstr ""

#: ../../examples/micropayment.rst:61 bac3076507bc4afdb109b3ddb033a33b
msgid "The amount to be transferred."
msgstr ""

#: ../../examples/micropayment.rst:62 5faf79e81cb84c7e8d744bd58c7d8e1e
msgid "Protection against replay attacks."
msgstr ""

#: ../../examples/micropayment.rst:64 6071b80414fc4cf997ee35865d7918b5
msgid "A replay attack is when a signed message is reused to claim authorization for a second action. To avoid replay attacks we use the same technique as in Ethereum transactions themselves, a so-called nonce, which is the number of transactions sent by an account. The smart contract checks if a nonce is used multiple times."
msgstr ""

#: ../../examples/micropayment.rst:70 a51d82acfc0744a08eb24003703157b7
msgid "Another type of replay attack can occur when the owner deploys a ``ReceiverPays`` smart contract, makes some payments, and then destroys the contract. Later, they decide to deploy the ``RecipientPays`` smart contract again, but the new contract does not know the nonces used in the previous deployment, so the attacker can use the old messages again."
msgstr ""

#: ../../examples/micropayment.rst:77 2b8548f7da884ac8ad7f7e70f70ce88d
msgid "Alice can protect against this attack by including the contract's address in the message, and only messages containing the contract's address itself will be accepted. You can find an example of this in the first two lines of the ``claimPayment()`` function of the full contract at the end of this section."
msgstr ""

#: ../../examples/micropayment.rst:84 3f743e3928cb4a399124a86c5c1ed677
msgid "Packing arguments"
msgstr ""

#: ../../examples/micropayment.rst:86 585f6907c12f4c8ea7191d80f540ad9c
msgid "Now that we have identified what information to include in the signed message, we are ready to put the message together, hash it, and sign it. For simplicity, we concatenate the data. The `ethereumjs-abi <https://github.com/ethereumjs/ethereumjs-abi>`_ library provides a function called ``soliditySHA3`` that mimics the behaviour of Solidity's ``keccak256`` function applied to arguments encoded using ``abi.encodePacked``. Here is a JavaScript function that creates the proper signature for the ``ReceiverPays`` example:"
msgstr ""

#: ../../examples/micropayment.rst:109 eff041fbebe741e293c169ad4414f8c0
msgid "Recovering the Message Signer in Solidity"
msgstr ""

#: ../../examples/micropayment.rst:111 79dc0071411f4885ad483d733d53cba9
msgid "In general, ECDSA signatures consist of two parameters, ``r`` and ``s``. Signatures in Ethereum include a third parameter called ``v``, that you can use to verify which account's private key was used to sign the message, and the transaction's sender. Solidity provides a built-in function :ref:`ecrecover <mathematical-and-cryptographic-functions>` that accepts a message along with the ``r``, ``s`` and ``v`` parameters and returns the address that was used to sign the message."
msgstr ""

#: ../../examples/micropayment.rst:121 0f54296a080f4bf1a26464a40a071400
msgid "Extracting the Signature Parameters"
msgstr ""

#: ../../examples/micropayment.rst:123 eb80878aea6b4865ad08196dd4159286
msgid "Signatures produced by web3.js are the concatenation of ``r``, ``s`` and ``v``, so the first step is to split these parameters apart. You can do this on the client-side, but doing it inside the smart contract means you only need to send one signature parameter rather than three. Splitting apart a byte array into its constituent parts is a mess, so we use :doc:`inline assembly <assembly>` to do the job in the ``splitSignature`` function (the third function in the full contract at the end of this section)."
msgstr ""

#: ../../examples/micropayment.rst:133 2f47a070c2f74d86a89b1c7a328bc269
msgid "Computing the Message Hash"
msgstr ""

#: ../../examples/micropayment.rst:135 bad8732b094a4097b401be5020e9f330
msgid "The smart contract needs to know exactly what parameters were signed, and so it must recreate the message from the parameters and use that for signature verification. The functions ``prefixed`` and ``recoverSigner`` do this in the ``claimPayment`` function."
msgstr ""

#: ../../examples/micropayment.rst:140 ../../examples/micropayment.rst:337
#: 7e646dafbeaa46dba32c52d50f6cc126 af8381b7bf6041dbb186b886ac01b5d3
msgid "The full contract"
msgstr ""

#: ../../examples/micropayment.rst:210 83b400a1df504d4ab7a5f94b632080e4
msgid "Writing a Simple Payment Channel"
msgstr ""

#: ../../examples/micropayment.rst:212 493c1323d429498298a655d529dd8e0b
msgid "Alice now builds a simple but complete implementation of a payment channel. Payment channels use cryptographic signatures to make repeated transfers of Ether securely, instantaneously, and without transaction fees."
msgstr ""

#: ../../examples/micropayment.rst:217 687eed5fca9d454aa390dcbe936379b6
msgid "What is a Payment Channel?"
msgstr ""

#: ../../examples/micropayment.rst:219 8a3fde8a4c35454d9149cfbe3760b8d5
msgid "Payment channels allow participants to make repeated transfers of Ether without using transactions. This means that you can avoid the delays and fees associated with transactions. We are going to explore a simple unidirectional payment channel between two parties (Alice and Bob). It involves three steps:"
msgstr ""

#: ../../examples/micropayment.rst:224 e1edcfcb2d82423c8ca67688f03f7478
msgid "Alice funds a smart contract with Ether. This \"opens\" the payment channel."
msgstr ""

#: ../../examples/micropayment.rst:225 66d2f599efbf4159905f8947da8e9b10
msgid "Alice signs messages that specify how much of that Ether is owed to the recipient. This step is repeated for each payment."
msgstr ""

#: ../../examples/micropayment.rst:226 2945f21e74224ba9803ade393963c1f2
msgid "Bob \"closes\" the payment channel, withdrawing his portion of the Ether and sending the remainder back to the sender."
msgstr ""

#: ../../examples/micropayment.rst:229 8c3faf7b750b469ba2fdf3075c53c9b3
msgid "Only steps 1 and 3 require Ethereum transactions, step 2 means that the sender transmits a cryptographically signed message to the recipient via off chain methods (e.g. email). This means only two transactions are required to support any number of transfers."
msgstr ""

#: ../../examples/micropayment.rst:234 33527bdfecb6493cafb38cf9ccefb9ae
msgid "Bob is guaranteed to receive his funds because the smart contract escrows the Ether and honours a valid signed message. The smart contract also enforces a timeout, so Alice is guaranteed to eventually recover her funds even if the recipient refuses to close the channel. It is up to the participants in a payment channel to decide how long to keep it open. For a short-lived transaction, such as paying an internet café for each minute of network access, the payment channel may be kept open for a limited duration. On the other hand, for a recurring payment, such as paying an employee an hourly wage, the payment channel may be kept open for several months or years."
msgstr ""

#: ../../examples/micropayment.rst:245 b12dc770f0c04a96bd1e566b073714a4
msgid "Opening the Payment Channel"
msgstr ""

#: ../../examples/micropayment.rst:247 6b4cc2b7ce0748e9b9a5a7f355d1141d
msgid "To open the payment channel, Alice deploys the smart contract, attaching the Ether to be escrowed and specifying the intended recipient and a maximum duration for the channel to exist. This is the function ``SimplePaymentChannel`` in the contract, at the end of this section."
msgstr ""

#: ../../examples/micropayment.rst:253 e4a52b60a4f448718d0457fc028a62cb
msgid "Making Payments"
msgstr ""

#: ../../examples/micropayment.rst:255 2e3533cbc27247cf9fde5b7c8b8df433
msgid "Alice makes payments by sending signed messages to Bob. This step is performed entirely outside of the Ethereum network. Messages are cryptographically signed by the sender and then transmitted directly to the recipient."
msgstr ""

#: ../../examples/micropayment.rst:259 92f5daeaf4ec4e2aabde215935279c3b
msgid "Each message includes the following information:"
msgstr ""

#: ../../examples/micropayment.rst:261 3644c517602a4df6ba1be05fac4896ba
msgid "The smart contract's address, used to prevent cross-contract replay attacks."
msgstr ""

#: ../../examples/micropayment.rst:262 e403679105544f61ba5241222095acc1
msgid "The total amount of Ether that is owed the recipient so far."
msgstr ""

#: ../../examples/micropayment.rst:264 1cb15801ec584e66a9a55a7dbb2dfaf7
msgid "A payment channel is closed just once, at the end of a series of transfers. Because of this, only one of the messages sent is redeemed. This is why each message specifies a cumulative total amount of Ether owed, rather than the amount of the individual micropayment. The recipient will naturally choose to redeem the most recent message because that is the one with the highest total. The nonce per-message is not needed anymore, because the smart contract only honours a single message. The address of the smart contract is still used to prevent a message intended for one payment channel from being used for a different channel."
msgstr ""

#: ../../examples/micropayment.rst:273 8002f6f81a004195a03b94121402b2ee
msgid "Here is the modified JavaScript code to cryptographically sign a message from the previous section:"
msgstr ""

#: ../../examples/micropayment.rst:302 ec7357531e9a4ed79d3f506d3d77508d
msgid "Closing the Payment Channel"
msgstr ""

#: ../../examples/micropayment.rst:304 107b63eae9704acabced1b93dde74ca5
msgid "When Bob is ready to receive his funds, it is time to close the payment channel by calling a ``close`` function on the smart contract. Closing the channel pays the recipient the Ether they are owed and destroys the contract, sending any remaining Ether back to Alice. To close the channel, Bob needs to provide a message signed by Alice."
msgstr ""

#: ../../examples/micropayment.rst:310 890962f91f7145478773752a025091f9
msgid "The smart contract must verify that the message contains a valid signature from the sender. The process for doing this verification is the same as the process the recipient uses. The Solidity functions ``isValidSignature`` and ``recoverSigner`` work just like their JavaScript counterparts in the previous section, with the latter function borrowed from the ``ReceiverPays`` contract."
msgstr ""

#: ../../examples/micropayment.rst:315 957463dd38f843f5bec1ee4f77c5bdd9
msgid "Only the payment channel recipient can call the ``close`` function, who naturally passes the most recent payment message because that message carries the highest total owed. If the sender were allowed to call this function, they could provide a message with a lower amount and cheat the recipient out of what they are owed."
msgstr ""

#: ../../examples/micropayment.rst:320 e731ef7986ee46ca831bf2dc350561ef
msgid "The function verifies the signed message matches the given parameters. If everything checks out, the recipient is sent their portion of the Ether, and the sender is sent the rest via a ``selfdestruct``. You can see the ``close`` function in the full contract."
msgstr ""

#: ../../examples/micropayment.rst:326 e5248ee1e8d14e85ab73819afefa4065
msgid "Channel Expiration"
msgstr ""

#: ../../examples/micropayment.rst:328 af6887683abd4b4298aa3cf6075b7a98
msgid "Bob can close the payment channel at any time, but if they fail to do so, Alice needs a way to recover her escrowed funds. An *expiration* time was set at the time of contract deployment. Once that time is reached, Alice can call ``claimTimeout`` to recover her funds. You can see the ``claimTimeout`` function in the full contract."
msgstr ""

#: ../../examples/micropayment.rst:333 baf56385059645c2b6707ce3dd9db200
msgid "After this function is called, Bob can no longer receive any Ether, so it is important that Bob closes the channel before the expiration is reached."
msgstr ""

#: ../../examples/micropayment.rst:434 5914e4a665b549f1877fbfc905ac24cb
msgid "The function ``splitSignature`` does not use all security checks. A real implementation should use a more rigorously tested library, such as openzepplin's `version  <https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol>`_ of this code."
msgstr ""

#: ../../examples/micropayment.rst:439 9c137e42d8d84b83a2ce0a20759fb5fa
msgid "Verifying Payments"
msgstr ""

#: ../../examples/micropayment.rst:441 e7bd0a481b07440c8f9952c6f24b1b0a
msgid "Unlike in the previous section, messages in a payment channel aren't redeemed right away. The recipient keeps track of the latest message and redeems it when it's time to close the payment channel. This means it's critical that the recipient perform their own verification of each message. Otherwise there is no guarantee that the recipient will be able to get paid in the end."
msgstr ""

#: ../../examples/micropayment.rst:448 ecc7563545f04a1e89c33f142a29b63b
msgid "The recipient should verify each message using the following process:"
msgstr ""

#: ../../examples/micropayment.rst:450 05df4d10a4034d4292a53ddc8aefa7e6
msgid "Verify that the contract address in the message matches the payment channel."
msgstr ""

#: ../../examples/micropayment.rst:451 5c02f09fc60c4088a773c400dd6ef0e4
msgid "Verify that the new total is the expected amount."
msgstr ""

#: ../../examples/micropayment.rst:452 eac7a8c09d7441228fce4cdc918afa01
msgid "Verify that the new total does not exceed the amount of Ether escrowed."
msgstr ""

#: ../../examples/micropayment.rst:453 37b0ab8df259449c81215787d4027e68
msgid "Verify that the signature is valid and comes from the payment channel sender."
msgstr ""

#: ../../examples/micropayment.rst:455 569877bb01ef4ffaa7414aeefe07c8e5
msgid "We'll use the `ethereumjs-util <https://github.com/ethereumjs/ethereumjs-util>`_ library to write this verification. The final step can be done a number of ways, and we use JavaScript. The following code borrows the ``constructPaymentMessage`` function from the signing **JavaScript code** above:"
msgstr ""

#: ../../examples/modular.rst:5 022a6dfd39a4485b81c3d03bcc918385
msgid "Modular Contracts"
msgstr ""

#: ../../examples/modular.rst:7 125efc9e4f574242802faf610d134521
msgid "A modular approach to building your contracts helps you reduce the complexity and improve the readability which will help to identify bugs and vulnerabilities during development and code review. If you specify and control the behaviour or each module in isolation, the interactions you have to consider are only those between the module specifications and not every other moving part of the contract. In the example below, the contract uses the ``move`` method of the ``Balances`` :ref:`library <libraries>` to check that balances sent between addresses match what you expect. In this way, the ``Balances`` library provides an isolated component that properly tracks balances of accounts. It is easy to verify that the ``Balances`` library never produces negative balances or overflows and the sum of all balances is an invariant across the lifetime of the contract."
msgstr ""

