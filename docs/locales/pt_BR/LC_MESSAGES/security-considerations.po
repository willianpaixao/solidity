# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2016-2021, Ethereum
# This file is distributed under the same license as the Solidity package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Solidity 0.8.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-01-13 16:47+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../security-considerations.rst:5 ef2c61a6ed814bf2ac289524a59685b7
msgid "Security Considerations"
msgstr ""

#: ../../security-considerations.rst:7 642276f726da44a987d2d52852864129
msgid ""
"While it is usually quite easy to build software that works as expected, "
"it is much harder to check that nobody can use it in a way that was "
"**not** anticipated."
msgstr ""

#: ../../security-considerations.rst:10 e0cfacfc2c83476fb6623cb842dff6a9
msgid ""
"In Solidity, this is even more important because you can use smart "
"contracts to handle tokens or, possibly, even more valuable things. "
"Furthermore, every execution of a smart contract happens in public and, "
"in addition to that, the source code is often available."
msgstr ""

#: ../../security-considerations.rst:15 18260ba9bbef49e4bfb8a084f94ee41f
msgid ""
"Of course you always have to consider how much is at stake: You can "
"compare a smart contract with a web service that is open to the public "
"(and thus, also to malicious actors) and perhaps even open source. If you"
" only store your grocery list on that web service, you might not have to "
"take too much care, but if you manage your bank account using that web "
"service, you should be more careful."
msgstr ""

#: ../../security-considerations.rst:22 33e33ab9b364430d9935d3650204d766
msgid ""
"This section will list some pitfalls and general security recommendations"
" but can, of course, never be complete.  Also, keep in mind that even if "
"your smart contract code is bug-free, the compiler or the platform itself"
" might have a bug. A list of some publicly known security-relevant bugs "
"of the compiler can be found in the :ref:`list of known "
"bugs<known_bugs>`, which is also machine-readable. Note that there is a "
"bug bounty program that covers the code generator of the Solidity "
"compiler."
msgstr ""

#: ../../security-considerations.rst:30 787b5b9609c846fb88cc9b0689a1bd88
msgid ""
"As always, with open source documentation, please help us extend this "
"section (especially, some examples would not hurt)!"
msgstr ""

#: ../../security-considerations.rst:33 45a0e6fc60654dc489cee08b0716ad9c
msgid ""
"NOTE: In addition to the list below, you can find more security "
"recommendations and best practices `in Guy Lando's knowledge list "
"<https://github.com/guylando/KnowledgeLists/blob/master/EthereumSmartContracts.md>`_"
" and `the Consensys GitHub repo <https://consensys.github.io/smart-"
"contract-best-practices/>`_."
msgstr ""

#: ../../security-considerations.rst:39 ebafab5b68c2404ea8dff798995921b8
msgid "Pitfalls"
msgstr ""

#: ../../security-considerations.rst:42 fcba4f62eb144f379f6179666b11d84f
msgid "Private Information and Randomness"
msgstr ""

#: ../../security-considerations.rst:44 c9032b2d7b8e485a9ab2249fef95d759
msgid ""
"Everything you use in a smart contract is publicly visible, even local "
"variables and state variables marked ``private``."
msgstr ""

#: ../../security-considerations.rst:47 4c82c29cee154995a05714144c474aa2
msgid ""
"Using random numbers in smart contracts is quite tricky if you do not "
"want miners to be able to cheat."
msgstr ""

#: ../../security-considerations.rst:51 580c947241a44d418df58af7f7538e89
msgid "Re-Entrancy"
msgstr ""

#: ../../security-considerations.rst:53 60be6f9ac31c41658e5e5a4660b1d3cc
msgid ""
"Any interaction from a contract (A) with another contract (B) and any "
"transfer of Ether hands over control to that contract (B). This makes it "
"possible for B to call back into A before this interaction is completed. "
"To give an example, the following code contains a bug (it is just a "
"snippet and not a complete contract):"
msgstr ""

#: ../../security-considerations.rst:75 9d027b03a3e54d469f616d4c2e25f4f7
msgid ""
"The problem is not too serious here because of the limited gas as part of"
" ``send``, but it still exposes a weakness: Ether transfer can always "
"include code execution, so the recipient could be a contract that calls "
"back into ``withdraw``. This would let it get multiple refunds and "
"basically retrieve all the Ether in the contract. In particular, the "
"following contract will allow an attacker to refund multiple times as it "
"uses ``call`` which forwards all remaining gas by default:"
msgstr ""

#: ../../security-considerations.rst:100 f1979d39eea143b8aec7295e5d762335
msgid ""
"To avoid re-entrancy, you can use the Checks-Effects-Interactions pattern"
" as outlined further below:"
msgstr ""

#: ../../security-considerations.rst:119 8eff4c4ba8ad449ba666aca28226ce39
msgid ""
"Note that re-entrancy is not only an effect of Ether transfer but of any "
"function call on another contract. Furthermore, you also have to take "
"multi-contract situations into account. A called contract could modify "
"the state of another contract you depend on."
msgstr ""

#: ../../security-considerations.rst:125 f7f4a7c886594757a11e956e9594cd1f
msgid "Gas Limit and Loops"
msgstr ""

#: ../../security-considerations.rst:127 8c6795bff9e84c619cccb5f12d36f51a
msgid ""
"Loops that do not have a fixed number of iterations, for example, loops "
"that depend on storage values, have to be used carefully: Due to the "
"block gas limit, transactions can only consume a certain amount of gas. "
"Either explicitly or just due to normal operation, the number of "
"iterations in a loop can grow beyond the block gas limit which can cause "
"the complete contract to be stalled at a certain point. This may not "
"apply to ``view`` functions that are only executed to read data from the "
"blockchain. Still, such functions may be called by other contracts as "
"part of on-chain operations and stall those. Please be explicit about "
"such cases in the documentation of your contracts."
msgstr ""

#: ../../security-considerations.rst:135 6db1ecda04af4a8397f0411be9204dc7
msgid "Sending and Receiving Ether"
msgstr ""

#: ../../security-considerations.rst:137 662aeb2927c747b89cf1020d76ffd18a
msgid ""
"Neither contracts nor \"external accounts\" are currently able to prevent"
" that someone sends them Ether. Contracts can react on and reject a "
"regular transfer, but there are ways to move Ether without creating a "
"message call. One way is to simply \"mine to\" the contract address and "
"the second way is using ``selfdestruct(x)``."
msgstr ""

#: ../../security-considerations.rst:142 9cc6dcb156064e6cb445978bb48d3627
msgid ""
"If a contract receives Ether (without a function being called), either "
"the :ref:`receive Ether <receive-ether-function>` or the :ref:`fallback "
"<fallback-function>` function is executed. If it does not have a receive "
"nor a fallback function, the Ether will be rejected (by throwing an "
"exception). During the execution of one of these functions, the contract "
"can only rely on the \"gas stipend\" it is passed (2300 gas) being "
"available to it at that time. This stipend is not enough to modify "
"storage (do not take this for granted though, the stipend might change "
"with future hard forks). To be sure that your contract can receive Ether "
"in that way, check the gas requirements of the receive and fallback "
"functions (for example in the \"details\" section in Remix)."
msgstr ""

#: ../../security-considerations.rst:154 42e4e8756e784079bcee55e4fa42e984
msgid ""
"There is a way to forward more gas to the receiving contract using "
"``addr.call{value: x}(\"\")``. This is essentially the same as "
"``addr.transfer(x)``, only that it forwards all remaining gas and opens "
"up the ability for the recipient to perform more expensive actions (and "
"it returns a failure code instead of automatically propagating the "
"error). This might include calling back into the sending contract or "
"other state changes you might not have thought of. So it allows for great"
" flexibility for honest users but also for malicious actors."
msgstr ""

#: ../../security-considerations.rst:162 cc5b68ee94a64f38a405e77ee488ee75
msgid ""
"Use the most precise units to represent the wei amount as possible, as "
"you lose any that is rounded due to a lack of precision."
msgstr ""

#: ../../security-considerations.rst:165 2f55a6e6f51a457e914c01d430d87e77
msgid ""
"If you want to send Ether using ``address.transfer``, there are certain "
"details to be aware of:"
msgstr ""

#: ../../security-considerations.rst:167 7011c07018fa4a64845de1e369a7d146
msgid ""
"If the recipient is a contract, it causes its receive or fallback "
"function to be executed which can, in turn, call back the sending "
"contract."
msgstr ""

#: ../../security-considerations.rst:169 d934da1ddc29439f9374f4187b5fed73
msgid ""
"Sending Ether can fail due to the call depth going above 1024. Since the "
"caller is in total control of the call depth, they can force the transfer"
" to fail; take this possibility into account or use ``send`` and make "
"sure to always check its return value. Better yet, write your contract "
"using a pattern where the recipient can withdraw Ether instead."
msgstr ""

#: ../../security-considerations.rst:174 e89ed0ffb4b742f7a7dd7bd5dc5af1f5
msgid ""
"Sending Ether can also fail because the execution of the recipient "
"contract requires more than the allotted amount of gas (explicitly by "
"using :ref:`require <assert-and-require>`, :ref:`assert <assert-and-"
"require>`, :ref:`revert <assert-and-require>` or because the operation is"
" too expensive) - it \"runs out of gas\" (OOG).  If you use ``transfer`` "
"or ``send`` with a return value check, this might provide a means for the"
" recipient to block progress in the sending contract. Again, the best "
"practice here is to use a :ref:`\"withdraw\" pattern instead of a "
"\"send\" pattern <withdrawal_pattern>`."
msgstr ""

#: ../../security-considerations.rst:185 f64299724ae64252975bc6c22bb93bec
msgid "Call Stack Depth"
msgstr ""

#: ../../security-considerations.rst:187 532039cdc7dc44a1981fa4e938a45e55
msgid ""
"External function calls can fail any time because they exceed the maximum"
" call stack size limit of 1024. In such situations, Solidity throws an "
"exception. Malicious actors might be able to force the call stack to a "
"high value before they interact with your contract. Note that, since "
"`Tangerine Whistle <https://eips.ethereum.org/EIPS/eip-608>`_ hardfork, "
"the `63/64 rule <https://eips.ethereum.org/EIPS/eip-150>`_ makes call "
"stack depth attack impractical. Also note that the call stack and the "
"expression stack are unrelated, even though both have a size limit of "
"1024 stack slots."
msgstr ""

#: ../../security-considerations.rst:192 971038c3034b46cab7b0f02c0163305b
msgid ""
"Note that ``.send()`` does **not** throw an exception if the call stack "
"is depleted but rather returns ``false`` in that case. The low-level "
"functions ``.call()``, ``.delegatecall()`` and ``.staticcall()`` behave "
"in the same way."
msgstr ""

#: ../../security-considerations.rst:197 a89d0504c5f74c249e49156addd7b2db
msgid "Authorized Proxies"
msgstr ""

#: ../../security-considerations.rst:199 608efd2b643a42088fbcc311c8732120
msgid ""
"If your contract can act as a proxy, i.e. if it can call arbitrary "
"contracts with user-supplied data, then the user can essentially assume "
"the identity of the proxy contract. Even if you have other protective "
"measures in place, it is best to build your contract system such that the"
" proxy does not have any permissions (not even for itself). If needed, "
"you can accomplish that using a second proxy:"
msgstr ""

#: ../../security-considerations.rst:230 6427013dd9f94b47b3d6cd3ef0b3c893
msgid "tx.origin"
msgstr ""

#: ../../security-considerations.rst:232 7ab14d0770ee478b99e7ee172ac1c250
msgid ""
"Never use tx.origin for authorization. Let's say you have a wallet "
"contract like this:"
msgstr ""

#: ../../security-considerations.rst:253 7bb87a989ed94192b0d9ebaf6c52110a
msgid ""
"Now someone tricks you into sending Ether to the address of this attack "
"wallet:"
msgstr ""

#: ../../security-considerations.rst:275 fa9a55f31e244e5bb530e65c8ec6228c
msgid ""
"If your wallet had checked ``msg.sender`` for authorization, it would get"
" the address of the attack wallet, instead of the owner address. But by "
"checking ``tx.origin``, it gets the original address that kicked off the "
"transaction, which is still the owner address. The attack wallet "
"instantly drains all your funds."
msgstr ""

#: ../../security-considerations.rst:280 9239959283e24a6ea9a11a4bc31ab1f2
msgid "Two's Complement / Underflows / Overflows"
msgstr ""

#: ../../security-considerations.rst:282 a689ca08e1444869835ac23a2b7c669f
msgid ""
"As in many programming languages, Solidity's integer types are not "
"actually integers. They resemble integers when the values are small, but "
"cannot represent arbitrarily large numbers."
msgstr ""

#: ../../security-considerations.rst:285 957d6161145e459f96f9f8a992496101
msgid ""
"The following code causes an overflow because the result of the addition "
"is too large to be stored in the type ``uint8``:"
msgstr ""

#: ../../security-considerations.rst:294 5f96d90e0eee4c90af667d773a07a76e
msgid ""
"Solidity has two modes in which it deals with these overflows: Checked "
"and Unchecked or \"wrapping\" mode."
msgstr ""

#: ../../security-considerations.rst:296 9b909abff4d14eba85a588d3b20eee97
msgid ""
"The default checked mode will detect overflows and cause a failing "
"assertion. You can disable this check using ``unchecked { ... }``, "
"causing the overflow to be silently ignored. The above code would return "
"``0`` if wrapped in ``unchecked { ... }``."
msgstr ""

#: ../../security-considerations.rst:300 f612032b0a6b4dc786be3a674ea730e2
msgid ""
"Even in checked mode, do not assume you are protected from overflow bugs."
" In this mode, overflows will always revert. If it is not possible to "
"avoid the overflow, this can lead to a smart contract being stuck in a "
"certain state."
msgstr ""

#: ../../security-considerations.rst:304 553e5c989cf04cbc97f29ed282f49e34
msgid ""
"In general, read about the limits of two's complement representation, "
"which even has some more special edge cases for signed numbers."
msgstr ""

#: ../../security-considerations.rst:307 a0f75276e1e44eafa052947a172dda88
msgid ""
"Try to use ``require`` to limit the size of inputs to a reasonable range "
"and use the :ref:`SMT checker<smt_checker>` to find potential overflows."
msgstr ""

#: ../../security-considerations.rst:313 534ba70c594d4e7d9295312885444ad7
msgid "Clearing Mappings"
msgstr ""

#: ../../security-considerations.rst:315 18b81608f12e4c1db3335b8651f70a48
msgid ""
"The Solidity type ``mapping`` (see :ref:`mapping-types`) is a storage-"
"only key-value data structure that does not keep track of the keys that "
"were assigned a non-zero value.  Because of that, cleaning a mapping "
"without extra information about the written keys is not possible. If a "
"``mapping`` is used as the base type of a dynamic storage array, deleting"
" or popping the array will have no effect over the ``mapping`` elements."
"  The same happens, for example, if a ``mapping`` is used as the type of "
"a member field of a ``struct`` that is the base type of a dynamic storage"
" array.  The ``mapping`` is also ignored in assignments of structs or "
"arrays containing a ``mapping``."
msgstr ""

#: ../../security-considerations.rst:352 ecf51f71349f41318fc933036bca0274
msgid ""
"Consider the example above and the following sequence of calls: "
"``allocate(10)``, ``writeMap(4, 128, 256)``. At this point, calling "
"``readMap(4, 128)`` returns 256. If we call ``eraseMaps``, the length of "
"state variable ``array`` is zeroed, but since its ``mapping`` elements "
"cannot be zeroed, their information stays alive in the contract's "
"storage. After deleting ``array``, calling ``allocate(5)`` allows us to "
"access ``array[4]`` again, and calling ``readMap(4, 128)`` returns 256 "
"even without another call to ``writeMap``."
msgstr ""

#: ../../security-considerations.rst:362 fcb746c369e74fb881ab63e8e04158cd
msgid ""
"If your ``mapping`` information must be deleted, consider using a library"
" similar to `iterable mapping <https://github.com/ethereum/dapp-"
"bin/blob/master/library/iterable_mapping.sol>`_, allowing you to traverse"
" the keys and delete their values in the appropriate ``mapping``."
msgstr ""

#: ../../security-considerations.rst:367 6dbd39f089f446b2bf1e7ad857269df1
msgid "Minor Details"
msgstr ""

#: ../../security-considerations.rst:369 50e853cbbfad494386cbeb08eabe6c59
msgid ""
"Types that do not occupy the full 32 bytes might contain \"dirty higher "
"order bits\". This is especially important if you access ``msg.data`` - "
"it poses a malleability risk: You can craft transactions that call a "
"function ``f(uint8 x)`` with a raw byte argument of ``0xff000001`` and "
"with ``0x00000001``. Both are fed to the contract and both will look like"
" the number ``1`` as far as ``x`` is concerned, but ``msg.data`` will be "
"different, so if you use ``keccak256(msg.data)`` for anything, you will "
"get different results."
msgstr ""

#: ../../security-considerations.rst:378 e6892eced04f4357ac7d6138736ab378
msgid "Recommendations"
msgstr ""

#: ../../security-considerations.rst:381 6044929dde43464ba2843643c30d9bba
msgid "Take Warnings Seriously"
msgstr ""

#: ../../security-considerations.rst:383 5ed5150ebba043b3b8f2a923b9cf4290
msgid ""
"If the compiler warns you about something, you should change it. Even if "
"you do not think that this particular warning has security implications, "
"there might be another issue buried beneath it. Any compiler warning we "
"issue can be silenced by slight changes to the code."
msgstr ""

#: ../../security-considerations.rst:389 86212fc16ff54563a0c38e6e4f961ce6
msgid ""
"Always use the latest version of the compiler to be notified about all "
"recently introduced warnings."
msgstr ""

#: ../../security-considerations.rst:392 aa15ea9372534324a7c669c2742d1a5f
msgid ""
"Messages of type ``info`` issued by the compiler are not dangerous, and "
"simply represent extra suggestions and optional information that the "
"compiler thinks might be useful to the user."
msgstr ""

#: ../../security-considerations.rst:397 6ba686bdbd4d47629cdda5cc1136744e
msgid "Restrict the Amount of Ether"
msgstr ""

#: ../../security-considerations.rst:399 544c1181508f464c858f5568183eea35
msgid ""
"Restrict the amount of Ether (or other tokens) that can be stored in a "
"smart contract. If your source code, the compiler or the platform has a "
"bug, these funds may be lost. If you want to limit your loss, limit the "
"amount of Ether."
msgstr ""

#: ../../security-considerations.rst:404 6cbd00c0e2214d4b846ce636134fc04a
msgid "Keep it Small and Modular"
msgstr ""

#: ../../security-considerations.rst:406 d90099169bf34cd28f23cc799adf53c7
msgid ""
"Keep your contracts small and easily understandable. Single out unrelated"
" functionality in other contracts or into libraries. General "
"recommendations about source code quality of course apply: Limit the "
"amount of local variables, the length of functions and so on. Document "
"your functions so that others can see what your intention was and whether"
" it is different than what the code does."
msgstr ""

#: ../../security-considerations.rst:413 ba41abda37ee4a43843b6c158ef417d8
msgid "Use the Checks-Effects-Interactions Pattern"
msgstr ""

#: ../../security-considerations.rst:415 c382628624034124897573f1ff60ef73
msgid ""
"Most functions will first perform some checks (who called the function, "
"are the arguments in range, did they send enough Ether, does the person "
"have tokens, etc.). These checks should be done first."
msgstr ""

#: ../../security-considerations.rst:419 6bf660c7cb534fccbac734ae3010965e
msgid ""
"As the second step, if all checks passed, effects to the state variables "
"of the current contract should be made. Interaction with other contracts "
"should be the very last step in any function."
msgstr ""

#: ../../security-considerations.rst:423 e65d04f45ce546338beb594853ee17af
msgid ""
"Early contracts delayed some effects and waited for external function "
"calls to return in a non-error state. This is often a serious mistake "
"because of the re-entrancy problem explained above."
msgstr ""

#: ../../security-considerations.rst:427 67f8ea7b80644a63838c597fa6c59e65
msgid ""
"Note that, also, calls to known contracts might in turn cause calls to "
"unknown contracts, so it is probably better to just always apply this "
"pattern."
msgstr ""

#: ../../security-considerations.rst:431 618ba5f9cdb94c08b95879e4996029df
msgid "Include a Fail-Safe Mode"
msgstr ""

#: ../../security-considerations.rst:433 757e662f3fc14673bf1f148bf767c1d3
msgid ""
"While making your system fully decentralised will remove any "
"intermediary, it might be a good idea, especially for new code, to "
"include some kind of fail-safe mechanism:"
msgstr ""

#: ../../security-considerations.rst:437 7c47a237319d4ec99651f9e51f07adf8
msgid ""
"You can add a function in your smart contract that performs some self-"
"checks like \"Has any Ether leaked?\", \"Is the sum of the tokens equal "
"to the balance of the contract?\" or similar things. Keep in mind that "
"you cannot use too much gas for that, so help through off-chain "
"computations might be needed there."
msgstr ""

#: ../../security-considerations.rst:443 20c79c83b61049c2bdd39f13747d21bd
msgid ""
"If the self-check fails, the contract automatically switches into some "
"kind of \"failsafe\" mode, which, for example, disables most of the "
"features, hands over control to a fixed and trusted third party or just "
"converts the contract into a simple \"give me back my money\" contract."
msgstr ""

#: ../../security-considerations.rst:449 cf58f7e28f2241d5a765914a5c712373
msgid "Ask for Peer Review"
msgstr ""

#: ../../security-considerations.rst:451 4fbb382c51a740f9b4ee41a18b937b73
msgid ""
"The more people examine a piece of code, the more issues are found. "
"Asking people to review your code also helps as a cross-check to find out"
" whether your code is easy to understand - a very important criterion for"
" good smart contracts."
msgstr ""

