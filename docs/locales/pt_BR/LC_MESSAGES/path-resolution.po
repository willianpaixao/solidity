# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2016-2021, Ethereum
# This file is distributed under the same license as the Solidity package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Solidity 0.8.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-01-13 16:47+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../path-resolution.rst:5 c5f1a6f807274ce59f99649a13a1dd6c
msgid "Import Path Resolution"
msgstr ""

#: ../../path-resolution.rst:7 0b72c4cec2344507ac9ce3e79ef2faf4
msgid ""
"In order to be able to support reproducible builds on all platforms, the "
"Solidity compiler has to abstract away the details of the filesystem "
"where source files are stored. Paths used in imports must work the same "
"way everywhere while the command-line interface must be able to work with"
" platform-specific paths to provide good user experience. This section "
"aims to explain in detail how Solidity reconciles these requirements."
msgstr ""

#: ../../path-resolution.rst:17 bc6cd8d4eaeb449db0001c0d52465929
msgid "Virtual Filesystem"
msgstr ""

#: ../../path-resolution.rst:19 64681b372ae147fbaba0a0923a5c311e
msgid ""
"The compiler maintains an internal database (*virtual filesystem* or "
"*VFS* for short) where each source unit is assigned a unique *source unit"
" name* which is an opaque and unstructured identifier. When you use the "
":ref:`import statement <import>`, you specify an *import path* that "
"references a source unit name."
msgstr ""

#: ../../path-resolution.rst:28 9d404613f369489ea5db274b431fdbda
msgid "Import Callback"
msgstr ""

#: ../../path-resolution.rst:30 7f702256592e4362a12f03cbad28e12d
msgid ""
"The VFS is initially populated only with files the compiler has received "
"as input. Additional files can be loaded during compilation using an "
"*import callback*, which is different depending on the type of compiler "
"you use (see below). If the compiler does not find any source unit name "
"matching the import path in the VFS, it invokes the callback, which is "
"responsible for obtaining the source code to be placed under that name. "
"An import callback is free to interpret source unit names in an arbitrary"
" way, not just as paths. If there is no callback available when one is "
"needed or if it fails to locate the source code, compilation fails."
msgstr ""

#: ../../path-resolution.rst:39 2aa8382b9b284ee5bbce16a126ceb2c4
msgid ""
"The command-line compiler provides the *Host Filesystem Loader* - a "
"rudimentary callback that interprets a source unit name as a path in the "
"local filesystem. The `JavaScript interface <https://github.com/ethereum"
"/solc-js>`_ does not provide any by default, but one can be provided by "
"the user. This mechanism can be used to obtain source code from locations"
" other then the local filesystem (which may not even be accessible, e.g. "
"when the compiler is running in a browser). For example the `Remix IDE "
"<https://remix.ethereum.org/>`_ provides a versatile callback that lets "
"you `import files from HTTP, IPFS and Swarm URLs or refer directly to "
"packages in NPM registry <https://remix-"
"ide.readthedocs.io/en/latest/import.html>`_."
msgstr ""

#: ../../path-resolution.rst:51 a25c3c77bec843298ae69dbb5b38f792
msgid ""
"Host Filesystem Loader's file lookup is platform-dependent. For example "
"backslashes in a source unit name can be interpreted as directory "
"separators or not and the lookup can be case-sensitive or not, depending "
"on the underlying platform."
msgstr ""

#: ../../path-resolution.rst:55 0b59ea984b5942dea2614ed93b4bb083
msgid ""
"For portability it is recommended to avoid using import paths that will "
"work correctly only with a specific import callback or only on one "
"platform. For example you should always use forward slashes since they "
"work as path separators also on platforms that support backslashes."
msgstr ""

#: ../../path-resolution.rst:61 5811d4249f304e1f8ee3d2cadea28d55
msgid "Initial Content of the Virtual Filesystem"
msgstr ""

#: ../../path-resolution.rst:63 1227dae3cb2c4eaa80268f227b5a6c78
msgid "The initial content of the VFS depends on how you invoke the compiler:"
msgstr ""

#: ../../path-resolution.rst:65 7f1495bf279f45a89f3ff4958d25b1d4
msgid "**solc / command-line interface**"
msgstr ""

#: ../../path-resolution.rst:67 0bd6099ec23a4baa8fb40c7b1a946ebe
msgid ""
"When you compile a file using the command-line interface of the compiler,"
" you provide one or more paths to files containing Solidity code:"
msgstr ""

#: ../../path-resolution.rst:74 2a9e686ad0974ca59d057cda1465864c
msgid ""
"The source unit name of a file loaded this way is constructed by "
"converting its path to a canonical form and, if possible, making it "
"relative to either the base path or one of the include paths. See "
":ref:`CLI Path Normalization and Stripping <cli-path-normalization-and-"
"stripping>` for a detailed description of this process."
msgstr ""

#: ../../path-resolution.rst:82 339f6f92ee0649ae91f0d90bc8b2ec3c
msgid "**Standard JSON**"
msgstr ""

#: ../../path-resolution.rst:84 f77c119864c4411ca23b24f555d2117b
msgid ""
"When using the :ref:`Standard JSON <compiler-api>` API (via either the "
"`JavaScript interface <https://github.com/ethereum/solc-js>`_ or the "
"``--standard-json`` command-line option) you provide input in JSON "
"format, containing, among other things, the content of all your source "
"files:"
msgstr ""

#: ../../path-resolution.rst:107 deb8910341f4470c975a62defd7c576e
msgid ""
"The ``sources`` dictionary becomes the initial content of the virtual "
"filesystem and its keys are used as source unit names."
msgstr ""

#: ../../path-resolution.rst:112 dc7d5d5d846340eca63c87ca719106df
msgid "**Standard JSON (via import callback)**"
msgstr ""

#: ../../path-resolution.rst:114 0ed6a0d3ff24475c84f8f0fbd319945c
msgid ""
"With Standard JSON it is also possible to tell the compiler to use the "
"import callback to obtain the source code:"
msgstr ""

#: ../../path-resolution.rst:132 5f725b8d3b4546bcbed8653b116085d1
msgid ""
"If an import callback is available, the compiler will give it the strings"
" specified in ``urls`` one by one, until one is loaded successfully or "
"the end of the list is reached."
msgstr ""

#: ../../path-resolution.rst:135 0e5c0584724341be9ac8bc2a1af71a6b
msgid ""
"The source unit names are determined the same way as when using "
"``content`` - they are keys of the ``sources`` dictionary and the content"
" of ``urls`` does not affect them in any way."
msgstr ""

#: ../../path-resolution.rst:140 ba5b4d1a611640ae9151d9e014823ddd
msgid "**Standard input**"
msgstr ""

#: ../../path-resolution.rst:142 134ae5036e7a47ae887f5c727e0ed0d8
msgid ""
"On the command line it is also possible to provide the source by sending "
"it to compiler's standard input:"
msgstr ""

#: ../../path-resolution.rst:149 eecfcc5e64d6463bb69b7c7c8e046aec
msgid ""
"``-`` used as one of the arguments instructs the compiler to place the "
"content of the standard input in the virtual filesystem under a special "
"source unit name: ``<stdin>``."
msgstr ""

#: ../../path-resolution.rst:152 46ba5b3b762143a09d42edf4a626237e
msgid ""
"Once the VFS is initialized, additional files can still be added to it "
"only through the import callback."
msgstr ""

#: ../../path-resolution.rst:158 e98b50df22404ced825aab8cda75867d
msgid "Imports"
msgstr ""

#: ../../path-resolution.rst:160 01aae706a7dd43a5a5a6e3a7e3b9e75d
msgid ""
"The import statement specifies an *import path*. Based on how the import "
"path is specified, we can divide imports into two categories:"
msgstr ""

#: ../../path-resolution.rst:163 355cc6bee2e54abb951f3a9692332a1d
msgid ""
":ref:`Direct imports <direct-imports>`, where you specify the full source"
" unit name directly."
msgstr ""

#: ../../path-resolution.rst:164 b6c3d709f84d491ba83ddfc22faf17bc
msgid ""
":ref:`Relative imports <relative-imports>`, where you specify a path "
"starting with ``./`` or ``../`` to be combined with the source unit name "
"of the importing file."
msgstr ""

#: ../../path-resolution.rst:168 41fa53a6246d4423947589a3e9d16ab5
msgid "contracts/contract.sol"
msgstr ""

#: ../../path-resolution.rst:174 ba7c76b12c3b462580cd86168fb43adf
msgid ""
"In the above ``./math/math.sol`` and ``contracts/tokens/token.sol`` are "
"import paths while the source unit names they translate to are "
"``contracts/math/math.sol`` and ``contracts/tokens/token.sol`` "
"respectively."
msgstr ""

#: ../../path-resolution.rst:182 6f5252d89a4943d19dce8431353f080f
msgid "Direct Imports"
msgstr ""

#: ../../path-resolution.rst:184 fcec53b4b69a4e7f85ba599f09f32d4d
msgid "An import that does not start with ``./`` or ``../`` is a *direct import*."
msgstr ""

#: ../../path-resolution.rst:193 327972b2b4b24df89e32a72018faffdd
msgid ""
"After applying any :ref:`import remappings <import-remapping>` the import"
" path simply becomes the source unit name."
msgstr ""

#: ../../path-resolution.rst:198 9d2a829694ae4e88b63ef7567bb0f005
msgid ""
"A source unit name is just an identifier and even if its value happens to"
" look like a path, it is not subject to the normalization rules you would"
" typically expect in a shell. Any ``/./`` or ``/../`` seguments or "
"sequences of multiple slashes remain a part of it. When the source is "
"provided via Standard JSON interface it is entirely possible to associate"
" different content with source unit names that would refer to the same "
"file on disk."
msgstr ""

#: ../../path-resolution.rst:204 96cc73dc3eb04bba91455046c378eefd
msgid ""
"When the source is not available in the virtual filesystem, the compiler "
"passes the source unit name to the import callback. The Host Filesystem "
"Loader will attempt to use it as a path and look up the file on disk. At "
"this point the platform-specific normalization rules kick in and names "
"that were considered different in the VFS may actually result in the same"
" file being loaded. For example ``/project/lib/math.sol`` and "
"``/project/lib/../lib///math.sol`` are considered completely different in"
" the VFS even though they refer to the same file on disk."
msgstr ""

#: ../../path-resolution.rst:214 b620b7d1bd5b44a7bdb268183a2d441c
msgid ""
"Even if an import callback ends up loading source code for two different "
"source unit names from the same file on disk, the compiler will still see"
" them as separate source units. It is the source unit name that matters, "
"not the physical location of the code."
msgstr ""

#: ../../path-resolution.rst:222 a488041457b84ea5993746d7ecc468a9
msgid "Relative Imports"
msgstr ""

#: ../../path-resolution.rst:224 fcd1c62d0ab04ea983e0fbab42692f7a
msgid ""
"An import starting with ``./`` or ``../`` is a *relative import*. Such "
"imports specify a path relative to the source unit name of the importing "
"source unit:"
msgstr ""

#: ../../path-resolution.rst:227 adac06be81294660a7e1675a00ed064a
msgid "/project/lib/math.sol"
msgstr ""

#: ../../path-resolution.rst:233 caec1aff643f4156a9bdbb4c0ed7fa88
msgid "lib/math.sol"
msgstr ""

#: ../../path-resolution.rst:241 de2af14dec2d47229f590d2fef6c4922
msgid ""
"Relative imports **always** start with ``./`` or ``../`` so ``import "
"\"util.sol\"``, unlike ``import \"./util.sol\"``, is a direct import. "
"While both paths would be considered relative in the host filesystem, "
"``util.sol`` is actually absolute in the VFS."
msgstr ""

#: ../../path-resolution.rst:246 5ecdde537e41466db8ba947ef932bf5f
msgid ""
"Let us define a *path segment* as any non-empty part of the path that "
"does not contain a separator and is bounded by two path separators. A "
"separator is a forward slash or the beginning/end of the string. For "
"example in ``./abc/..//`` there are three path segments: ``.``, ``abc`` "
"and ``..``."
msgstr ""

#: ../../path-resolution.rst:251 0fbb38a3aec04944932e3fc41be9275d
msgid ""
"The compiler computes a source unit name from the import path in the "
"following way:"
msgstr ""

#: ../../path-resolution.rst:253 9ed470b3177a40b2b4c31c1d8c658155
msgid "First a prefix is computed"
msgstr ""

#: ../../path-resolution.rst:255 010f1e7f5c64440e8d6785352b44da9a
msgid ""
"Prefix is initialized with the source unit name of the importing source "
"unit."
msgstr ""

#: ../../path-resolution.rst:256 e563193b03e540039d9fdcf76c7ae8fb
msgid "The last path segment with preceding slashes is removed from the prefix."
msgstr ""

#: ../../path-resolution.rst:257 7b3447fe69644550a843b904aea26e33
msgid ""
"Then, the leading part of the normalized import path, consisting only of "
"``/`` and ``.`` characters is considered. For every ``..`` segment found "
"in this part the last path segment with preceding slashes is removed from"
" the prefix."
msgstr ""

#: ../../path-resolution.rst:262 5864b77de2a641d88538d01ec9bce2dd
msgid ""
"Then the prefix is prepended to the normalized import path. If the prefix"
" is non-empty, a single slash is inserted between it and the import path."
msgstr ""

#: ../../path-resolution.rst:265 efc17895d52348fc827d2a4bc81b5405
msgid ""
"The removal of the last path segment with preceding slashes is understood"
" to work as follows:"
msgstr ""

#: ../../path-resolution.rst:268 2289a0608dd249958cd807202e8834dd
msgid ""
"Everything past the last slash is removed (i.e. ``a/b//c.sol`` becomes "
"``a/b//``)."
msgstr ""

#: ../../path-resolution.rst:269 5fb7b08bb35a40e6b0721fa4462d20eb
msgid "All trailing slashes are removed (i.e. ``a/b//`` becomes ``a/b``)."
msgstr ""

#: ../../path-resolution.rst:271 d612e47d25e744b1a455c299371fb5b1
msgid "The normalization rules are the same as for UNIX paths, namely:"
msgstr ""

#: ../../path-resolution.rst:273 6795bc280db44149805d13d786326ff7
msgid "All the internal ``.`` segments are removed."
msgstr ""

#: ../../path-resolution.rst:274 24dd0083e6cc45b688535f93ec037ea5
msgid "Every internal ``..`` segment backtracks one level up in the hierarchy."
msgstr ""

#: ../../path-resolution.rst:275 1a93f3214fa94fc5aeda917a59100d21
msgid "Multiple slashes are squashed into a single one."
msgstr ""

#: ../../path-resolution.rst:277 c90dfb6a1869487e859c70ff021fcab2
msgid ""
"Note that normalization is performed only on the import path. The source "
"unit name of the importing module that is used for the prefix remains "
"unnormalized. This ensures that the ``protocol://`` part does not turn "
"into ``protocol:/`` if the importing file is identified with a URL."
msgstr ""

#: ../../path-resolution.rst:282 281c8c1d409a42a3b8e8f7be0df0aaed
msgid ""
"If your import paths are already normalized, you can expect the above "
"algorithm to produce very intuitive results. Here are some examples of "
"what you can expect if they are not:"
msgstr ""

#: ../../path-resolution.rst:286 93fa1ce2ef0d4314aca359576bd147f0
msgid "lib/src/../contract.sol"
msgstr ""

#: ../../path-resolution.rst:297 ad476e9bba09452d8bd689974c267e02
msgid ""
"The use of relative imports containing leading ``..`` segments is not "
"recommended. The same effect can be achieved in a more reliable way by "
"using direct imports with :ref:`base path and include paths <base-and-"
"include-paths>`."
msgstr ""

#: ../../path-resolution.rst:305 13ec560a6b0b454f9a1fc63bf99106fc
msgid "Base Path and Include Paths"
msgstr ""

#: ../../path-resolution.rst:307 3fb5667260f243c8afea0931b203d18f
msgid ""
"The base path and include paths represent directories that the Host "
"Filesystem Loader will load files from. When a source unit name is passed"
" to the loader, it prepends the base path to it and performs a filesystem"
" lookup. If the lookup does not succeed, the same is done with all "
"directories on the include path list."
msgstr ""

#: ../../path-resolution.rst:312 5db2e2bc60d54803beea982f00c63740
msgid ""
"It is recommended to set the base path to the root directory of your "
"project and use include paths to specify additional locations that may "
"contain libraries your project depends on. This lets you import from "
"these libraries in a uniform way, no matter where they are located in the"
" filesystem relative to your project. For example, if you use npm to "
"install packages and your contract imports "
"``@openzeppelin/contracts/utils/Strings.sol``, you can use these options "
"to tell the compiler that the library can be found in one of the npm "
"package directories:"
msgstr ""

#: ../../path-resolution.rst:327 a771d137f8784c9495f5bef1a284c640
msgid ""
"Your contract will compile (with the same exact metadata) no matter "
"whether you install the library in the local or global package directory "
"or even directly under your project root."
msgstr ""

#: ../../path-resolution.rst:330 f6295401a6354e0e9c970a7e19c8bf5d
msgid ""
"By default the base path is empty, which leaves the source unit name "
"unchanged. When the source unit name is a relative path, this results in "
"the file being looked up in the directory the compiler has been invoked "
"from. It is also the only value that results in absolute paths in source "
"unit names being actually interpreted as absolute paths on disk. If the "
"base path itself is relative, it is interpreted as relative to the "
"current working directory of the compiler."
msgstr ""

#: ../../path-resolution.rst:340 9f4a59d7240d46c5b864e47b4b9545c9
msgid ""
"Include paths cannot have empty values and must be used together with a "
"non-empty base path."
msgstr ""

#: ../../path-resolution.rst:344 4cd7cf8112da423293632b3101b5fbbb
msgid ""
"Include paths and base path can overlap as long as it does not make "
"import resolution ambiguous. For example, you can specify a directory "
"inside base path as an include directory or have an include directory "
"that is a subdirectory of another include directory. The compiler will "
"only issue an error if the source unit name passed to the Host Filesystem"
" Loader represents an existing path when combined with multiple include "
"paths or an include path and base path."
msgstr ""

#: ../../path-resolution.rst:354 a50ed5e5acce452b9a699a5b9d6fcda6
msgid "CLI Path Normalization and Stripping"
msgstr ""

#: ../../path-resolution.rst:356 71813b0e5d9e4a4d82f406b18e46a363
msgid ""
"On the command line the compiler behaves just as you would expect from "
"any other program: it accepts paths in a format native to the platform "
"and relative paths are relative to the current working directory. The "
"source unit names assigned to files whose paths are specified on the "
"command line, however, should not change just because the project is "
"being compiled on a different platform or because the compiler happens to"
" have been invoked from a different directory. To achieve this, paths to "
"source files coming from the command line must be converted to a "
"canonical form, and, if possible, made relative to the base path or one "
"of the include paths."
msgstr ""

#: ../../path-resolution.rst:365 bf942067e4bf4259a33596473e24255e
msgid "The normalization rules are as follows:"
msgstr ""

#: ../../path-resolution.rst:367 2f087612bb224da98fac1325001f42ea
msgid ""
"If a path is relative, it is made absolute by prepending the current "
"working directory to it."
msgstr ""

#: ../../path-resolution.rst:368 3a59449dc6fc4b48a4cc57323e4a0f0d
msgid "Internal ``.`` and ``..`` segments are collapsed."
msgstr ""

#: ../../path-resolution.rst:369 a44478425f894312a10efc5d5b392ed1
msgid "Platform-specific path separators are replaced with forward slashes."
msgstr ""

#: ../../path-resolution.rst:370 301c0f2ce20c498b846aa27549b3511f
msgid ""
"Sequences of multiple consecutive path separators are squashed into a "
"single separator (unless they are the leading slashes of an `UNC path "
"<https://en.wikipedia.org/wiki/Path_(computing)#UNC>`_)."
msgstr ""

#: ../../path-resolution.rst:372 c6b30a4d01094d8da52f05bae90ef587
msgid ""
"If the path includes a root name (e.g. a drive letter on Windows) and the"
" root is the same as the root of the current working directory, the root "
"is replaced with ``/``."
msgstr ""

#: ../../path-resolution.rst:374 08944f477e2746e9aaf050eae225c433
msgid "Symbolic links in the path are **not** resolved."
msgstr ""

#: ../../path-resolution.rst:376 7a13e2aa5cf64b2585ccb55467d9430e
msgid ""
"The only exception is the path to the current working directory prepended"
" to relative paths in the process of making them absolute. On some "
"platforms the working directory is reported always with symbolic links "
"resolved so for consistency the compiler resolves them everywhere."
msgstr ""

#: ../../path-resolution.rst:381 cd7fe2132b164915925caf7aa0c42dc9
msgid ""
"The original case of the path is preserved even if the filesystem is "
"case-insensitive but `case-preserving "
"<https://en.wikipedia.org/wiki/Case_preservation>`_ and the actual case "
"on disk is different."
msgstr ""

#: ../../path-resolution.rst:387 06c41363605d4db1937e53fa4b6707df
msgid ""
"There are situations where paths cannot be made platform-independent. For"
" example on Windows the compiler can avoid using drive letters by "
"referring to the root directory of the current drive as ``/`` but drive "
"letters are still necessary for paths leading to other drives. You can "
"avoid such situations by ensuring that all the files are available within"
" a single directory tree on the same drive."
msgstr ""

#: ../../path-resolution.rst:394 3d4383382f5845d3a8b6311c2a123c86
msgid ""
"After normalization the compiler attempts to make the source file path "
"relative. It tries the base path first and then the include paths in the "
"order they were given. If the base path is empty or not specified, it is "
"treated as if it was equal to the path to the current working directory "
"(with all symbolic links resolved). The result is accepted only if the "
"normalized directory path is the exact prefix of the normalized file "
"path. Otherwise the file path remains absolute. This makes the conversion"
" unambiguous and ensures that the relative path does not start with "
"``../``. The resulting file path becomes the source unit name."
msgstr ""

#: ../../path-resolution.rst:406 52f6ea008b8b4903acdc0ceb5bfd31a7
msgid ""
"The relative path produced by stripping must remain unique within the "
"base path and include paths. For example the compiler will issue an error"
" for the following command if both ``/project/contract.sol`` and "
"``/lib/contract.sol`` exist:"
msgstr ""

#: ../../path-resolution.rst:416 483819a12a4f4a6f9076fae54d8b0178
msgid ""
"Prior to version 0.8.8, CLI path stripping was not performed and the only"
" normalization applied was the conversion of path separators. When "
"working with older versions of the compiler it is recommended to invoke "
"the compiler from the base path and to only use relative paths on the "
"command line."
msgstr ""

#: ../../path-resolution.rst:425 8bf846bdd9804af28973591ad81cf623
msgid "Allowed Paths"
msgstr ""

#: ../../path-resolution.rst:427 0abc428db25d40b58258486ec5c1aa75
msgid ""
"As a security measure, the Host Filesystem Loader will refuse to load "
"files from outside of a few locations that are considered safe by "
"default:"
msgstr ""

#: ../../path-resolution.rst:430 3ead320f107c42048558f2f4286f523b
msgid "Outside of Standard JSON mode:"
msgstr ""

#: ../../path-resolution.rst:432 165950db0c214bdca8842deecbce474a
msgid "The directories containing input files listed on the command line."
msgstr ""

#: ../../path-resolution.rst:433 7fc552ebc1284deb9d228e9fe44f7eb1
msgid ""
"The directories used as :ref:`remapping <import-remapping>` targets. If "
"the target is not a directory (i.e does not end with ``/``, ``/.`` or "
"``/..``) the directory containing the target is used instead."
msgstr ""

#: ../../path-resolution.rst:436 ../../path-resolution.rst:440
#: 06df89585f56447a82a7d31b34eb47a1 4a6357a9ce3f4fb38685617f0bcf7879
msgid "Base path and include paths."
msgstr ""

#: ../../path-resolution.rst:438 99d72d71f4644007a491f0120d6240df
msgid "In Standard JSON mode:"
msgstr ""

#: ../../path-resolution.rst:442 551af11fbd3c42ecbdde2cb4194ca045
msgid ""
"Additional directories can be whitelisted using the ``--allow-paths`` "
"option. The option accepts a comma-separated list of paths:"
msgstr ""

#: ../../path-resolution.rst:454 b454c1de0d6844d0a6c1e1675bf274cf
msgid ""
"When the compiler is invoked with the command shown above, the Host "
"Filesystem Loader will allow importing files from the following "
"directories:"
msgstr ""

#: ../../path-resolution.rst:457 300defb5ab904239beea58741593ac1d
msgid ""
"``/home/user/project/token/`` (because ``token/`` contains the input file"
" and also because it is the base path),"
msgstr ""

#: ../../path-resolution.rst:459 5a1accc1bc1b4e469f3e0b3ae51d2e91
msgid "``/lib/`` (because ``/lib/`` is one of the include paths),"
msgstr ""

#: ../../path-resolution.rst:460 2b7d750948cf46f98defcaa2fb0f22db
msgid ""
"``/home/user/project/libs/`` (because ``libs/`` is a directory containing"
" a remapping target),"
msgstr ""

#: ../../path-resolution.rst:461 fcec9e3062074d4f84776b97ba1a48ed
msgid ""
"``/home/user/utils/`` (because of ``../utils/`` passed to ``--allow-"
"paths``),"
msgstr ""

#: ../../path-resolution.rst:462 3fdb9917807248349b4b3d06279e9cee
msgid ""
"``/tmp/libraries/`` (because of ``/tmp/libraries`` passed to ``--allow-"
"paths``),"
msgstr ""

#: ../../path-resolution.rst:466 4f77985e4589486a8150cc494e6f9d27
msgid ""
"The working directory of the compiler is one of the paths allowed by "
"default only if it happens to be the base path (or the base path is not "
"specified or has an empty value)."
msgstr ""

#: ../../path-resolution.rst:471 949c3d2455ac4fcdbbfbe952d76203ce
msgid ""
"The compiler does not check if allowed paths actually exist and whether "
"they are directories. Non-existent or empty paths are simply ignored. If "
"an allowed path matches a file rather than a directory, the file is "
"considered whitelisted, too."
msgstr ""

#: ../../path-resolution.rst:477 7cd436eddba345d8a4331840adae3303
msgid ""
"Allowed paths are case-sensitive even if the filesystem is not. The case "
"must exactly match the one used in your imports. For example ``--allow-"
"paths tokens`` will not match ``import \"Tokens/IERC20.sol\"``."
msgstr ""

#: ../../path-resolution.rst:483 c9e7cd2c222e48f2bfdef2e87f8c4135
msgid ""
"Files and directories only reachable through symbolic links from allowed "
"directories are not automatically whitelisted. For example if "
"``token/contract.sol`` in the example above was actually a symlink "
"pointing at ``/etc/passwd`` the compiler would refuse to load it unless "
"``/etc/`` was one of the allowed paths too."
msgstr ""

#: ../../path-resolution.rst:493 d19a54f1a9eb407d8de2dbd6de56ea5e
msgid "Import Remapping"
msgstr ""

#: ../../path-resolution.rst:495 aef156880bd34ab4b3456c56704f70a2
msgid ""
"Import remapping allows you to redirect imports to a different location "
"in the virtual filesystem. The mechanism works by changing the "
"translation between import paths and source unit names. For example you "
"can set up a remapping so that any import from the virtual directory "
"``github.com/ethereum/dapp-bin/library/`` would be seen as an import from"
" ``dapp-bin/library/`` instead."
msgstr ""

#: ../../path-resolution.rst:500 6f2c4d6a3e534aa8835a58aca4c72b9d
msgid ""
"You can limit the scope of a remapping by specifying a *context*. This "
"allows creating remappings that apply only to imports located in a "
"specific library or a specific file. Without a context a remapping is "
"applied to every matching import in all the files in the virtual "
"filesystem."
msgstr ""

#: ../../path-resolution.rst:505 8ab05d12f67749bc88092e10554e5071
msgid "Import remappings have the form of ``context:prefix=target``:"
msgstr ""

#: ../../path-resolution.rst:507 68bc4b2809b74d5c8c1610e4d75cc92d
msgid ""
"``context`` must match the beginning of the source unit name of the file "
"containing the import."
msgstr ""

#: ../../path-resolution.rst:508 e26b1dbd8507445bb989df73ff243407
msgid ""
"``prefix`` must match the beginning of the source unit name resulting "
"from the import."
msgstr ""

#: ../../path-resolution.rst:509 006ed91b95a04a238a14a4e5316180c4
msgid "``target`` is the value the prefix is replaced with."
msgstr ""

#: ../../path-resolution.rst:511 af8dbdbeffc14735be96c0c480315514
msgid ""
"For example, if you clone https://github.com/ethereum/dapp-bin/ locally "
"to ``/project/dapp-bin`` and run the compiler with:"
msgstr ""

#: ../../path-resolution.rst:518 ccf58ed443664dadbc68ee89b35bbf60
msgid "you can use the following in your source file:"
msgstr ""

#: ../../path-resolution.rst:524 b957d5c85ef54495ba01ef4291c96175
msgid ""
"The compiler will look for the file in the VFS under ``dapp-"
"bin/library/math.sol``. If the file is not available there, the source "
"unit name will be passed to the Host Filesystem Loader, which will then "
"look in ``/project/dapp-bin/library/iterable_mapping.sol``."
msgstr ""

#: ../../path-resolution.rst:530 e976569f1b9441a1831b4bbdc7fdde91
msgid ""
"Information about remappings is stored in contract metadata. Since the "
"binary produced by the compiler has a hash of the metadata embedded in "
"it, any modification to the remappings will result in different bytecode."
msgstr ""

#: ../../path-resolution.rst:534 5c4d4ab6d2d744ad9b10be56f2a887b2
msgid ""
"For this reason you should be careful not to include any local "
"information in remapping targets. For example if your library is located "
"in ``/home/user/packages/mymath/math.sol``, a remapping like "
"``@math/=/home/user/packages/mymath/`` would result in your home "
"directory being included in the metadata. To be able to reproduce the "
"same bytecode with such a remapping on a different machine, you would "
"need to recreate parts of your local directory structure in the VFS and "
"(if you rely on Host Filesystem Loader) also in the host filesystem."
msgstr ""

#: ../../path-resolution.rst:542 71d1564c4ccb49b9bafffcb7a8f787fa
msgid ""
"To avoid having your local directory structure embedded in the metadata, "
"it is recommended to designate the directories containing libraries as "
"*include paths* instead. For example, in the example above ``--include-"
"path /home/user/packages/`` would let you use imports starting with "
"``mymath/``. Unlike remapping, the option on its own will not make "
"``mymath`` appear as ``@math`` but this can be achieved by creating a "
"symbolic link or renaming the package subdirectory."
msgstr ""

#: ../../path-resolution.rst:549 42ff9fac49cb45c78c7eb41b5af731d2
msgid ""
"As a more complex example, suppose you rely on a module that uses an old "
"version of dapp-bin that you checked out to ``/project/dapp-bin_old``, "
"then you can run:"
msgstr ""

#: ../../path-resolution.rst:559 fa6219acba744c3a9d66e604483da60e
msgid ""
"This means that all imports in ``module2`` point to the old version but "
"imports in ``module1`` point to the new version."
msgstr ""

#: ../../path-resolution.rst:562 dc225470105f43619ba7522d483a1f2e
msgid "Here are the detailed rules governing the behaviour of remappings:"
msgstr ""

#: ../../path-resolution.rst:564 b0a8a5d7e8464704afb7262048a4f6c2
msgid ""
"**Remappings only affect the translation between import paths and source "
"unit names.**"
msgstr ""

#: ../../path-resolution.rst:566 6777d49b29f04be0ae18f96a40d635e1
msgid ""
"Source unit names added to the VFS in any other way cannot be remapped. "
"For example the paths you specify on the command-line and the ones in "
"``sources.urls`` in Standard JSON are not affected."
msgstr ""

#: ../../path-resolution.rst:574 1344cab749884af9b9d965fa14f604c6
msgid ""
"In the example above the compiler will load the source code from "
"``/project/contract.sol`` and place it under that exact source unit name "
"in the VFS, not under ``/contract/contract.sol``."
msgstr ""

#: ../../path-resolution.rst:577 18d5f16fa9b54dd7844e80bbbc17fbc6
msgid "**Context and prefix must match source unit names, not import paths.**"
msgstr ""

#: ../../path-resolution.rst:579 2650a34467e24baa8e76cfb848731e72
msgid ""
"This means that you cannot remap ``./`` or ``../`` directly since they "
"are replaced during the translation to source unit name but you can remap"
" the part of the name they are replaced with:"
msgstr ""

#: ../../path-resolution.rst:587 ../../path-resolution.rst:599
#: ../../path-resolution.rst:624 3625728b33e44a54aab499e3c5435871
#: 84af07c0c0f04524be224a24d15179dc f93a4959333d4e7e8acdd9c847d5c176
msgid "/project/contract.sol"
msgstr ""

#: ../../path-resolution.rst:592 c4d971bd813b4eccb8e5c7156404c968
msgid ""
"You cannot remap base path or any other part of the path that is only "
"added internally by an import callback:"
msgstr ""

#: ../../path-resolution.rst:604 ce9b38dcd2564f8aae001158d8646e53
msgid ""
"**Target is inserted directly into the source unit name and does not "
"necessarily have to be a valid path.**"
msgstr ""

#: ../../path-resolution.rst:606 1d07d4da68ff4bdfa66d9fd07ccef683
msgid ""
"It can be anything as long as the import callback can handle it. In case "
"of the Host Filesystem Loader this includes also relative paths. When "
"using the JavaScript interface you can even use URLs and abstract "
"identifiers if your callback can handle them."
msgstr ""

#: ../../path-resolution.rst:611 8bc288085e664f1191f35fb20f3d03eb
msgid ""
"Remapping happens after relative imports have already been resolved into "
"source unit names. This means that targets starting with ``./`` and "
"``../`` have no special meaning and are relative to the base path rather "
"than to the location of the source file."
msgstr ""

#: ../../path-resolution.rst:615 6f4c6fa26c80467897262a1126c8d2ea
msgid ""
"Remapping targets are not normalized so ``@root/=./a/b//`` will remap "
"``@root/contract.sol`` to ``./a/b//contract.sol`` and not "
"``a/b/contract.sol``."
msgstr ""

#: ../../path-resolution.rst:618 ecf07dc753454947b45c665114f85a90
msgid ""
"If the target does not end with a slash, the compiler will not add one "
"automatically:"
msgstr ""

#: ../../path-resolution.rst:629 dd8b35e5b3f24e0db087aa184cdd5e23
msgid "**Context and prefix are patterns and matches must be exact.**"
msgstr ""

#: ../../path-resolution.rst:631 1d4e982940514f72b3152e496e806a75
msgid "``a//b=c`` will not match ``a/b``."
msgstr ""

#: ../../path-resolution.rst:632 6b1cfc89dae4418b97a8683db5b62041
msgid ""
"source unit names are not normalized so ``a/b=c`` will not match ``a//b``"
" either."
msgstr ""

#: ../../path-resolution.rst:633 ffbd554ab8f545bf98de8ad27ba66bb3
msgid ""
"Parts of file and directory names can match as well. "
"``/newProject/con:/new=old`` will match ``/newProject/contract.sol`` and "
"remap it to ``oldProject/contract.sol``."
msgstr ""

#: ../../path-resolution.rst:637 f10388a471464da5ae3f0fbfa1fbfb1d
msgid "**At most one remapping is applied to a single import.**"
msgstr ""

#: ../../path-resolution.rst:639 58c188c96ff648ef9dbfc0f7a30bf3e1
msgid ""
"If multiple remappings match the same source unit name, the one with the "
"longest matching prefix is chosen."
msgstr ""

#: ../../path-resolution.rst:641 e78664d02b6e411dacc8e7353c3bb68b
msgid "If prefixes are identical, the one specified last wins."
msgstr ""

#: ../../path-resolution.rst:642 f3a3c70d0edf4214a2ce6bd6460577db
msgid ""
"Remappings do not work on other remappings. For example ``a=b b=c c=d`` "
"will not result in ``a`` being remapped to ``d``."
msgstr ""

#: ../../path-resolution.rst:645 8c25a9194f1b42279b8ee6ebba55e0be
msgid "**Prefix cannot be empty but context and target are optional.**"
msgstr ""

#: ../../path-resolution.rst:647 87b11a5597584bf3afe02abf9840d80a
msgid ""
"If ``target`` is the empty string, ``prefix`` is simply removed from "
"import paths."
msgstr ""

#: ../../path-resolution.rst:648 32a2af2684b842e1911f7488183fc5df
msgid ""
"Empty ``context`` means that the remapping applies to all imports in all "
"source units."
msgstr ""

#: ../../path-resolution.rst:653 3405bce55e76435fa977e2fcd0a3ac76
msgid "Using URLs in imports"
msgstr ""

#: ../../path-resolution.rst:655 19fc0c8562524d9abecbf109e25b2940
msgid ""
"Most URL prefixes such as ``https://`` or ``data://`` have no special "
"meaning in import paths. The only exception is ``file://`` which is "
"stripped from source unit names by the Host Filesystem Loader."
msgstr ""

#: ../../path-resolution.rst:659 662db3fd08604f08837dea934aafae3e
msgid ""
"When compiling locally you can use import remapping to replace the "
"protocol and domain part with a local path:"
msgstr ""

#: ../../path-resolution.rst:666 99caad16934d4d27b7fa3e9156b0bc89
msgid ""
"Note the leading ``:``, which is necessary when the remapping context is "
"empty. Otherwise the ``https:`` part would be interpreted by the compiler"
" as the context."
msgstr ""

