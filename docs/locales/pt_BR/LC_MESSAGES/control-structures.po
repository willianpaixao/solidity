msgid ""
msgstr ""
"Project-Id-Version: solidity-test\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-01-13 16:47+0100\n"
"PO-Revision-Date: 2022-01-13 16:14\n"
"Last-Translator: \n"
"Language-Team: Portuguese, Brazilian\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Crowdin-Project: solidity-test\n"
"X-Crowdin-Project-ID: 494285\n"
"X-Crowdin-Language: pt-BR\n"
"X-Crowdin-File: control-structures.po\n"
"X-Crowdin-File-ID: 3\n"
"Language: pt_BR\n"

#: ../../control-structures.rst:3 011bdbcdd9e74544a787aa94cf10c5f0
msgid "Expressions and Control Structures"
msgstr ""

#: ../../control-structures.rst:11 205850b708ed406a8194cd1b42f4d97e
msgid "Control Structures"
msgstr ""

#: ../../control-structures.rst:13 17afe460dd3c4cf0aa19a74c1e6af4f5
msgid "Most of the control structures known from curly-braces languages are available in Solidity:"
msgstr ""

#: ../../control-structures.rst:15 8d73eeea487b4009b33a460023ace43a
msgid "There is: ``if``, ``else``, ``while``, ``do``, ``for``, ``break``, ``continue``, ``return``, with the usual semantics known from C or JavaScript."
msgstr ""

#: ../../control-structures.rst:18 572bffba272e461e99f95673b98e4dcb
msgid "Solidity also supports exception handling in the form of ``try``/``catch``-statements, but only for :ref:`external function calls <external-function-calls>` and contract creation calls. Errors can be created using the :ref:`revert statement <revert-statement>`."
msgstr ""

#: ../../control-structures.rst:22 3f0b80df83444010b585b47fdcb17857
msgid "Parentheses can *not* be omitted for conditionals, but curly braces can be omitted around single-statement bodies."
msgstr ""

#: ../../control-structures.rst:25 ea0e034e065a4226ad7157e366f4c435
msgid "Note that there is no type conversion from non-boolean to boolean types as there is in C and JavaScript, so ``if (1) { ... }`` is *not* valid Solidity."
msgstr ""

#: ../../control-structures.rst:34 0a33dd1b6b10499ea9ada350e7b50737
msgid "Function Calls"
msgstr ""

#: ../../control-structures.rst:39 7a4e476d3fb94eb1a7fb5a0af884f19b
msgid "Internal Function Calls"
msgstr ""

#: ../../control-structures.rst:41 6132769d0a044f74bd6b4b85bafb2680
msgid "Functions of the current contract can be called directly (\"internally\"), also recursively, as seen in this nonsensical example:"
msgstr ""

#: ../../control-structures.rst:55 41bc0907e4054efeab1abd2d8bdbe16c
msgid "These function calls are translated into simple jumps inside the EVM. This has the effect that the current memory is not cleared, i.e. passing memory references to internally-called functions is very efficient. Only functions of the same contract instance can be called internally."
msgstr ""

#: ../../control-structures.rst:60 f54c11481b4e41ecaef9bae2e4801a34
msgid "You should still avoid excessive recursion, as every internal function call uses up at least one stack slot and there are only 1024 slots available."
msgstr ""

#: ../../control-structures.rst:66 682548aeb2d14e18af9a610eeeb91e9b
msgid "External Function Calls"
msgstr ""

#: ../../control-structures.rst:68 f8c808171a1b459ca67c8c72aeecb0af
msgid "Functions can also be called using the ``this.g(8);`` and ``c.g(2);`` notation, where ``c`` is a contract instance and ``g`` is a function belonging to ``c``. Calling the function ``g`` via either way results in it being called \"externally\", using a message call and not directly via jumps. Please note that function calls on ``this`` cannot be used in the constructor, as the actual contract has not been created yet."
msgstr ""

#: ../../control-structures.rst:75 c69b0178286b4da7b2ffedb08f0cfc77
msgid "Functions of other contracts have to be called externally. For an external call, all function arguments have to be copied to memory."
msgstr ""

#: ../../control-structures.rst:79 3246dbdfb8c24e71ae787cd9e520c9f8
msgid "A function call from one contract to another does not create its own transaction, it is a message call as part of the overall transaction."
msgstr ""

#: ../../control-structures.rst:82 005684fa34134ec9ab32ae4860681c5b
msgid "When calling functions of other contracts, you can specify the amount of Wei or gas sent with the call with the special options ``{value: 10, gas: 10000}``. Note that it is discouraged to specify gas values explicitly, since the gas costs of opcodes can change in the future. Any Wei you send to the contract is added to the total balance of that contract:"
msgstr ""

#: ../../control-structures.rst:103 b96c98e296624dcabf58112593f26ab1
msgid "You need to use the modifier ``payable`` with the ``info`` function because otherwise, the ``value`` option would not be available."
msgstr ""

#: ../../control-structures.rst:107 fe2055eb9b7946e79a0fa31cb1dbf033
msgid "Be careful that ``feed.info{value: 10, gas: 800}`` only locally sets the ``value`` and amount of ``gas`` sent with the function call, and the parentheses at the end perform the actual call. So ``feed.info{value: 10, gas: 800}`` does not call the function and the ``value`` and ``gas`` settings are lost, only ``feed.info{value: 10, gas: 800}()`` performs the function call."
msgstr ""

#: ../../control-structures.rst:114 dfa6119f623949608b8f0d16b358c003
msgid "Due to the fact that the EVM considers a call to a non-existing contract to always succeed, Solidity uses the ``extcodesize`` opcode to check that the contract that is about to be called actually exists (it contains code) and causes an exception if it does not. This check is skipped if the return data will be decoded after the call and thus the ABI decoder will catch the case of a non-existing contract."
msgstr ""

#: ../../control-structures.rst:121 b6d604e9a9a346c9835a329f71722e38
msgid "Note that this check is not performed in case of :ref:`low-level calls <address_related>` which operate on addresses rather than contract instances."
msgstr ""

#: ../../control-structures.rst:125 ef070c7baa77475dbf24456b741275e2
msgid "Be careful when using high-level calls to :ref:`precompiled contracts <precompiledContracts>`, since the compiler considers them non-existing according to the above logic even though they execute code and can return data."
msgstr ""

#: ../../control-structures.rst:130 f000b503a22f48178ef3855ad3bbd8cf
msgid "Function calls also cause exceptions if the called contract itself throws an exception or goes out of gas."
msgstr ""

#: ../../control-structures.rst:134 beffc5f3e8564163b5daad485131a782
msgid "Any interaction with another contract imposes a potential danger, especially if the source code of the contract is not known in advance. The current contract hands over control to the called contract and that may potentially do just about anything. Even if the called contract inherits from a known parent contract, the inheriting contract is only required to have a correct interface. The implementation of the contract, however, can be completely arbitrary and thus, pose a danger. In addition, be prepared in case it calls into other contracts of your system or even back into the calling contract before the first call returns. This means that the called contract can change state variables of the calling contract via its functions. Write your functions in a way that, for example, calls to external functions happen after any changes to state variables in your contract so your contract is not vulnerable to a reentrancy exploit."
msgstr ""

#: ../../control-structures.rst:149 8082fdb943a24f338bbdeff0d4f5311e
msgid "Before Solidity 0.6.2, the recommended way to specify the value and gas was to use ``f.value(x).gas(g)()``. This was deprecated in Solidity 0.6.2 and is no longer possible since Solidity 0.7.0."
msgstr ""

#: ../../control-structures.rst:154 90fd9dabf36249d488e8df0fed9877a4
msgid "Named Calls and Anonymous Function Parameters"
msgstr ""

#: ../../control-structures.rst:156 efc59033e02b49e4b1c1ff16e461b49a
msgid "Function call arguments can be given by name, in any order, if they are enclosed in ``{ }`` as can be seen in the following example. The argument list has to coincide by name with the list of parameters from the function declaration, but can be in arbitrary order."
msgstr ""

#: ../../control-structures.rst:180 52720155b0a64a6187ce63083d1fd61b
msgid "Omitted Function Parameter Names"
msgstr ""

#: ../../control-structures.rst:182 91c6cd4b4d4f4f8f9a02c8179f7c0006
msgid "The names of unused parameters (especially return parameters) can be omitted. Those parameters will still be present on the stack, but they are inaccessible."
msgstr ""

#: ../../control-structures.rst:203 828ab7a10174467f842ba07b3765966a
msgid "Creating Contracts via ``new``"
msgstr ""

#: ../../control-structures.rst:205 d0d300592bef436fa31e7416744e0b65
msgid "A contract can create other contracts using the ``new`` keyword. The full code of the contract being created has to be known when the creating contract is compiled so recursive creation-dependencies are not possible."
msgstr ""

#: ../../control-structures.rst:235 cc39f3332e08430f89bf8171c3b92f64
msgid "As seen in the example, it is possible to send Ether while creating an instance of ``D`` using the ``value`` option, but it is not possible to limit the amount of gas. If the creation fails (due to out-of-stack, not enough balance or other problems), an exception is thrown."
msgstr ""

#: ../../control-structures.rst:242 4405169203324b3e854c18df7d511bfd
msgid "Salted contract creations / create2"
msgstr ""

#: ../../control-structures.rst:244 a5e7bc05ea7b483eb2f92e740ed1a95c
msgid "When creating a contract, the address of the contract is computed from the address of the creating contract and a counter that is increased with each contract creation."
msgstr ""

#: ../../control-structures.rst:248 8935cc17d6834ee28ae85ffed78dd5e5
msgid "If you specify the option ``salt`` (a bytes32 value), then contract creation will use a different mechanism to come up with the address of the new contract:"
msgstr ""

#: ../../control-structures.rst:251 bc73ca0ea39e489f963a5c5e6f8d2849
msgid "It will compute the address from the address of the creating contract, the given salt value, the (creation) bytecode of the created contract and the constructor arguments."
msgstr ""

#: ../../control-structures.rst:255 e9eff1976da2480c8bb445df0f926348
msgid "In particular, the counter (\"nonce\") is not used. This allows for more flexibility in creating contracts: You are able to derive the address of the new contract before it is created. Furthermore, you can rely on this address also in case the creating contracts creates other contracts in the meantime."
msgstr ""

#: ../../control-structures.rst:261 d62b718548114651ae90a11eeec9c87a
msgid "The main use-case here is contracts that act as judges for off-chain interactions, which only need to be created if there is a dispute."
msgstr ""

#: ../../control-structures.rst:296 05bef53b39984aa297fe2bfdf7b3fced
msgid "There are some peculiarities in relation to salted creation. A contract can be re-created at the same address after having been destroyed. Yet, it is possible for that newly created contract to have a different deployed bytecode even though the creation bytecode has been the same (which is a requirement because otherwise the address would change). This is due to the fact that the constructor can query external state that might have changed between the two creations and incorporate that into the deployed bytecode before it is stored."
msgstr ""

#: ../../control-structures.rst:306 347345f1e1c64a548fabda8d2c93ba31
msgid "Order of Evaluation of Expressions"
msgstr ""

#: ../../control-structures.rst:308 0658c3ea96a145c0b7865f176d937272
msgid "The evaluation order of expressions is not specified (more formally, the order in which the children of one node in the expression tree are evaluated is not specified, but they are of course evaluated before the node itself). It is only guaranteed that statements are executed in order and short-circuiting for boolean expressions is done."
msgstr ""

#: ../../control-structures.rst:317 e94478ce45a140f99d8f1a80d0e69e2a
msgid "Assignment"
msgstr ""

#: ../../control-structures.rst:322 9bbe43b3fc2a4d9f9f4ca6084ba45a65
msgid "Destructuring Assignments and Returning Multiple Values"
msgstr ""

#: ../../control-structures.rst:324 99c5ffa22f3a44a099f5457c71b12060
msgid "Solidity internally allows tuple types, i.e. a list of objects of potentially different types whose number is a constant at compile-time. Those tuples can be used to return multiple values at the same time. These can then either be assigned to newly declared variables or to pre-existing variables (or LValues in general)."
msgstr ""

#: ../../control-structures.rst:330 f3b4cb18e3d8443bba0cec4a0b7dd19c
msgid "Tuples are not proper types in Solidity, they can only be used to form syntactic groupings of expressions."
msgstr ""

#: ../../control-structures.rst:356 abb33820aeab48c5a8a8fa02c9056908
msgid "It is not possible to mix variable declarations and non-declaration assignments, i.e. the following is not valid: ``(x, uint y) = (1, 2);``"
msgstr ""

#: ../../control-structures.rst:360 c21b15f610dc424cb543075cdaa803d6
msgid "Prior to version 0.5.0 it was possible to assign to tuples of smaller size, either filling up on the left or on the right side (which ever was empty). This is now disallowed, so both sides have to have the same number of components."
msgstr ""

#: ../../control-structures.rst:365 a6e3614a505f4b279d1b1f3f295ec7dd
msgid "Be careful when assigning to multiple variables at the same time when reference types are involved, because it could lead to unexpected copying behaviour."
msgstr ""

#: ../../control-structures.rst:370 ea166faafac94966afc29aba68915106
msgid "Complications for Arrays and Structs"
msgstr ""

#: ../../control-structures.rst:372 3fb526c25d064c0991d7ec3a0f817512
msgid "The semantics of assignments are more complicated for non-value types like arrays and structs, including ``bytes`` and ``string``, see :ref:`Data location and assignment behaviour <data-location-assignment>` for details."
msgstr ""

#: ../../control-structures.rst:375 8e872e16d97d41158ef9374409a2a299
msgid "In the example below the call to ``g(x)`` has no effect on ``x`` because it creates an independent copy of the storage value in memory. However, ``h(x)`` successfully modifies ``x`` because only a reference and not a copy is passed."
msgstr ""

#: ../../control-structures.rst:406 5bd8b8c9dba44832af87993344b1b496
msgid "Scoping and Declarations"
msgstr ""

#: ../../control-structures.rst:408 f69e4ff3f5df45939547d1da68987475
msgid "A variable which is declared will have an initial default value whose byte-representation is all zeros. The \"default values\" of variables are the typical \"zero-state\" of whatever the type is. For example, the default value for a ``bool`` is ``false``. The default value for the ``uint`` or ``int`` types is ``0``. For statically-sized arrays and ``bytes1`` to ``bytes32``, each individual element will be initialized to the default value corresponding to its type. For dynamically-sized arrays, ``bytes`` and ``string``, the default value is an empty array or string. For the ``enum`` type, the default value is its first member."
msgstr ""

#: ../../control-structures.rst:420 ca87a344fd6e44c8a2840105ee14af67
msgid "Scoping in Solidity follows the widespread scoping rules of C99 (and many other languages): Variables are visible from the point right after their declaration until the end of the smallest ``{ }``-block that contains the declaration. As an exception to this rule, variables declared in the initialization part of a for-loop are only visible until the end of the for-loop."
msgstr ""

#: ../../control-structures.rst:426 c595ae419ab54b2b83b7cb895f0ab710
msgid "Variables that are parameter-like (function parameters, modifier parameters, catch parameters, ...) are visible inside the code block that follows - the body of the function/modifier for a function and modifier parameter and the catch block for a catch parameter."
msgstr ""

#: ../../control-structures.rst:431 6bef7713a4d74f7688d269d00376fb89
msgid "Variables and other items declared outside of a code block, for example functions, contracts, user-defined types, etc., are visible even before they were declared. This means you can use state variables before they are declared and call functions recursively."
msgstr ""

#: ../../control-structures.rst:435 9f1d212a93b8425d86fb711a69284c2c
msgid "As a consequence, the following examples will compile without warnings, since the two variables have the same name but disjoint scopes."
msgstr ""

#: ../../control-structures.rst:456 ae6a4447ecd04d8e8ba20629dcb15212
msgid "As a special example of the C99 scoping rules, note that in the following, the first assignment to ``x`` will actually assign the outer and not the inner variable. In any case, you will get a warning about the outer variable being shadowed."
msgstr ""

#: ../../control-structures.rst:477 9fd0450c389043c78b1eed96e90c93ff
msgid "Before version 0.5.0 Solidity followed the same scoping rules as JavaScript, that is, a variable declared anywhere within a function would be in scope for the entire function, regardless where it was declared. The following example shows a code snippet that used to compile but leads to an error starting from version 0.5.0."
msgstr ""

#: ../../control-structures.rst:500 bee0c2fde129472395545880232a405e
msgid "Checked or Unchecked Arithmetic"
msgstr ""

#: ../../control-structures.rst:502 482587c9f44a475fa4bb9c1d5e4030a8
msgid "An overflow or underflow is the situation where the resulting value of an arithmetic operation, when executed on an unrestricted integer, falls outside the range of the result type."
msgstr ""

#: ../../control-structures.rst:505 d32c0ef8169d4422a14416bffa91d456
msgid "Prior to Solidity 0.8.0, arithmetic operations would always wrap in case of under- or overflow leading to widespread use of libraries that introduce additional checks."
msgstr ""

#: ../../control-structures.rst:509 a2ee8fc2c1fb49668c209a5e41457d94
msgid "Since Solidity 0.8.0, all arithmetic operations revert on over- and underflow by default, thus making the use of these libraries unnecessary."
msgstr ""

#: ../../control-structures.rst:512 ac7a1f41bfaa464fbefda5f3e74e79db
msgid "To obtain the previous behaviour, an ``unchecked`` block can be used:"
msgstr ""

#: ../../control-structures.rst:529 ac18cb2ffc834923861f09aebf61e808
msgid "The call to ``f(2, 3)`` will return ``2**256-1``, while ``g(2, 3)`` will cause a failing assertion."
msgstr ""

#: ../../control-structures.rst:532 5ba17a1a85004e27a0da5e73223e5487
msgid "The ``unchecked`` block can be used everywhere inside a block, but not as a replacement for a block. It also cannot be nested."
msgstr ""

#: ../../control-structures.rst:535 3a235f7cd0d1454cae8d307f7a92773c
msgid "The setting only affects the statements that are syntactically inside the block. Functions called from within an ``unchecked`` block do not inherit the property."
msgstr ""

#: ../../control-structures.rst:539 db5e09fe9338482895aaa46ff6f959bc
msgid "To avoid ambiguity, you cannot use ``_;`` inside an ``unchecked`` block."
msgstr ""

#: ../../control-structures.rst:541 5f09c424d1e6495f8df590c07bc05baa
msgid "The following operators will cause a failing assertion on overflow or underflow and will wrap without an error if used inside an unchecked block:"
msgstr ""

#: ../../control-structures.rst:544 857062ffc2064ce28e215de45be9628d
msgid "``++``, ``--``, ``+``, binary ``-``, unary ``-``, ``*``, ``/``, ``%``, ``**``"
msgstr ""

#: ../../control-structures.rst:546 1a4e605eaf844e1dadccae4175e78721
msgid "``+=``, ``-=``, ``*=``, ``/=``, ``%=``"
msgstr ""

#: ../../control-structures.rst:549 4c5f1e0b36064ae69903955cd61a72ca
msgid "It is not possible to disable the check for division by zero or modulo by zero using the ``unchecked`` block."
msgstr ""

#: ../../control-structures.rst:553 b10dd09302904ba19e711697735b01d3
msgid "Bitwise operators do not perform overflow or underflow checks. This is particularly visible when using bitwise shifts (``<<``, ``>>``, ``<<=``, ``>>=``) in place of integer division and multiplication by a power of 2. For example ``type(uint256).max << 3`` does not revert even though ``type(uint256).max * 8`` would."
msgstr ""

#: ../../control-structures.rst:559 0e8364a74e4f43cf8b04e2f3f8cf60b2
msgid "The second statement in ``int x = type(int).min; -x;`` will result in an overflow because the negative range can hold one more value than the positive range."
msgstr ""

#: ../../control-structures.rst:562 5d6b0c515ae049d4be4cdd5e1f82165a
msgid "Explicit type conversions will always truncate and never cause a failing assertion with the exception of a conversion from an integer to an enum type."
msgstr ""

#: ../../control-structures.rst:570 9f67c5e1a7ba4bd1bf7df8c1e3b52c01
msgid "Error handling: Assert, Require, Revert and Exceptions"
msgstr ""

#: ../../control-structures.rst:572 dcc47060ac984f2a8b50c6e188531883
msgid "Solidity uses state-reverting exceptions to handle errors. Such an exception undoes all changes made to the state in the current call (and all its sub-calls) and flags an error to the caller."
msgstr ""

#: ../../control-structures.rst:577 fc72f6ae8db34d8f9d8bbb1d6a75c492
msgid "When exceptions happen in a sub-call, they \"bubble up\" (i.e., exceptions are rethrown) automatically unless they are caught in a ``try/catch`` statement. Exceptions to this rule are ``send`` and the low-level functions ``call``, ``delegatecall`` and ``staticcall``: they return ``false`` as their first return value in case of an exception instead of \"bubbling up\"."
msgstr ""

#: ../../control-structures.rst:585 2e973de85d774201b15cdac89a077926
msgid "The low-level functions ``call``, ``delegatecall`` and ``staticcall`` return ``true`` as their first return value if the account called is non-existent, as part of the design of the EVM. Account existence must be checked prior to calling if needed."
msgstr ""

#: ../../control-structures.rst:590 77a029b44476410eaa78a3b4002dd938
msgid "Exceptions can contain error data that is passed back to the caller in the form of :ref:`error instances <errors>`. The built-in errors ``Error(string)`` and ``Panic(uint256)`` are used by special functions, as explained below. ``Error`` is used for \"regular\" error conditions while ``Panic`` is used for errors that should not be present in bug-free code."
msgstr ""

#: ../../control-structures.rst:597 ec15d68411c94cebb1a13bd46d64ad8b
msgid "Panic via ``assert`` and Error via ``require``"
msgstr ""

#: ../../control-structures.rst:599 fa0d5e1d7985467d9ec65a0803be6065
msgid "The convenience functions ``assert`` and ``require`` can be used to check for conditions and throw an exception if the condition is not met."
msgstr ""

#: ../../control-structures.rst:602 234c3949a44c4a0b8e1015b6068e09df
msgid "The ``assert`` function creates an error of type ``Panic(uint256)``. The same error is created by the compiler in certain situations as listed below."
msgstr ""

#: ../../control-structures.rst:605 4b03d77bce4444e0b008763fc8942127
msgid "Assert should only be used to test for internal errors, and to check invariants. Properly functioning code should never create a Panic, not even on invalid external input. If this happens, then there is a bug in your contract which you should fix. Language analysis tools can evaluate your contract to identify the conditions and function calls which will cause a Panic."
msgstr ""

#: ../../control-structures.rst:613 29aa983ff0f14a11bb287bf8a2de74fe
msgid "A Panic exception is generated in the following situations. The error code supplied with the error data indicates the kind of panic."
msgstr ""

#: ../../control-structures.rst:616 81f8e2bf6f5e41f3b41429da8c042421
msgid "0x00: Used for generic compiler inserted panics."
msgstr ""

#: ../../control-structures.rst:617 7a74a780d7ef404abd0bf0c85fb474ef
msgid "0x01: If you call ``assert`` with an argument that evaluates to false."
msgstr ""

#: ../../control-structures.rst:618 e047aa95a8f9495ea97ccdbbe7f4f643
msgid "0x11: If an arithmetic operation results in underflow or overflow outside of an ``unchecked { ... }`` block."
msgstr ""

#: ../../control-structures.rst:619 835b7552273a445ebe9b6e5ce0a2a1fd
msgid "0x12; If you divide or modulo by zero (e.g. ``5 / 0`` or ``23 % 0``)."
msgstr ""

#: ../../control-structures.rst:620 9050aee18f3f46bcae5fc872e35fbea6
msgid "0x21: If you convert a value that is too big or negative into an enum type."
msgstr ""

#: ../../control-structures.rst:621 d1c953acc6394cc0a9ccf572320722b8
msgid "0x22: If you access a storage byte array that is incorrectly encoded."
msgstr ""

#: ../../control-structures.rst:622 cf2db69742b249df832b76db378bc042
msgid "0x31: If you call ``.pop()`` on an empty array."
msgstr ""

#: ../../control-structures.rst:623 c40e80306ba346a8a0d69dbabeb7be8b
msgid "0x32: If you access an array, ``bytesN`` or an array slice at an out-of-bounds or negative index (i.e. ``x[i]`` where ``i >= x.length`` or ``i < 0``)."
msgstr ""

#: ../../control-structures.rst:624 f19c5b883b4345269cd50f9fae87ee01
msgid "0x41: If you allocate too much memory or create an array that is too large."
msgstr ""

#: ../../control-structures.rst:625 3aef3e6660ca41229a2f05f5740c37dd
msgid "0x51: If you call a zero-initialized variable of internal function type."
msgstr ""

#: ../../control-structures.rst:627 3506197a9cce4b2aa81570b8dd08497b
msgid "The ``require`` function either creates an error without any data or an error of type ``Error(string)``. It should be used to ensure valid conditions that cannot be detected until execution time. This includes conditions on inputs or return values from calls to external contracts."
msgstr ""

#: ../../control-structures.rst:636 c93d5e4b787b4e95bd19f9d405deae8c
msgid "It is currently not possible to use custom errors in combination with ``require``. Please use ``if (!condition) revert CustomError();`` instead."
msgstr ""

#: ../../control-structures.rst:639 8e4a9d5244494eb9becbe2105318a96e
msgid "An ``Error(string)`` exception (or an exception without data) is generated by the compiler in the following situations:"
msgstr ""

#: ../../control-structures.rst:643 7b8aeeb465f74a83aef0682f18cda5aa
msgid "Calling ``require(x)`` where ``x`` evaluates to ``false``."
msgstr ""

#: ../../control-structures.rst:644 80ce798d213f499e9c0018ce715f23d6
msgid "If you use ``revert()`` or ``revert(\"description\")``."
msgstr ""

#: ../../control-structures.rst:645 f43007ffbbf74878bb3abb439297c068
msgid "If you perform an external function call targeting a contract that contains no code."
msgstr ""

#: ../../control-structures.rst:646 9b6bcb2e7a8a4733ac74f05bd3036adc
msgid "If your contract receives Ether via a public function without ``payable`` modifier (including the constructor and the fallback function)."
msgstr ""

#: ../../control-structures.rst:648 61dbe3e6207f4c28beedf766b542a067
msgid "If your contract receives Ether via a public getter function."
msgstr ""

#: ../../control-structures.rst:650 40a0d4abca1944bc9efdeb0c4739f490
msgid "For the following cases, the error data from the external call (if provided) is forwarded. This means that it can either cause an `Error` or a `Panic` (or whatever else was given):"
msgstr ""

#: ../../control-structures.rst:654 4514b5598c684dd786c4a94cf9f869d6
msgid "If a ``.transfer()`` fails."
msgstr ""

#: ../../control-structures.rst:655 f583d70577504e849953fe0573dfd7c1
msgid "If you call a function via a message call but it does not finish properly (i.e., it runs out of gas, has no matching function, or throws an exception itself), except when a low level operation ``call``, ``send``, ``delegatecall``, ``callcode`` or ``staticcall`` is used. The low level operations never throw exceptions but indicate failures by returning ``false``."
msgstr ""

#: ../../control-structures.rst:661 435ac6a7fee84b848f18d9aad3da9cc4
msgid "If you create a contract using the ``new`` keyword but the contract creation :ref:`does not finish properly<creating-contracts>`."
msgstr ""

#: ../../control-structures.rst:664 c325066912b74cb6a5df30ab654dd456
msgid "You can optionally provide a message string for ``require``, but not for ``assert``."
msgstr ""

#: ../../control-structures.rst:667 30a0dd9ac6f2499dbcc864e57afc6ca8
msgid "If you do not provide a string argument to ``require``, it will revert with empty error data, not even including the error selector."
msgstr ""

#: ../../control-structures.rst:671 fb489c982fd941f4a48d9f54909fe678
msgid "The following example shows how you can use ``require`` to check conditions on inputs and ``assert`` for internal error checking."
msgstr ""

#: ../../control-structures.rst:693 c3af710598a3475d91f5081e5fd8dc94
msgid "Internally, Solidity performs a revert operation (instruction ``0xfd``). This causes the EVM to revert all changes made to the state. The reason for reverting is that there is no safe way to continue execution, because an expected effect did not occur. Because we want to keep the atomicity of transactions, the safest action is to revert all changes and make the whole transaction (or at least call) without effect."
msgstr ""

#: ../../control-structures.rst:701 0f73eb2ce1ad42c0b2d1e4298f4c9cfe
msgid "In both cases, the caller can react on such failures using ``try``/``catch``, but the changes in the callee will always be reverted."
msgstr ""

#: ../../control-structures.rst:706 4fbb59a325424fb3b06e5a617abded28
msgid "Panic exceptions used to use the ``invalid`` opcode before Solidity 0.8.0, which consumed all gas available to the call. Exceptions that use ``require`` used to consume all gas until before the Metropolis release."
msgstr ""

#: ../../control-structures.rst:713 1299f92642124fd7af631c1131fd8400
msgid "``revert``"
msgstr ""

#: ../../control-structures.rst:715 95af855902b54783964c7b69d263ba00
msgid "A direct revert can be triggered using the ``revert`` statement and the ``revert`` function."
msgstr ""

#: ../../control-structures.rst:717 89b32f9c439742398dd1147375522004
msgid "The ``revert`` statement takes a custom error as direct argument without parentheses:"
msgstr ""

#: ../../control-structures.rst:719 396d86a7586242d8b7da48d97845033c
msgid "revert CustomError(arg1, arg2);"
msgstr ""

#: ../../control-structures.rst:721 4946f1c3997e4027ab7bd0606d705f3b
msgid "For backwards-compatibility reasons, there is also the ``revert()`` function, which uses parentheses and accepts a string:"
msgstr ""

#: ../../control-structures.rst:724 a44ba45a1877436aa7e029d7ca883c38
msgid "revert(); revert(\"description\");"
msgstr ""

#: ../../control-structures.rst:727 2edaa173858e4c8c9c6f7818144e89e2
msgid "The error data will be passed back to the caller and can be caught there. Using ``revert()`` causes a revert without any error data while ``revert(\"description\")`` will create an ``Error(string)`` error."
msgstr ""

#: ../../control-structures.rst:731 86f35c76b9724223805f2be30804452d
msgid "Using a custom error instance will usually be much cheaper than a string description, because you can use the name of the error to describe it, which is encoded in only four bytes. A longer description can be supplied via NatSpec which does not incur any costs."
msgstr ""

#: ../../control-structures.rst:736 1dd43d43181f4375a747ad57f33b1919
msgid "The following example shows how to use an error string and a custom error instance together with ``revert`` and the equivalent ``require``:"
msgstr ""

#: ../../control-structures.rst:765 6a1cd48669754382afef0ff7965afacb
msgid "The two ways ``if (!condition) revert(...);`` and ``require(condition, ...);`` are equivalent as long as the arguments to ``revert`` and ``require`` do not have side-effects, for example if they are just strings."
msgstr ""

#: ../../control-structures.rst:770 77d8af67090f4235a7a23af1b83dba08
msgid "The ``require`` function is evaluated just as any other function. This means that all arguments are evaluated before the function itself is executed. In particular, in ``require(condition, f())`` the function ``f`` is executed even if ``condition`` is true."
msgstr ""

#: ../../control-structures.rst:775 cb504b86eaea445a930de886f8f8318f
msgid "The provided string is :ref:`abi-encoded <ABI>` as if it were a call to a function ``Error(string)``. In the above example, ``revert(\"Not enough Ether provided.\");`` returns the following hexadecimal as error return data:"
msgstr ""

#: ../../control-structures.rst:785 fd4146b2c2554f3f9561b18db9940a16
msgid "The provided message can be retrieved by the caller using ``try``/``catch`` as shown below."
msgstr ""

#: ../../control-structures.rst:788 00c11b9a4b984627b2b3035ae439408c
msgid "There used to be a keyword called ``throw`` with the same semantics as ``revert()`` which was deprecated in version 0.4.13 and removed in version 0.5.0."
msgstr ""

#: ../../control-structures.rst:795 692ee8b9648441a08f5d339173ec3557
msgid "``try``/``catch``"
msgstr ""

#: ../../control-structures.rst:797 91b6149689b547c7a6d700e3d5bb436e
msgid "A failure in an external call can be caught using a try/catch statement, as follows:"
msgstr ""

#: ../../control-structures.rst:836 a4df5dd046534151845b7e27e4a2c4db
msgid "The ``try`` keyword has to be followed by an expression representing an external function call or a contract creation (``new ContractName()``). Errors inside the expression are not caught (for example if it is a complex expression that also involves internal function calls), only a revert happening inside the external call itself. The ``returns`` part (which is optional) that follows declares return variables matching the types returned by the external call. In case there was no error, these variables are assigned and the contract's execution continues inside the first success block. If the end of the success block is reached, execution continues after the ``catch`` blocks."
msgstr ""

#: ../../control-structures.rst:845 808cebb932064b919b2d66f6a07a3c77
msgid "Solidity supports different kinds of catch blocks depending on the type of error:"
msgstr ""

#: ../../control-structures.rst:848 f0ee5ab257774d54ae5b005d4a18ae81
msgid "``catch Error(string memory reason) { ... }``: This catch clause is executed if the error was caused by ``revert(\"reasonString\")`` or ``require(false, \"reasonString\")`` (or an internal error that causes such an exception)."
msgstr ""

#: ../../control-structures.rst:852 a493345282c044f9ab1487fe1490c3f8
msgid "``catch Panic(uint errorCode) { ... }``: If the error was caused by a panic, i.e. by a failing ``assert``, division by zero, invalid array access, arithmetic overflow and others, this catch clause will be run."
msgstr ""

#: ../../control-structures.rst:855 22c27c94ba904e39aeb1a2b598be1d90
msgid "``catch (bytes memory lowLevelData) { ... }``: This clause is executed if the error signature does not match any other clause, if there was an error while decoding the error message, or if no error data was provided with the exception. The declared variable provides access to the low-level error data in that case."
msgstr ""

#: ../../control-structures.rst:861 ffce5ea4100c40209d0fcc6d161a63e3
msgid "``catch { ... }``: If you are not interested in the error data, you can just use ``catch { ... }`` (even as the only catch clause) instead of the previous clause."
msgstr ""

#: ../../control-structures.rst:865 cc40ff7f0e4d4fba8a5f00c701a0c767
msgid "It is planned to support other types of error data in the future. The strings ``Error`` and ``Panic`` are currently parsed as is and are not treated as identifiers."
msgstr ""

#: ../../control-structures.rst:868 6ac23a46927d413599cfee7c4cab82ba
msgid "In order to catch all error cases, you have to have at least the clause ``catch { ...}`` or the clause ``catch (bytes memory lowLevelData) { ... }``."
msgstr ""

#: ../../control-structures.rst:871 b88505b3318346d784f80804f862c14b
msgid "The variables declared in the ``returns`` and the ``catch`` clause are only in scope in the block that follows."
msgstr ""

#: ../../control-structures.rst:876 8c1668f1d3b645baaed416b18ec6ac54
msgid "If an error happens during the decoding of the return data inside a try/catch-statement, this causes an exception in the currently executing contract and because of that, it is not caught in the catch clause. If there is an error during decoding of ``catch Error(string memory reason)`` and there is a low-level catch clause, this error is caught there."
msgstr ""

#: ../../control-structures.rst:884 41e2bec14ae248efa95cb5bf198748a4
msgid "If execution reaches a catch-block, then the state-changing effects of the external call have been reverted. If execution reaches the success block, the effects were not reverted. If the effects have been reverted, then execution either continues in a catch block or the execution of the try/catch statement itself reverts (for example due to decoding failures as noted above or due to not providing a low-level catch clause)."
msgstr ""

#: ../../control-structures.rst:893 84d9de7ba4494e8bb825f91719679a83
msgid "The reason behind a failed call can be manifold. Do not assume that the error message is coming directly from the called contract: The error might have happened deeper down in the call chain and the called contract just forwarded it. Also, it could be due to an out-of-gas situation and not a deliberate error condition: The caller always retains at least 1/64th of the gas in a call and thus even if the called contract goes out of gas, the caller still has some gas left."
msgstr ""

