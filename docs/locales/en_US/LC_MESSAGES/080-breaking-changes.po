# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2016-2021, Ethereum
# This file is distributed under the same license as the Solidity package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Solidity 0.8.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-01-13 16:47+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../080-breaking-changes.rst:3 1de5a8e481a9479bba83015d3610360d
msgid "Solidity v0.8.0 Breaking Changes"
msgstr ""

#: ../../080-breaking-changes.rst:5 0d0c4aab71124cba9c32c44ee3b51d54
msgid ""
"This section highlights the main breaking changes introduced in Solidity "
"version 0.8.0. For the full list check `the release changelog "
"<https://github.com/ethereum/solidity/releases/tag/v0.8.0>`_."
msgstr ""

#: ../../080-breaking-changes.rst:11 ffe937e0722f4cebad01500ffb2bf3c7
msgid "Silent Changes of the Semantics"
msgstr ""

#: ../../080-breaking-changes.rst:13 b851caeaf1bf4ceaa3e2f78af6543af4
msgid ""
"This section lists changes where existing code changes its behaviour "
"without the compiler notifying you about it."
msgstr ""

#: ../../080-breaking-changes.rst:16 464658e429134fd8973081acfd989529
msgid ""
"Arithmetic operations revert on underflow and overflow. You can use "
"``unchecked { ... }`` to use the previous wrapping behaviour."
msgstr ""

#: ../../080-breaking-changes.rst:19 2ccc9b1a9bb8420cbb36256ed1b17c57
msgid ""
"Checks for overflow are very common, so we made them the default to "
"increase readability of code, even if it comes at a slight increase of "
"gas costs."
msgstr ""

#: ../../080-breaking-changes.rst:22 f75bd6669b7941fbae28144933b28bd8
msgid "ABI coder v2 is activated by default."
msgstr ""

#: ../../080-breaking-changes.rst:24 edef94b1404a43b2850960ee0b7816a2
msgid ""
"You can choose to use the old behaviour using ``pragma abicoder v1;``. "
"The pragma ``pragma experimental ABIEncoderV2;`` is still valid, but it "
"is deprecated and has no effect. If you want to be explicit, please use "
"``pragma abicoder v2;`` instead."
msgstr ""

#: ../../080-breaking-changes.rst:28 92770ed58526487faba9988593db5e78
msgid ""
"Note that ABI coder v2 supports more types than v1 and performs more "
"sanity checks on the inputs. ABI coder v2 makes some function calls more "
"expensive and it can also make contract calls revert that did not revert "
"with ABI coder v1 when they contain data that does not conform to the "
"parameter types."
msgstr ""

#: ../../080-breaking-changes.rst:33 d8408f36274e42eb9ed9db4765affa5d
msgid ""
"Exponentiation is right associative, i.e., the expression ``a**b**c`` is "
"parsed as ``a**(b**c)``. Before 0.8.0, it was parsed as ``(a**b)**c``."
msgstr ""

#: ../../080-breaking-changes.rst:36 511391cc729a4192823ec5fdc9e40c77
msgid "This is the common way to parse the exponentiation operator."
msgstr ""

#: ../../080-breaking-changes.rst:38 598200c8d7304cc69b8239ea9fa8801c
msgid ""
"Failing assertions and other internal checks like division by zero or "
"arithmetic overflow do not use the invalid opcode but instead the revert "
"opcode. More specifically, they will use error data equal to a function "
"call to ``Panic(uint256)`` with an error code specific to the "
"circumstances."
msgstr ""

#: ../../080-breaking-changes.rst:43 c7bc6a35b31046f7baaed4f17b75045f
msgid ""
"This will save gas on errors while it still allows static analysis tools "
"to distinguish these situations from a revert on invalid input, like a "
"failing ``require``."
msgstr ""

#: ../../080-breaking-changes.rst:46 d03258e854644accbe113fd67a9aadb6
msgid ""
"If a byte array in storage is accessed whose length is encoded "
"incorrectly, a panic is caused. A contract cannot get into this situation"
" unless inline assembly is used to modify the raw representation of "
"storage byte arrays."
msgstr ""

#: ../../080-breaking-changes.rst:49 42f9317ce7754d89b51b612e84c71fb2
msgid ""
"If constants are used in array length expressions, previous versions of "
"Solidity would use arbitrary precision in all branches of the evaluation "
"tree. Now, if constant variables are used as intermediate expressions, "
"their values will be properly rounded in the same way as when they are "
"used in run-time expressions."
msgstr ""

#: ../../080-breaking-changes.rst:53 61b027dbbad54b1fb43c0b0e7aae0090
msgid "The type ``byte`` has been removed. It was an alias of ``bytes1``."
msgstr ""

#: ../../080-breaking-changes.rst:56 6666aebdf48547e5b1ce6d9d4db873c8
msgid "New Restrictions"
msgstr ""

#: ../../080-breaking-changes.rst:58 350de658f239402ea7bf70a51dd6ecd1
msgid ""
"This section lists changes that might cause existing contracts to not "
"compile anymore."
msgstr ""

#: ../../080-breaking-changes.rst:60 191489d87c00409d8390dc063f7a9540
msgid ""
"There are new restrictions related to explicit conversions of literals. "
"The previous behaviour in the following cases was likely ambiguous:"
msgstr ""

#: ../../080-breaking-changes.rst:63 59d83dce8ce94e41a080da69704263f9
msgid ""
"Explicit conversions from negative literals and literals larger than "
"``type(uint160).max`` to ``address`` are disallowed."
msgstr ""

#: ../../080-breaking-changes.rst:65 29855a6868114a8da5bd3a9a433a4dd5
msgid ""
"Explicit conversions between literals and an integer type ``T`` are only "
"allowed if the literal lies between ``type(T).min`` and ``type(T).max``. "
"In particular, replace usages of ``uint(-1)`` with ``type(uint).max``."
msgstr ""

#: ../../080-breaking-changes.rst:68 c48d069548f94db295e201a93641010e
msgid ""
"Explicit conversions between literals and enums are only allowed if the "
"literal can represent a value in the enum."
msgstr ""

#: ../../080-breaking-changes.rst:70 1e785c09cca64c3ca554aa5e9739a1c7
msgid ""
"Explicit conversions between literals and ``address`` type (e.g. "
"``address(literal)``) have the type ``address`` instead of ``address "
"payable``. One can get a payable address type by using an explicit "
"conversion, i.e., ``payable(literal)``."
msgstr ""

#: ../../080-breaking-changes.rst:74 b827e6b393fa4809832c3238239d00fd
msgid ""
":ref:`Address literals<address_literals>` have the type ``address`` "
"instead of ``address payable``. They can be converted to ``address "
"payable`` by using an explicit conversion, e.g. "
"``payable(0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF)``."
msgstr ""

#: ../../080-breaking-changes.rst:78 4cbfa394c7274da881a9b3888b19a8d1
msgid ""
"There are new restrictions on explicit type conversions. The conversion "
"is only allowed when there is at most one change in sign, width or type-"
"category (``int``, ``address``, ``bytesNN``, etc.). To perform multiple "
"changes, use multiple conversions."
msgstr ""

#: ../../080-breaking-changes.rst:82 c195c134ec6c430794529124ff05d405
msgid ""
"Let us use the notation ``T(S)`` to denote the explicit conversion "
"``T(x)``, where, ``T`` and ``S`` are types, and ``x`` is any arbitrary "
"variable of type ``S``. An example of such a disallowed conversion would "
"be ``uint16(int8)`` since it changes both width (8 bits to 16 bits) and "
"sign (signed integer to unsigned integer). In order to do the conversion,"
" one has to go through an intermediate type. In the previous example, "
"this would be ``uint16(uint8(int8))`` or ``uint16(int16(int8))``. Note "
"that the two ways to convert will produce different results e.g., for "
"``-1``. The following are some examples of conversions that are "
"disallowed by this rule."
msgstr ""

#: ../../080-breaking-changes.rst:90 084207f322454f0192a9d87cda2c6aa4
msgid ""
"``address(uint)`` and ``uint(address)``: converting both type-category "
"and width. Replace this by ``address(uint160(uint))`` and "
"``uint(uint160(address))`` respectively."
msgstr ""

#: ../../080-breaking-changes.rst:92 f63d32488f92425287a532bec5e91c02
msgid ""
"``payable(uint160)``, ``payable(bytes20)`` and ``payable(integer-"
"literal)``: converting both type-category and state-mutability. Replace "
"this by ``payable(address(uint160))``, ``payable(address(bytes20))`` and "
"``payable(address(integer-literal))`` respectively. Note that "
"``payable(0)`` is valid and is an exception to the rule."
msgstr ""

#: ../../080-breaking-changes.rst:96 d73ff3b23ee9409193a3460de8a8b91b
msgid ""
"``int80(bytes10)`` and ``bytes10(int80)``: converting both type-category "
"and sign. Replace this by ``int80(uint80(bytes10))`` and "
"``bytes10(uint80(int80)`` respectively."
msgstr ""

#: ../../080-breaking-changes.rst:98 5a1e06621c7f46c68d46624aecfe97f6
msgid ""
"``Contract(uint)``: converting both type-category and width. Replace this"
" by ``Contract(address(uint160(uint)))``."
msgstr ""

#: ../../080-breaking-changes.rst:101 7a2881ba2f19474099c46bbd21ea4807
msgid ""
"These conversions were disallowed to avoid ambiguity. For example, in the"
" expression ``uint16 x = uint16(int8(-1))``, the value of ``x`` would "
"depend on whether the sign or the width conversion was applied first."
msgstr ""

#: ../../080-breaking-changes.rst:105 b30792624012418287c2d1668fd44780
msgid ""
"Function call options can only be given once, i.e. ``c.f{gas: "
"10000}{value: 1}()`` is invalid and has to be changed to ``c.f{gas: "
"10000, value: 1}()``."
msgstr ""

#: ../../080-breaking-changes.rst:107 3cf587f8ef044b7a80faceebee0712af
msgid ""
"The global functions ``log0``, ``log1``, ``log2``, ``log3`` and ``log4`` "
"have been removed."
msgstr ""

#: ../../080-breaking-changes.rst:109 fcf13350fc8f4931b5c3e0a5f02cdcaa
msgid ""
"These are low-level functions that were largely unused. Their behaviour "
"can be accessed from inline assembly."
msgstr ""

#: ../../080-breaking-changes.rst:111 2c749f37f09b47869c6bbf5558beb3e5
msgid "``enum`` definitions cannot contain more than 256 members."
msgstr ""

#: ../../080-breaking-changes.rst:113 fdbbffe11b834b3085e6d65c809e7ac9
msgid ""
"This will make it safe to assume that the underlying type in the ABI is "
"always ``uint8``."
msgstr ""

#: ../../080-breaking-changes.rst:115 79658c4a28814ad3aa86597158642cc7
msgid ""
"Declarations with the name ``this``, ``super`` and ``_`` are disallowed, "
"with the exception of public functions and events. The exception is to "
"make it possible to declare interfaces of contracts implemented in "
"languages other than Solidity that do permit such function names."
msgstr ""

#: ../../080-breaking-changes.rst:119 34895a9e169e4e9ebe52e704020323b7
msgid ""
"Remove support for the ``\\b``, ``\\f``, and ``\\v`` escape sequences in "
"code. They can still be inserted via hexadecimal escapes, e.g. ``\\x08``,"
" ``\\x0c``, and ``\\x0b``, respectively."
msgstr ""

#: ../../080-breaking-changes.rst:122 1011700365424a02b32b8246ef70bbd0
msgid ""
"The global variables ``tx.origin`` and ``msg.sender`` have the type "
"``address`` instead of ``address payable``. One can convert them into "
"``address payable`` by using an explicit conversion, i.e., "
"``payable(tx.origin)`` or ``payable(msg.sender)``."
msgstr ""

#: ../../080-breaking-changes.rst:126 ee433433c44a482490699b4d2393164a
msgid ""
"This change was done since the compiler cannot determine whether or not "
"these addresses are payable or not, so it now requires an explicit "
"conversion to make this requirement visible."
msgstr ""

#: ../../080-breaking-changes.rst:129 d5dee4df31164a988909e7a5f147038e
msgid ""
"Explicit conversion into ``address`` type always returns a non-payable "
"``address`` type. In particular, the following explicit conversions have "
"the type ``address`` instead of ``address payable``:"
msgstr ""

#: ../../080-breaking-changes.rst:133 6b23eb62ee184ea9ac6b7c2a45a5b276
msgid ""
"``address(u)`` where ``u`` is a variable of type ``uint160``. One can "
"convert ``u`` into the type ``address payable`` by using two explicit "
"conversions, i.e., ``payable(address(u))``."
msgstr ""

#: ../../080-breaking-changes.rst:136 1fb9d291e40e4a4792a10da4962b1eef
msgid ""
"``address(b)`` where ``b`` is a variable of type ``bytes20``. One can "
"convert ``b`` into the type ``address payable`` by using two explicit "
"conversions, i.e., ``payable(address(b))``."
msgstr ""

#: ../../080-breaking-changes.rst:139 1531e122f9e9438eb45cf4f7970eb7a6
msgid ""
"``address(c)`` where ``c`` is a contract. Previously, the return type of "
"this conversion depended on whether the contract can receive Ether "
"(either by having a receive function or a payable fallback function). The"
" conversion ``payable(c)`` has the type ``address payable`` and is only "
"allowed when the contract ``c`` can receive Ether. In general, one can "
"always convert ``c`` into the type ``address payable`` by using the "
"following explicit conversion: ``payable(address(c))``. Note that "
"``address(this)`` falls under the same category as ``address(c)`` and the"
" same rules apply for it."
msgstr ""

#: ../../080-breaking-changes.rst:147 951071fac96645a5a082227c07bd079b
msgid ""
"The ``chainid`` builtin in inline assembly is now considered ``view`` "
"instead of ``pure``."
msgstr ""

#: ../../080-breaking-changes.rst:149 10f7cd008b8a46b19695fe3a02fc0737
msgid ""
"Unary negation cannot be used on unsigned integers anymore, only on "
"signed integers."
msgstr ""

#: ../../080-breaking-changes.rst:152 d609db116fa34592bc7504da8b1f7e02
msgid "Interface Changes"
msgstr ""

#: ../../080-breaking-changes.rst:154 7b92e36c6ac6441393777e6b7710b686
msgid ""
"The output of ``--combined-json`` has changed: JSON fields ``abi``, "
"``devdoc``, ``userdoc`` and ``storage-layout`` are sub-objects now. "
"Before 0.8.0 they used to be serialised as strings."
msgstr ""

#: ../../080-breaking-changes.rst:157 7c9e199b88d14e0bbec940020f4f0a41
msgid ""
"The \"legacy AST\" has been removed (``--ast-json`` on the commandline "
"interface and ``legacyAST`` for standard JSON). Use the \"compact AST\" "
"(``--ast-compact--json`` resp. ``AST``) as replacement."
msgstr ""

#: ../../080-breaking-changes.rst:160 61f2c940b2e04e88a6136a66448fd012
msgid "The old error reporter (``--old-reporter``) has been removed."
msgstr ""

#: ../../080-breaking-changes.rst:164 c545b017bd3b47e780f0c284f346587b
msgid "How to update your code"
msgstr ""

#: ../../080-breaking-changes.rst:166 7fe99b1405c44390913d6e53ab9be4f0
msgid ""
"If you rely on wrapping arithmetic, surround each operation with "
"``unchecked { ... }``."
msgstr ""

#: ../../080-breaking-changes.rst:167 1d89535bba404836b50330dcb3dd7837
msgid ""
"Optional: If you use SafeMath or a similar library, change ``x.add(y)`` "
"to ``x + y``, ``x.mul(y)`` to ``x * y`` etc."
msgstr ""

#: ../../080-breaking-changes.rst:168 a8eb025c65ae406a809b1926c2449be2
msgid "Add ``pragma abicoder v1;`` if you want to stay with the old ABI coder."
msgstr ""

#: ../../080-breaking-changes.rst:169 785805263dc44755bce8e0c5db0dbb7b
msgid ""
"Optionally remove ``pragma experimental ABIEncoderV2`` or ``pragma "
"abicoder v2`` since it is redundant."
msgstr ""

#: ../../080-breaking-changes.rst:170 9ac392d1c90b406398af1b7754a90345
msgid "Change ``byte`` to ``bytes1``."
msgstr ""

#: ../../080-breaking-changes.rst:171 edb0ef185d8849bbbc36023b85eeb56b
msgid "Add intermediate explicit type conversions if required."
msgstr ""

#: ../../080-breaking-changes.rst:172 fa53d7b436af48d7ac8168d992acdc2f
msgid ""
"Combine ``c.f{gas: 10000}{value: 1}()`` to ``c.f{gas: 10000, value: "
"1}()``."
msgstr ""

#: ../../080-breaking-changes.rst:173 3078aad8e38848ed8bd438bdf6836e25
msgid ""
"Change ``msg.sender.transfer(x)`` to ``payable(msg.sender).transfer(x)`` "
"or use a stored variable of ``address payable`` type."
msgstr ""

#: ../../080-breaking-changes.rst:174 86f1812fc2324ac590ad5c317fcabc76
msgid "Change ``x**y**z`` to ``(x**y)**z``."
msgstr ""

#: ../../080-breaking-changes.rst:175 135ddc966b68431992f53cfb49ab7aab
msgid "Use inline assembly as a replacement for ``log0``, ..., ``log4``."
msgstr ""

#: ../../080-breaking-changes.rst:176 e3069ef44ed8473a97a201f57c79b8a3
msgid ""
"Negate unsigned integers by subtracting them from the maximum value of "
"the type and adding 1 (e.g. ``type(uint256).max - x + 1``, while ensuring"
" that `x` is not zero)"
msgstr ""

