# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2016-2021, Ethereum
# This file is distributed under the same license as the Solidity package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Solidity 0.8.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-01-13 16:47+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../abi-spec.rst:7 5ae569d9e6d7400caef5073c156a2ce3
msgid "Contract ABI Specification"
msgstr ""

#: ../../abi-spec.rst:10 f5a38b86705a4bec85029079f1ec6413
msgid "Basic Design"
msgstr ""

#: ../../abi-spec.rst:12 f96b687c7db94106ae66ad15e093c33c
msgid ""
"The Contract Application Binary Interface (ABI) is the standard way to "
"interact with contracts in the Ethereum ecosystem, both from outside the "
"blockchain and for contract-to-contract interaction. Data is encoded "
"according to its type, as described in this specification. The encoding "
"is not self describing and thus requires a schema in order to decode."
msgstr ""

#: ../../abi-spec.rst:16 16f08950349741339607b4293003eedf
msgid ""
"We assume the interface functions of a contract are strongly typed, known"
" at compilation time and static. We assume that all contracts will have "
"the interface definitions of any contracts they call available at "
"compile-time."
msgstr ""

#: ../../abi-spec.rst:19 4f059941c68b4148ac0610434f241e2d
msgid ""
"This specification does not address contracts whose interface is dynamic "
"or otherwise known only at run-time."
msgstr ""

#: ../../abi-spec.rst:25 d5dc23a0b9894d7eaf299e45ece03924
msgid "Function Selector"
msgstr ""

#: ../../abi-spec.rst:27 8e1cd4c55d944d37a4f0c37194c09fa4
msgid ""
"The first four bytes of the call data for a function call specifies the "
"function to be called. It is the first (left, high-order in big-endian) "
"four bytes of the Keccak-256 hash of the signature of the function. The "
"signature is defined as the canonical expression of the basic prototype "
"without data location specifier, i.e. the function name with the "
"parenthesised list of parameter types. Parameter types are split by a "
"single comma - no spaces are used."
msgstr ""

#: ../../abi-spec.rst:35 1094a469361c46b389c5e7a8f67620ed
msgid ""
"The return type of a function is not part of this signature. In "
":ref:`Solidity's function overloading <overload-function>` return types "
"are not considered. The reason is to keep function call resolution "
"context-independent. The :ref:`JSON description of the ABI<abi_json>` "
"however contains both inputs and outputs."
msgstr ""

#: ../../abi-spec.rst:41 e842bf5d6786450f972a7e36b36e43c1
msgid "Argument Encoding"
msgstr ""

#: ../../abi-spec.rst:43 64d98c91105f42268bdcea897b70a260
msgid ""
"Starting from the fifth byte, the encoded arguments follow. This encoding"
" is also used in other places, e.g. the return values and also event "
"arguments are encoded in the same way, without the four bytes specifying "
"the function."
msgstr ""

#: ../../abi-spec.rst:48 12bfd6f32f494b44b09d7a56310aefb0
msgid "Types"
msgstr ""

#: ../../abi-spec.rst:50 a98d392b02b94537b4621624eb2adb50
msgid "The following elementary types exist:"
msgstr ""

#: ../../abi-spec.rst:52 af04b95ec0ca41b9bcfe695d2ea560c9
msgid ""
"``uint<M>``: unsigned integer type of ``M`` bits, ``0 < M <= 256``, ``M %"
" 8 == 0``. e.g. ``uint32``, ``uint8``, ``uint256``."
msgstr ""

#: ../../abi-spec.rst:54 6d2069946d8c4de69df1de02e4c3d327
msgid ""
"``int<M>``: two's complement signed integer type of ``M`` bits, ``0 < M "
"<= 256``, ``M % 8 == 0``."
msgstr ""

#: ../../abi-spec.rst:56 27fef6e4f2c54ae2bbf62a3b6e079516
msgid ""
"``address``: equivalent to ``uint160``, except for the assumed "
"interpretation and language typing. For computing the function selector, "
"``address`` is used."
msgstr ""

#: ../../abi-spec.rst:59 ca9cfd8854134d4f9da241414812bca4
msgid ""
"``uint``, ``int``: synonyms for ``uint256``, ``int256`` respectively. For"
" computing the function selector, ``uint256`` and ``int256`` have to be "
"used."
msgstr ""

#: ../../abi-spec.rst:62 ac41ef1e29424a42a400f476e4cfb8c3
msgid ""
"``bool``: equivalent to ``uint8`` restricted to the values 0 and 1. For "
"computing the function selector, ``bool`` is used."
msgstr ""

#: ../../abi-spec.rst:64 855d31d632104a7c98bf13bfc532c841
msgid ""
"``fixed<M>x<N>``: signed fixed-point decimal number of ``M`` bits, ``8 <="
" M <= 256``, ``M % 8 == 0``, and ``0 < N <= 80``, which denotes the value"
" ``v`` as ``v / (10 ** N)``."
msgstr ""

#: ../../abi-spec.rst:67 7f821ab518144e079dc3fc47d393ec3d
msgid "``ufixed<M>x<N>``: unsigned variant of ``fixed<M>x<N>``."
msgstr ""

#: ../../abi-spec.rst:69 8909956b4b564c8ba19433fe70e39ea2
msgid ""
"``fixed``, ``ufixed``: synonyms for ``fixed128x18``, ``ufixed128x18`` "
"respectively. For computing the function selector, ``fixed128x18`` and "
"``ufixed128x18`` have to be used."
msgstr ""

#: ../../abi-spec.rst:72 96477cf006f1400bbf54dd4be43f4b8e
msgid "``bytes<M>``: binary type of ``M`` bytes, ``0 < M <= 32``."
msgstr ""

#: ../../abi-spec.rst:74 befda287c2674424b81e182d3f98d294
msgid ""
"``function``: an address (20 bytes) followed by a function selector (4 "
"bytes). Encoded identical to ``bytes24``."
msgstr ""

#: ../../abi-spec.rst:76 ad26bcd93f604734baf709a413c6692f
msgid "The following (fixed-size) array type exists:"
msgstr ""

#: ../../abi-spec.rst:78 4ee59958c6e34300b355e6a4d6db86d3
msgid ""
"``<type>[M]``: a fixed-length array of ``M`` elements, ``M >= 0``, of the"
" given type."
msgstr ""

#: ../../abi-spec.rst:82 692f9111b6f24695ba07d257357172ba
msgid ""
"While this ABI specification can express fixed-length arrays with zero "
"elements, they're not supported by the compiler."
msgstr ""

#: ../../abi-spec.rst:84 3b5fac20c8c04b6ca31ef24219a7000a
msgid "The following non-fixed-size types exist:"
msgstr ""

#: ../../abi-spec.rst:86 9210c1e78d914e67a307b3750ba5ce0d
msgid "``bytes``: dynamic sized byte sequence."
msgstr ""

#: ../../abi-spec.rst:88 9864986582024f329dd27634f9f29d04
msgid "``string``: dynamic sized unicode string assumed to be UTF-8 encoded."
msgstr ""

#: ../../abi-spec.rst:90 06a147db49734bafa782d2317fee4d62
msgid "``<type>[]``: a variable-length array of elements of the given type."
msgstr ""

#: ../../abi-spec.rst:92 6b9235aef86045458cff0a9292d576f8
msgid ""
"Types can be combined to a tuple by enclosing them inside parentheses, "
"separated by commas:"
msgstr ""

#: ../../abi-spec.rst:94 2bff5cf90de44cff87d344129b09799a
msgid ""
"``(T1,T2,...,Tn)``: tuple consisting of the types ``T1``, ..., ``Tn``, "
"``n >= 0``"
msgstr ""

#: ../../abi-spec.rst:96 69c125be4edb4ba5a594f7ac23c0c46e
msgid ""
"It is possible to form tuples of tuples, arrays of tuples and so on. It "
"is also possible to form zero-tuples (where ``n == 0``)."
msgstr ""

#: ../../abi-spec.rst:99 6719a9c858744eed8a12118298e3b1c3
msgid "Mapping Solidity to ABI types"
msgstr ""

#: ../../abi-spec.rst:101 5241b954dd814d68b0893f4ea09edb54
msgid ""
"Solidity supports all the types presented above with the same names with "
"the exception of tuples. On the other hand, some Solidity types are not "
"supported by the ABI. The following table shows on the left column "
"Solidity types that are not part of the ABI, and on the right column the "
"ABI types that represent them."
msgstr ""

#: ../../abi-spec.rst:108 7931106bb9614af1a1dba2507299a01e
msgid "Solidity"
msgstr ""

#: ../../abi-spec.rst:108 0287e98bb51046b6a932247ab3b5231d
msgid "ABI"
msgstr ""

#: ../../abi-spec.rst:110 65c046c38c934a19871f4cacf44e502a
msgid ":ref:`address payable<address>`"
msgstr ""

#: ../../abi-spec.rst:110 ../../abi-spec.rst:112
#: 2a09afc95254401393d8665693ecb165 8d5ad084adf646ffa6d69a728ab6b41a
msgid "``address``"
msgstr ""

#: ../../abi-spec.rst:112 fc7f884b8fba41b29e4ca3c8eeacb99f
msgid ":ref:`contract<contracts>`"
msgstr ""

#: ../../abi-spec.rst:114 b54589286ed548a78188e719b954d0c0
msgid ":ref:`enum<enums>`"
msgstr ""

#: ../../abi-spec.rst:114 ecb9f20c69364e598c62956f10ac5e25
msgid "``uint8``"
msgstr ""

#: ../../abi-spec.rst:116 aef3a79e41984b06ba03d7b4b4a4cda1
msgid ":ref:`user defined value types <user-defined-value-types>`"
msgstr ""

#: ../../abi-spec.rst:116 535ba8dfbda745e19d981d243aaeec17
msgid "its underlying value type"
msgstr ""

#: ../../abi-spec.rst:119 a6ce470d8bd04584b3a9884e950e3ca6
msgid ":ref:`struct<structs>`"
msgstr ""

#: ../../abi-spec.rst:119 9e5d18879ef64f1592fc7d7a185fb6ec
msgid "``tuple``"
msgstr ""

#: ../../abi-spec.rst:123 941401d0d7ae4fa883ed74fa6717ef8d
msgid ""
"Before version ``0.8.0`` enums could have more than 256 members and were "
"represented by the smallest integer type just big enough to hold the "
"value of any member."
msgstr ""

#: ../../abi-spec.rst:127 4e5b90a996b544dc913788cb78a6c637
msgid "Design Criteria for the Encoding"
msgstr ""

#: ../../abi-spec.rst:129 0534c24253384ec3a68e7e1519e31d5a
msgid ""
"The encoding is designed to have the following properties, which are "
"especially useful if some arguments are nested arrays:"
msgstr ""

#: ../../abi-spec.rst:131 7be18780747045909d93101f0237219a
msgid ""
"The number of reads necessary to access a value is at most the depth of "
"the value inside the argument array structure, i.e. four reads are needed"
" to retrieve ``a_i[k][l][r]``. In a previous version of the ABI, the "
"number of reads scaled linearly with the total number of dynamic "
"parameters in the worst case."
msgstr ""

#: ../../abi-spec.rst:136 ba6850a9f30a45ada49c64219f1a0097
msgid ""
"The data of a variable or array element is not interleaved with other "
"data and it is relocatable, i.e. it only uses relative \"addresses\"."
msgstr ""

#: ../../abi-spec.rst:141 ec4960c4a6984d78a714117fdd04d3fc
msgid "Formal Specification of the Encoding"
msgstr ""

#: ../../abi-spec.rst:143 9943d46123324e5084c6211ebe838056
msgid ""
"We distinguish static and dynamic types. Static types are encoded in-"
"place and dynamic types are encoded at a separately allocated location "
"after the current block."
msgstr ""

#: ../../abi-spec.rst:146 37de37ccec9d4b51b47456ccef3e5197
msgid "**Definition:** The following types are called \"dynamic\":"
msgstr ""

#: ../../abi-spec.rst:148 1be6d4a28b3d44a690922e7d729733a1
msgid "``bytes``"
msgstr ""

#: ../../abi-spec.rst:149 e9aba79e38bf4fb79efbb353243b2660
msgid "``string``"
msgstr ""

#: ../../abi-spec.rst:150 d9c242ed03b943e3857eacec8dd23c1d
msgid "``T[]`` for any ``T``"
msgstr ""

#: ../../abi-spec.rst:151 7c3cfb3c297749f1a87cc0e02bef2cbc
msgid "``T[k]`` for any dynamic ``T`` and any ``k >= 0``"
msgstr ""

#: ../../abi-spec.rst:152 bcd43c15946041499238090bf72c3bbc
msgid "``(T1,...,Tk)`` if ``Ti`` is dynamic for some ``1 <= i <= k``"
msgstr ""

#: ../../abi-spec.rst:154 94a5d0027133414282e7cdc875ae3d41
msgid "All other types are called \"static\"."
msgstr ""

#: ../../abi-spec.rst:156 ef397c0083c644a590795f96526952bf
msgid ""
"**Definition:** ``len(a)`` is the number of bytes in a binary string "
"``a``. The type of ``len(a)`` is assumed to be ``uint256``."
msgstr ""

#: ../../abi-spec.rst:159 84faf24b56d84605bddb253070db2774
msgid ""
"We define ``enc``, the actual encoding, as a mapping of values of the ABI"
" types to binary strings such that ``len(enc(X))`` depends on the value "
"of ``X`` if and only if the type of ``X`` is dynamic."
msgstr ""

#: ../../abi-spec.rst:162 7b1328c7dd6e4472b7ea8719c4757d93
msgid ""
"**Definition:** For any ABI value ``X``, we recursively define "
"``enc(X)``, depending on the type of ``X`` being"
msgstr ""

#: ../../abi-spec.rst:165 906b00d27e8d427abca306f9e6e77e1e
msgid "``(T1,...,Tk)`` for ``k >= 0`` and any types ``T1``, ..., ``Tk``"
msgstr ""

#: ../../abi-spec.rst:167 61bfa11cd10d4cf98fdfd90bbd6ea15b
msgid "``enc(X) = head(X(1)) ... head(X(k)) tail(X(1)) ... tail(X(k))``"
msgstr ""

#: ../../abi-spec.rst:169 ec0dce8349244d79bfa57d98e4eda4b6
msgid ""
"where ``X = (X(1), ..., X(k))`` and ``head`` and ``tail`` are defined for"
" ``Ti`` as follows:"
msgstr ""

#: ../../abi-spec.rst:172 9c4615ad7c084e16b23e900027e852c2
msgid "if ``Ti`` is static:"
msgstr ""

#: ../../abi-spec.rst:174 5aab19e8c1e34b79ae22f4ad89098932
msgid "``head(X(i)) = enc(X(i))`` and ``tail(X(i)) = \"\"`` (the empty string)"
msgstr ""

#: ../../abi-spec.rst:176 a384a2afe529476bb7b45d484ead673f
msgid "otherwise, i.e. if ``Ti`` is dynamic:"
msgstr ""

#: ../../abi-spec.rst:178 e7d6b2cf57db427ebcdb71d5c6ffa2ac
msgid ""
"``head(X(i)) = enc(len( head(X(1)) ... head(X(k)) tail(X(1)) ... "
"tail(X(i-1)) ))`` ``tail(X(i)) = enc(X(i))``"
msgstr ""

#: ../../abi-spec.rst:181 48ce75e119b64eb5bfa37da19c8c1921
msgid ""
"Note that in the dynamic case, ``head(X(i))`` is well-defined since the "
"lengths of the head parts only depend on the types and not the values. "
"The value of ``head(X(i))`` is the offset of the beginning of "
"``tail(X(i))`` relative to the start of ``enc(X)``."
msgstr ""

#: ../../abi-spec.rst:185 e51b27ddb26a43a989fe45b13afb281c
msgid "``T[k]`` for any ``T`` and ``k``:"
msgstr ""

#: ../../abi-spec.rst:187 be84f871483c4ed19ec105e002a28820
msgid "``enc(X) = enc((X[0], ..., X[k-1]))``"
msgstr ""

#: ../../abi-spec.rst:189 103dbdb8598f4daf87c51151fe7e550f
msgid ""
"i.e. it is encoded as if it were a tuple with ``k`` elements of the same "
"type."
msgstr ""

#: ../../abi-spec.rst:192 56d071161f6246a585140575d110f024
msgid ""
"``T[]`` where ``X`` has ``k`` elements (``k`` is assumed to be of type "
"``uint256``):"
msgstr ""

#: ../../abi-spec.rst:194 3a4cebacf8bd48559bfa6be12cbd9bea
msgid "``enc(X) = enc(k) enc([X[0], ..., X[k-1]])``"
msgstr ""

#: ../../abi-spec.rst:196 a71eddab90ef4de99658bd38d5c514a3
msgid ""
"i.e. it is encoded as if it were an array of static size ``k``, prefixed "
"with the number of elements."
msgstr ""

#: ../../abi-spec.rst:199 76d034b96578495d880d2720caee5789
msgid "``bytes``, of length ``k`` (which is assumed to be of type ``uint256``):"
msgstr ""

#: ../../abi-spec.rst:201 2a2854f0006747419c2ce8909b037d23
msgid ""
"``enc(X) = enc(k) pad_right(X)``, i.e. the number of bytes is encoded as "
"a ``uint256`` followed by the actual value of ``X`` as a byte sequence, "
"followed by the minimum number of zero-bytes such that ``len(enc(X))`` is"
" a multiple of 32."
msgstr ""

#: ../../abi-spec.rst:205 631ee330fb9a45bba1f3ead8b2307856
msgid "``string``:"
msgstr ""

#: ../../abi-spec.rst:207 9601094e1b334d8ca2a7a3c5a8a97eaf
msgid ""
"``enc(X) = enc(enc_utf8(X))``, i.e. ``X`` is UTF-8 encoded and this value"
" is interpreted as of ``bytes`` type and encoded further. Note that the "
"length used in this subsequent encoding is the number of bytes of the "
"UTF-8 encoded string, not its number of characters."
msgstr ""

#: ../../abi-spec.rst:211 aa995739d6ac4701b878caef36495039
msgid ""
"``uint<M>``: ``enc(X)`` is the big-endian encoding of ``X``, padded on "
"the higher-order (left) side with zero-bytes such that the length is 32 "
"bytes."
msgstr ""

#: ../../abi-spec.rst:213 b503f8a6256040f08a1d945930664b6b
msgid "``address``: as in the ``uint160`` case"
msgstr ""

#: ../../abi-spec.rst:214 74ceff7e6d9d4b5e8e3f1ec3a5eb2e53
msgid ""
"``int<M>``: ``enc(X)`` is the big-endian two's complement encoding of "
"``X``, padded on the higher-order (left) side with ``0xff`` bytes for "
"negative ``X`` and with zero-bytes for non-negative ``X`` such that the "
"length is 32 bytes."
msgstr ""

#: ../../abi-spec.rst:215 6dd6b6ae97de4ae0aec24a00b3a01973
msgid ""
"``bool``: as in the ``uint8`` case, where ``1`` is used for ``true`` and "
"``0`` for ``false``"
msgstr ""

#: ../../abi-spec.rst:216 d07df5b02433420aaf82e825149f3817
msgid ""
"``fixed<M>x<N>``: ``enc(X)`` is ``enc(X * 10**N)`` where ``X * 10**N`` is"
" interpreted as a ``int256``."
msgstr ""

#: ../../abi-spec.rst:217 77ad337cd14f4a4c856b0e529b29f304
msgid "``fixed``: as in the ``fixed128x18`` case"
msgstr ""

#: ../../abi-spec.rst:218 373811efcfbe4858bce3a218ed6f7c3a
msgid ""
"``ufixed<M>x<N>``: ``enc(X)`` is ``enc(X * 10**N)`` where ``X * 10**N`` "
"is interpreted as a ``uint256``."
msgstr ""

#: ../../abi-spec.rst:219 e7fb76e1dc4f4314b4c33dbd78a08249
msgid "``ufixed``: as in the ``ufixed128x18`` case"
msgstr ""

#: ../../abi-spec.rst:220 9b3b61cd67534d2e922215dcffb3670b
msgid ""
"``bytes<M>``: ``enc(X)`` is the sequence of bytes in ``X`` padded with "
"trailing zero-bytes to a length of 32 bytes."
msgstr ""

#: ../../abi-spec.rst:222 abb35211a46f4cb3be279effe38c73dc
msgid "Note that for any ``X``, ``len(enc(X))`` is a multiple of 32."
msgstr ""

#: ../../abi-spec.rst:225 27ac0bca3a8342f1a589393b66afb292
msgid "Function Selector and Argument Encoding"
msgstr ""

#: ../../abi-spec.rst:227 e1a85d38622a4b71a7f7d3894c3f34f7
msgid ""
"All in all, a call to the function ``f`` with parameters ``a_1, ..., "
"a_n`` is encoded as"
msgstr ""

#: ../../abi-spec.rst:229 4a5daf0f017744739a4e91fd0ae20678
msgid "``function_selector(f) enc((a_1, ..., a_n))``"
msgstr ""

#: ../../abi-spec.rst:231 ccbde3ea277e434787cd37d3511299ca
msgid "and the return values ``v_1, ..., v_k`` of ``f`` are encoded as"
msgstr ""

#: ../../abi-spec.rst:233 a467c816dae045319e7759a997c5c505
msgid "``enc((v_1, ..., v_k))``"
msgstr ""

#: ../../abi-spec.rst:235 422a59b795dc4780979271c0309981ee
msgid "i.e. the values are combined into a tuple and encoded."
msgstr ""

#: ../../abi-spec.rst:238 9e43e849a9c245b49ffec0e855eb4bec
msgid "Examples"
msgstr ""

#: ../../abi-spec.rst:240 06f9121851114ded9cd7fa5c7f928832
msgid "Given the contract:"
msgstr ""

#: ../../abi-spec.rst:255 7289a03c128b4263ace377d499582493
msgid ""
"Thus for our ``Foo`` example if we wanted to call ``baz`` with the "
"parameters ``69`` and ``true``, we would pass 68 bytes total, which can "
"be broken down into:"
msgstr ""

#: ../../abi-spec.rst:258 40ee17eeca7c4fbd864c119256ce132d
msgid ""
"``0xcdcd77c0``: the Method ID. This is derived as the first 4 bytes of "
"the Keccak hash of the ASCII form of the signature ``baz(uint32,bool)``."
msgstr ""

#: ../../abi-spec.rst:260 d311b40a35c74e6b97ba65d1c8b0463e
msgid ""
"``0x0000000000000000000000000000000000000000000000000000000000000045``: "
"the first parameter, a uint32 value ``69`` padded to 32 bytes"
msgstr ""

#: ../../abi-spec.rst:262 4cd0a695a2354d2da19bed2d8c232179
msgid ""
"``0x0000000000000000000000000000000000000000000000000000000000000001``: "
"the second parameter - boolean ``true``, padded to 32 bytes"
msgstr ""

#: ../../abi-spec.rst:265 ../../abi-spec.rst:282 ../../abi-spec.rst:302
#: 48a5750c90954d3d9465342ee816a7f3 70864eea24614a97b88a15b334fd5420
#: bf341d880783426c8a75a63b0a6a8994
msgid "In total:"
msgstr ""

#: ../../abi-spec.rst:271 ecb5898e79a741fa9a81653e5b839852
msgid ""
"It returns a single ``bool``. If, for example, it were to return "
"``false``, its output would be the single byte array "
"``0x0000000000000000000000000000000000000000000000000000000000000000``, a"
" single bool."
msgstr ""

#: ../../abi-spec.rst:274 50a22710d862497a8f7dbc4c8a905297
msgid ""
"If we wanted to call ``bar`` with the argument ``[\"abc\", \"def\"]``, we"
" would pass 68 bytes total, broken down into:"
msgstr ""

#: ../../abi-spec.rst:276 52ef482f2a5d433b936387589d3f129f
msgid ""
"``0xfce353f6``: the Method ID. This is derived from the signature "
"``bar(bytes3[2])``."
msgstr ""

#: ../../abi-spec.rst:277 45c5b1fb642e40678769085110117474
msgid ""
"``0x6162630000000000000000000000000000000000000000000000000000000000``: "
"the first part of the first parameter, a ``bytes3`` value ``\"abc\"`` "
"(left-aligned)."
msgstr ""

#: ../../abi-spec.rst:279 af68f660f53e4b9788efb2362e67728e
msgid ""
"``0x6465660000000000000000000000000000000000000000000000000000000000``: "
"the second part of the first parameter, a ``bytes3`` value ``\"def\"`` "
"(left-aligned)."
msgstr ""

#: ../../abi-spec.rst:288 1bbc859775e04b00b1ae1f3c5e8a36eb
msgid ""
"If we wanted to call ``sam`` with the arguments ``\"dave\"``, ``true`` "
"and ``[1,2,3]``, we would pass 292 bytes total, broken down into:"
msgstr ""

#: ../../abi-spec.rst:291 8be469bda1534e568a5be593eae292ce
msgid ""
"``0xa5643bf2``: the Method ID. This is derived from the signature "
"``sam(bytes,bool,uint256[])``. Note that ``uint`` is replaced with its "
"canonical representation ``uint256``."
msgstr ""

#: ../../abi-spec.rst:292 d47cfa103682435087ff34de427edaaf
msgid ""
"``0x0000000000000000000000000000000000000000000000000000000000000060``: "
"the location of the data part of the first parameter (dynamic type), "
"measured in bytes from the start of the arguments block. In this case, "
"``0x60``."
msgstr ""

#: ../../abi-spec.rst:293 1eb936e6cbe341819d88430ec377a84e
msgid ""
"``0x0000000000000000000000000000000000000000000000000000000000000001``: "
"the second parameter: boolean true."
msgstr ""

#: ../../abi-spec.rst:294 b910e87d9f8f4ddb913e881efd9ec3ec
msgid ""
"``0x00000000000000000000000000000000000000000000000000000000000000a0``: "
"the location of the data part of the third parameter (dynamic type), "
"measured in bytes. In this case, ``0xa0``."
msgstr ""

#: ../../abi-spec.rst:295 5ac7673bd59542f686c965eb64f04175
msgid ""
"``0x0000000000000000000000000000000000000000000000000000000000000004``: "
"the data part of the first argument, it starts with the length of the "
"byte array in elements, in this case, 4."
msgstr ""

#: ../../abi-spec.rst:296 8a7f044e01db4776b028e03a67833679
msgid ""
"``0x6461766500000000000000000000000000000000000000000000000000000000``: "
"the contents of the first argument: the UTF-8 (equal to ASCII in this "
"case) encoding of ``\"dave\"``, padded on the right to 32 bytes."
msgstr ""

#: ../../abi-spec.rst:297 24287de51d39401485ae52d969c8cecd
msgid ""
"``0x0000000000000000000000000000000000000000000000000000000000000003``: "
"the data part of the third argument, it starts with the length of the "
"array in elements, in this case, 3."
msgstr ""

#: ../../abi-spec.rst:298 8d55d106c567408fab7ab925dd8c7283
msgid ""
"``0x0000000000000000000000000000000000000000000000000000000000000001``: "
"the first entry of the third parameter."
msgstr ""

#: ../../abi-spec.rst:299 4a6519044da44824aabf87b9d593cfb4
msgid ""
"``0x0000000000000000000000000000000000000000000000000000000000000002``: "
"the second entry of the third parameter."
msgstr ""

#: ../../abi-spec.rst:300 c84fd46e63a94c5f9e8e72d66e6ce9b8
msgid ""
"``0x0000000000000000000000000000000000000000000000000000000000000003``: "
"the third entry of the third parameter."
msgstr ""

#: ../../abi-spec.rst:309 915609da88914e7283b63975348216f3
msgid "Use of Dynamic Types"
msgstr ""

#: ../../abi-spec.rst:311 6da8bec99caa48b8982b2acbdad14422
msgid ""
"A call to a function with the signature "
"``f(uint,uint32[],bytes10,bytes)`` with values ``(0x123, [0x456, 0x789], "
"\"1234567890\", \"Hello, world!\")`` is encoded in the following way:"
msgstr ""

#: ../../abi-spec.rst:314 3a80360eb63b4977a9c79b61031ff5e6
msgid ""
"We take the first four bytes of "
"``sha3(\"f(uint256,uint32[],bytes10,bytes)\")``, i.e. ``0x8be65246``. "
"Then we encode the head parts of all four arguments. For the static types"
" ``uint256`` and ``bytes10``, these are directly the values we want to "
"pass, whereas for the dynamic types ``uint32[]`` and ``bytes``, we use "
"the offset in bytes to the start of their data area, measured from the "
"start of the value encoding (i.e. not counting the first four bytes "
"containing the hash of the function signature). These are:"
msgstr ""

#: ../../abi-spec.rst:320 0e7ed82d9d664b6495229e3b8534c3dd
msgid ""
"``0x0000000000000000000000000000000000000000000000000000000000000123`` "
"(``0x123`` padded to 32 bytes)"
msgstr ""

#: ../../abi-spec.rst:321 f2b787894493438c9e92ca737199d003
msgid ""
"``0x0000000000000000000000000000000000000000000000000000000000000080`` "
"(offset to start of data part of second parameter, 4*32 bytes, exactly "
"the size of the head part)"
msgstr ""

#: ../../abi-spec.rst:322 484046580a90410a93fcb15746a51fce
msgid ""
"``0x3132333435363738393000000000000000000000000000000000000000000000`` "
"(``\"1234567890\"`` padded to 32 bytes on the right)"
msgstr ""

#: ../../abi-spec.rst:323 099e889ffb004318bf99debe02ebb6b6
msgid ""
"``0x00000000000000000000000000000000000000000000000000000000000000e0`` "
"(offset to start of data part of fourth parameter = offset to start of "
"data part of first dynamic parameter + size of data part of first dynamic"
" parameter = 4\\*32 + 3\\*32 (see below))"
msgstr ""

#: ../../abi-spec.rst:325 861486f0195a4f698cb8623f64392c5c
msgid ""
"After this, the data part of the first dynamic argument, ``[0x456, "
"0x789]`` follows:"
msgstr ""

#: ../../abi-spec.rst:327 7423a7c7e8d84c15959b7c23f0611e0c
msgid ""
"``0x0000000000000000000000000000000000000000000000000000000000000002`` "
"(number of elements of the array, 2)"
msgstr ""

#: ../../abi-spec.rst:328 05b0a60fe754400e8c9c61fc0974c510
msgid ""
"``0x0000000000000000000000000000000000000000000000000000000000000456`` "
"(first element)"
msgstr ""

#: ../../abi-spec.rst:329 6ddbb00cc602409699582c943bedabf3
msgid ""
"``0x0000000000000000000000000000000000000000000000000000000000000789`` "
"(second element)"
msgstr ""

#: ../../abi-spec.rst:331 d909c11aceed444db7365ce22bf1681a
msgid ""
"Finally, we encode the data part of the second dynamic argument, "
"``\"Hello, world!\"``:"
msgstr ""

#: ../../abi-spec.rst:333 bd60c356a4ee48b6aee11e1171633464
msgid ""
"``0x000000000000000000000000000000000000000000000000000000000000000d`` "
"(number of elements (bytes in this case): 13)"
msgstr ""

#: ../../abi-spec.rst:334 9f31e8678cfb4c1d905a24ee447aedb0
msgid ""
"``0x48656c6c6f2c20776f726c642100000000000000000000000000000000000000`` "
"(``\"Hello, world!\"`` padded to 32 bytes on the right)"
msgstr ""

#: ../../abi-spec.rst:336 c56c3e5672094a78b5978c73cd2b740e
msgid ""
"All together, the encoding is (newline after function selector and each "
"32-bytes for clarity):"
msgstr ""

#: ../../abi-spec.rst:351 15755f1f805d49788eccb5cbf5e8ac81
msgid ""
"Let us apply the same principle to encode the data for a function with a "
"signature ``g(uint[][],string[])`` with values ``([[1, 2], [3]], "
"[\"one\", \"two\", \"three\"])`` but start from the most atomic parts of "
"the encoding:"
msgstr ""

#: ../../abi-spec.rst:354 22f99734fc6b4eb0b144b228456b86ce
msgid ""
"First we encode the length and data of the first embedded dynamic array "
"``[1, 2]`` of the first root array ``[[1, 2], [3]]``:"
msgstr ""

#: ../../abi-spec.rst:356 a611db85976c44fd8b34c2d21e3f53f3
msgid ""
"``0x0000000000000000000000000000000000000000000000000000000000000002`` "
"(number of elements in the first array, 2; the elements themselves are "
"``1`` and ``2``)"
msgstr ""

#: ../../abi-spec.rst:357 3e8679dc75e34ef19bb487d28e714215
msgid ""
"``0x0000000000000000000000000000000000000000000000000000000000000001`` "
"(first element)"
msgstr ""

#: ../../abi-spec.rst:358 1fe7559e85c84eccad58a58b9a0ce3e3
msgid ""
"``0x0000000000000000000000000000000000000000000000000000000000000002`` "
"(second element)"
msgstr ""

#: ../../abi-spec.rst:360 928ef2b290fe4f81a2ff670dc0e80b57
msgid ""
"Then we encode the length and data of the second embedded dynamic array "
"``[3]`` of the first root array ``[[1, 2], [3]]``:"
msgstr ""

#: ../../abi-spec.rst:362 34498f3bb1fa4b9d9a66a44a6cb19dfb
msgid ""
"``0x0000000000000000000000000000000000000000000000000000000000000001`` "
"(number of elements in the second array, 1; the element is ``3``)"
msgstr ""

#: ../../abi-spec.rst:363 d7a1c2b9b5a046b3883401a4195eea6d
msgid ""
"``0x0000000000000000000000000000000000000000000000000000000000000003`` "
"(first element)"
msgstr ""

#: ../../abi-spec.rst:365 47b8f08608e648ea9586a7f0630c2c10
msgid ""
"Then we need to find the offsets ``a`` and ``b`` for their respective "
"dynamic arrays ``[1, 2]`` and ``[3]``. To calculate the offsets we can "
"take a look at the encoded data of the first root array ``[[1, 2], [3]]``"
" enumerating each line in the encoding:"
msgstr ""

#: ../../abi-spec.rst:379 d321d6a532e84b3181017d75d0ee46f9
msgid ""
"Offset ``a`` points to the start of the content of the array ``[1, 2]`` "
"which is line 2 (64 bytes); thus ``a = "
"0x0000000000000000000000000000000000000000000000000000000000000040``."
msgstr ""

#: ../../abi-spec.rst:382 c85406e3cb4b4d429f60094278fcff66
msgid ""
"Offset ``b`` points to the start of the content of the array ``[3]`` "
"which is line 5 (160 bytes); thus ``b = "
"0x00000000000000000000000000000000000000000000000000000000000000a0``."
msgstr ""

#: ../../abi-spec.rst:386 1c4e83af9f8e478e9ec7d77f7e0daafb
msgid "Then we encode the embedded strings of the second root array:"
msgstr ""

#: ../../abi-spec.rst:388 3b823b4e7c1f4214946072460b97ead5
msgid ""
"``0x0000000000000000000000000000000000000000000000000000000000000003`` "
"(number of characters in word ``\"one\"``)"
msgstr ""

#: ../../abi-spec.rst:389 ef6159d4ed25426bbbdbfb725d926cc9
msgid ""
"``0x6f6e650000000000000000000000000000000000000000000000000000000000`` "
"(utf8 representation of word ``\"one\"``)"
msgstr ""

#: ../../abi-spec.rst:390 0e17a7c125d24807a4233bb9525bd970
msgid ""
"``0x0000000000000000000000000000000000000000000000000000000000000003`` "
"(number of characters in word ``\"two\"``)"
msgstr ""

#: ../../abi-spec.rst:391 9a354391190f43819727b072b72abdd0
msgid ""
"``0x74776f0000000000000000000000000000000000000000000000000000000000`` "
"(utf8 representation of word ``\"two\"``)"
msgstr ""

#: ../../abi-spec.rst:392 1b94fb26281844e183ed4cfea5a69f41
msgid ""
"``0x0000000000000000000000000000000000000000000000000000000000000005`` "
"(number of characters in word ``\"three\"``)"
msgstr ""

#: ../../abi-spec.rst:393 36e87c1168074a3e87defb70de780e85
msgid ""
"``0x7468726565000000000000000000000000000000000000000000000000000000`` "
"(utf8 representation of word ``\"three\"``)"
msgstr ""

#: ../../abi-spec.rst:395 4d18c7b70c8949fba60a932e93c5f18f
msgid ""
"In parallel to the first root array, since strings are dynamic elements "
"we need to find their offsets ``c``, ``d`` and ``e``:"
msgstr ""

#: ../../abi-spec.rst:409 825a74eef4c24533a2828d75a4c76066
msgid ""
"Offset ``c`` points to the start of the content of the string ``\"one\"``"
" which is line 3 (96 bytes); thus ``c = "
"0x0000000000000000000000000000000000000000000000000000000000000060``."
msgstr ""

#: ../../abi-spec.rst:412 a68c8631a3cc4941aa964921d7e8069b
msgid ""
"Offset ``d`` points to the start of the content of the string ``\"two\"``"
" which is line 5 (160 bytes); thus ``d = "
"0x00000000000000000000000000000000000000000000000000000000000000a0``."
msgstr ""

#: ../../abi-spec.rst:415 bde2876eee8d45ceb86f0e39d4e4ac63
msgid ""
"Offset ``e`` points to the start of the content of the string "
"``\"three\"`` which is line 7 (224 bytes); thus ``e = "
"0x00000000000000000000000000000000000000000000000000000000000000e0``."
msgstr ""

#: ../../abi-spec.rst:419 e94b37f0e39d467a8d81d89d5c318172
msgid ""
"Note that the encodings of the embedded elements of the root arrays are "
"not dependent on each other and have the same encodings for a function "
"with a signature ``g(string[],uint[][])``."
msgstr ""

#: ../../abi-spec.rst:422 c3550f2431514522af4ba05a324a9259
msgid "Then we encode the length of the first root array:"
msgstr ""

#: ../../abi-spec.rst:424 2f03715afcd141289f0baf7b40ad260c
msgid ""
"``0x0000000000000000000000000000000000000000000000000000000000000002`` "
"(number of elements in the first root array, 2; the elements themselves "
"are ``[1, 2]``  and ``[3]``)"
msgstr ""

#: ../../abi-spec.rst:426 6effc036cf7547719450bb71da50beaa
msgid "Then we encode the length of the second root array:"
msgstr ""

#: ../../abi-spec.rst:428 fb90bb1e0d6c4ca3b76e4b0c0a3a5527
msgid ""
"``0x0000000000000000000000000000000000000000000000000000000000000003`` "
"(number of strings in the second root array, 3; the strings themselves "
"are ``\"one\"``, ``\"two\"`` and ``\"three\"``)"
msgstr ""

#: ../../abi-spec.rst:430 e188602f1fa74f18ad33b7ed21ab9374
msgid ""
"Finally we find the offsets ``f`` and ``g`` for their respective root "
"dynamic arrays ``[[1, 2], [3]]`` and ``[\"one\", \"two\", \"three\"]``, "
"and assemble parts in the correct order:"
msgstr ""

#: ../../abi-spec.rst:457 a0e1f2124d4143dab0028f68e34919d0
msgid ""
"Offset ``f`` points to the start of the content of the array ``[[1, 2], "
"[3]]`` which is line 2 (64 bytes); thus ``f = "
"0x0000000000000000000000000000000000000000000000000000000000000040``."
msgstr ""

#: ../../abi-spec.rst:460 811cb40706274c2a9a8b32a65851878a
msgid ""
"Offset ``g`` points to the start of the content of the array ``[\"one\", "
"\"two\", \"three\"]`` which is line 10 (320 bytes); thus ``g = "
"0x0000000000000000000000000000000000000000000000000000000000000140``."
msgstr ""

#: ../../abi-spec.rst:466 39df011d454f414e8c9c8f2015ede4e1
msgid "Events"
msgstr ""

#: ../../abi-spec.rst:468 e822330e3c94403ca2971c61ddccea77
msgid ""
"Events are an abstraction of the Ethereum logging/event-watching "
"protocol. Log entries provide the contract's address, a series of up to "
"four topics and some arbitrary length binary data. Events leverage the "
"existing function ABI in order to interpret this (together with an "
"interface spec) as a properly typed structure."
msgstr ""

#: ../../abi-spec.rst:472 4a700046e2f14076ab26409caabb978e
msgid ""
"Given an event name and series of event parameters, we split them into "
"two sub-series: those which are indexed and those which are not. Those "
"which are indexed, which may number up to 3 (for non-anonymous events) or"
" 4 (for anonymous ones), are used alongside the Keccak hash of the event "
"signature to form the topics of the log entry. Those which are not "
"indexed form the byte array of the event."
msgstr ""

#: ../../abi-spec.rst:478 faa368e8e3354fba825f515c4d014e6e
msgid "In effect, a log entry using this ABI is described as:"
msgstr ""

#: ../../abi-spec.rst:480 5e60f2c7561e4c6ca6a44848d6cbc9a4
msgid ""
"``address``: the address of the contract (intrinsically provided by "
"Ethereum);"
msgstr ""

#: ../../abi-spec.rst:481 534bec81b29a4511a0cff0590858d091
msgid ""
"``topics[0]``: "
"``keccak(EVENT_NAME+\"(\"+EVENT_ARGS.map(canonical_type_of).join(\",\")+\")\")``"
" (``canonical_type_of`` is a function that simply returns the canonical "
"type of a given argument, e.g. for ``uint indexed foo``, it would return "
"``uint256``). This value is only present in ``topics[0]`` if the event is"
" not declared as ``anonymous``;"
msgstr ""

#: ../../abi-spec.rst:484 12116dd77004462198514a78e3e4f203
msgid ""
"``topics[n]``: ``abi_encode(EVENT_INDEXED_ARGS[n - 1])`` if the event is "
"not declared as ``anonymous`` or ``abi_encode(EVENT_INDEXED_ARGS[n])`` if"
" it is (``EVENT_INDEXED_ARGS`` is the series of ``EVENT_ARGS`` that are "
"indexed);"
msgstr ""

#: ../../abi-spec.rst:487 dd0fcfec267849198c5c57ecdd82a4e9
msgid ""
"``data``: ABI encoding of ``EVENT_NON_INDEXED_ARGS`` "
"(``EVENT_NON_INDEXED_ARGS`` is the series of ``EVENT_ARGS`` that are not "
"indexed, ``abi_encode`` is the ABI encoding function used for returning a"
" series of typed values from a function, as described above)."
msgstr ""

#: ../../abi-spec.rst:491 f862338270dc41e8b77a0cf202abbd8c
msgid ""
"For all types of length at most 32 bytes, the ``EVENT_INDEXED_ARGS`` "
"array contains the value directly, padded or sign-extended (for signed "
"integers) to 32 bytes, just as for regular ABI encoding. However, for all"
" \"complex\" types or types of dynamic length, including all arrays, "
"``string``, ``bytes`` and structs, ``EVENT_INDEXED_ARGS`` will contain "
"the *Keccak hash* of a special in-place encoded value (see "
":ref:`indexed_event_encoding`), rather than the encoded value directly. "
"This allows applications to efficiently query for values of dynamic-"
"length types (by setting the hash of the encoded value as the topic), but"
" leaves applications unable to decode indexed values they have not "
"queried for. For dynamic-length types, application developers face a "
"trade-off between fast search for predetermined values (if the argument "
"is indexed) and legibility of arbitrary values (which requires that the "
"arguments not be indexed). Developers may overcome this tradeoff and "
"achieve both efficient search and arbitrary legibility by defining events"
" with two arguments — one indexed, one not — intended to hold the same "
"value."
msgstr ""

#: ../../abi-spec.rst:508 b064b17dfb9e42eba10f17a621b37727
msgid "Errors"
msgstr ""

#: ../../abi-spec.rst:510 7a565bf183cd4c9386d312e187caa16a
msgid ""
"In case of a failure inside a contract, the contract can use a special "
"opcode to abort execution and revert all state changes. In addition to "
"these effects, descriptive data can be returned to the caller. This "
"descriptive data is the encoding of an error and its arguments in the "
"same way as data for a function call."
msgstr ""

#: ../../abi-spec.rst:515 4fca48612f2847febfe3b54f5f996a9a
msgid ""
"As an example, let us consider the following contract whose ``transfer`` "
"function always reverts with a custom error of \"insufficient balance\":"
msgstr ""

#: ../../abi-spec.rst:530 d1312d43e1d6403682adf0ec8d40d083
msgid ""
"The return data would be encoded in the same way as the function call "
"``InsufficientBalance(0, amount)`` to the function "
"``InsufficientBalance(uint256,uint256)``, i.e. ``0xcf479181``, "
"``uint256(0)``, ``uint256(amount)``."
msgstr ""

#: ../../abi-spec.rst:534 743208cbbe1d45a29c3c2c56a10e28c4
msgid ""
"The error selectors ``0x00000000`` and ``0xffffffff`` are reserved for "
"future use."
msgstr ""

#: ../../abi-spec.rst:537 b46495dd91024d79887d973a9eca2bf5
msgid ""
"Never trust error data. The error data by default bubbles up through the "
"chain of external calls, which means that a contract may receive an error"
" not defined in any of the contracts it calls directly. Furthermore, any "
"contract can fake any error by returning data that matches an error "
"signature, even if the error is not defined anywhere."
msgstr ""

#: ../../abi-spec.rst:547 6a087d976ed04299a35ef866ca292d37
msgid "JSON"
msgstr ""

#: ../../abi-spec.rst:549 402f112b474b424ebbac369becb18d78
msgid ""
"The JSON format for a contract's interface is given by an array of "
"function, event and error descriptions. A function description is a JSON "
"object with the fields:"
msgstr ""

#: ../../abi-spec.rst:552 908ebb6df33c4229ad70a292cf751d66
msgid ""
"``type``: ``\"function\"``, ``\"constructor\"``, ``\"receive\"`` (the "
":ref:`\"receive Ether\" function <receive-ether-function>`) or "
"``\"fallback\"`` (the :ref:`\"default\" function <fallback-function>`);"
msgstr ""

#: ../../abi-spec.rst:553 6a8ce558b9994f3bb90e188080c8b149
msgid "``name``: the name of the function;"
msgstr ""

#: ../../abi-spec.rst:554 ../../abi-spec.rst:578 ../../abi-spec.rst:591
#: 1276614905ef48dd95ec79084e3e8593 a7381e931dbf4c3db24a33ac6301d6ab
#: a74b01417af84fdba085222fe0f3fced
msgid "``inputs``: an array of objects, each of which contains:"
msgstr ""

#: ../../abi-spec.rst:556 ../../abi-spec.rst:580 ../../abi-spec.rst:593
#: 5f3eeb261f784949b8935932ba913b00 b7fc7bb6558f4e9583336fe96e8f45d6
#: be3b31e388ad4842bdb0939a0a0a15ac
msgid "``name``: the name of the parameter."
msgstr ""

#: ../../abi-spec.rst:557 ../../abi-spec.rst:581 ../../abi-spec.rst:594
#: ab201d0b27b1444bae94f6ae3f0eeabd bb35f62799f943348a53791e882b54f1
#: c4aad24ce34a491993b5d7de9beeba8a
msgid "``type``: the canonical type of the parameter (more below)."
msgstr ""

#: ../../abi-spec.rst:558 ../../abi-spec.rst:582 ../../abi-spec.rst:595
#: 53e77dab3f554ff6885217bbef1c9d26 68ad15ba927641fe9103a86e0e29014b
#: 9128e8cea64e40c291ad01d1c29e347a
msgid "``components``: used for tuple types (more below)."
msgstr ""

#: ../../abi-spec.rst:560 8de14f9ce5614e15b80b50f27adba50b
msgid "``outputs``: an array of objects similar to ``inputs``."
msgstr ""

#: ../../abi-spec.rst:561 57d910d4d4e94a70bde8b8f8ac51cb05
msgid ""
"``stateMutability``: a string with one of the following values: ``pure`` "
"(:ref:`specified to not read blockchain state <pure-functions>`), "
"``view`` (:ref:`specified to not modify the blockchain state <view-"
"functions>`), ``nonpayable`` (function does not accept Ether - the "
"default) and ``payable`` (function accepts Ether)."
msgstr ""

#: ../../abi-spec.rst:565 bc40d4648718459385121e971dfac92c
msgid ""
"Constructor and fallback function never have ``name`` or ``outputs``. "
"Fallback function doesn't have ``inputs`` either."
msgstr ""

#: ../../abi-spec.rst:568 0f4f5e9e6f454f468f8034463e5e0772
msgid ""
"Sending non-zero Ether to non-payable function will revert the "
"transaction."
msgstr ""

#: ../../abi-spec.rst:571 ed9614c558ff47ca8b7d3026df48603d
msgid ""
"The state mutability ``nonpayable`` is reflected in Solidity by not "
"specifying a state mutability modifier at all."
msgstr ""

#: ../../abi-spec.rst:574 da00ca433c3444c4828065b77b44ee19
msgid "An event description is a JSON object with fairly similar fields:"
msgstr ""

#: ../../abi-spec.rst:576 40437778b0da47059f4419a5badf18a9
msgid "``type``: always ``\"event\"``"
msgstr ""

#: ../../abi-spec.rst:577 025f8f41eb3b47b885c13d79a9e4c82f
msgid "``name``: the name of the event."
msgstr ""

#: ../../abi-spec.rst:583 46a65e018164428885a6d1d80e8a78ac
msgid ""
"``indexed``: ``true`` if the field is part of the log's topics, ``false``"
" if it one of the log's data segment."
msgstr ""

#: ../../abi-spec.rst:585 d66fb9cb9ce44b1db3a5b0683ac39243
msgid "``anonymous``: ``true`` if the event was declared as ``anonymous``."
msgstr ""

#: ../../abi-spec.rst:587 e8043e02e4ad46eb8c5d2d493797202a
msgid "Errors look as follows:"
msgstr ""

#: ../../abi-spec.rst:589 f08fa3b9cb6c4cb9bb76249f5ff00282
msgid "``type``: always ``\"error\"``"
msgstr ""

#: ../../abi-spec.rst:590 6b3c11474b954d6d8edf3a26c24ed605
msgid "``name``: the name of the error."
msgstr ""

#: ../../abi-spec.rst:598 577ab878caee458a8d537a42ae92ae36
msgid ""
"There can be multiple errors with the same name and even with identical "
"signature in the JSON array, for example if the errors originate from "
"different files in the smart contract or are referenced from another "
"smart contract. For the ABI, only the name of the error itself is "
"relevant and not where it is defined."
msgstr ""

#: ../../abi-spec.rst:605 c3239ccfa5e44b9ca0e920569ab8e62e
msgid "For example,"
msgstr ""

#: ../../abi-spec.rst:622 ../../abi-spec.rst:674
#: 456d6b37089e421d95673a760879cebb 5213dfcd3c8a4d38b0fb5189c1c32d36
msgid "would result in the JSON:"
msgstr ""

#: ../../abi-spec.rst:646 5084c0449612494e92d97f941c4e5009
msgid "Handling tuple types"
msgstr ""

#: ../../abi-spec.rst:648 35a78ca2998a4963967e7d9469304c94
msgid ""
"Despite that names are intentionally not part of the ABI encoding they do"
" make a lot of sense to be included in the JSON to enable displaying it "
"to the end user. The structure is nested in the following way:"
msgstr ""

#: ../../abi-spec.rst:651 0d37eb457dd64b4d919732d05dcb5d6c
msgid ""
"An object with members ``name``, ``type`` and potentially ``components`` "
"describes a typed variable. The canonical type is determined until a "
"tuple type is reached and the string description up to that point is "
"stored in ``type`` prefix with the word ``tuple``, i.e. it will be "
"``tuple`` followed by a sequence of ``[]`` and ``[k]`` with integers "
"``k``. The components of the tuple are then stored in the member "
"``components``, which is of array type and has the same structure as the "
"top-level object except that ``indexed`` is not allowed there."
msgstr ""

#: ../../abi-spec.rst:659 e78232a8dd5f419eb113c6a35d7f01e8
msgid "As an example, the code"
msgstr ""

#: ../../abi-spec.rst:737 d78e096eb84547f7a95c4b466243b581
msgid "Strict Encoding Mode"
msgstr ""

#: ../../abi-spec.rst:739 136167d0dbee4677aa77d5f12d1f74e9
msgid ""
"Strict encoding mode is the mode that leads to exactly the same encoding "
"as defined in the formal specification above. This means offsets have to "
"be as small as possible while still not creating overlaps in the data "
"areas and thus no gaps are allowed."
msgstr ""

#: ../../abi-spec.rst:743 86bc754b7dd9454795ab44fdd16546da
msgid ""
"Usually, ABI decoders are written in a straightforward way just following"
" offset pointers, but some decoders might enforce strict mode. The "
"Solidity ABI decoder currently does not enforce strict mode, but the "
"encoder always creates data in strict mode."
msgstr ""

#: ../../abi-spec.rst:748 3f4392a3d8fb4c898d7bc68eba63c7c6
msgid "Non-standard Packed Mode"
msgstr ""

#: ../../abi-spec.rst:750 3de23be983894baf8fc987858e92a288
msgid ""
"Through ``abi.encodePacked()``, Solidity supports a non-standard packed "
"mode where:"
msgstr ""

#: ../../abi-spec.rst:752 09674b3115c04ac3a3a292265f3b1236
msgid ""
"types shorter than 32 bytes are concatenated directly, without padding or"
" sign extension"
msgstr ""

#: ../../abi-spec.rst:753 e1acf02aac27498eb1f380febe79d664
msgid "dynamic types are encoded in-place and without the length."
msgstr ""

#: ../../abi-spec.rst:754 0545caab6da746d0a9bf66a8dd8159a5
msgid "array elements are padded, but still encoded in-place"
msgstr ""

#: ../../abi-spec.rst:756 7cbef50aa7014772b098f5f72ce79f4a
msgid "Furthermore, structs as well as nested arrays are not supported."
msgstr ""

#: ../../abi-spec.rst:758 3b548a08ad2f42e583f6f2948c0c359c
msgid ""
"As an example, the encoding of ``int16(-1), bytes1(0x42), uint16(0x03), "
"string(\"Hello, world!\")`` results in:"
msgstr ""

#: ../../abi-spec.rst:768 97487b3bc6e34d6e9fddf49bf5a3d68f
msgid "More specifically:"
msgstr ""

#: ../../abi-spec.rst:770 27ea91fd64714b768c4799347803da09
msgid ""
"During the encoding, everything is encoded in-place. This means that "
"there is no distinction between head and tail, as in the ABI encoding, "
"and the length of an array is not encoded."
msgstr ""

#: ../../abi-spec.rst:773 62043fe79fc14d49a02ef5826437cae5
msgid ""
"The direct arguments of ``abi.encodePacked`` are encoded without padding,"
" as long as they are not arrays (or ``string`` or ``bytes``)."
msgstr ""

#: ../../abi-spec.rst:775 813ed571d2ee4c47bd6b353c11e3561f
msgid ""
"The encoding of an array is the concatenation of the encoding of its "
"elements **with** padding."
msgstr ""

#: ../../abi-spec.rst:777 acda5c35d21b471390c24838795a7364
msgid ""
"Dynamically-sized types like ``string``, ``bytes`` or ``uint[]`` are "
"encoded without their length field."
msgstr ""

#: ../../abi-spec.rst:779 cb5a672d39994f288fe303de6663e2d3
msgid ""
"The encoding of ``string`` or ``bytes`` does not apply padding at the end"
" unless it is part of an array or struct (then it is padded to a multiple"
" of 32 bytes)."
msgstr ""

#: ../../abi-spec.rst:783 cff61b1dfc434c19be1d6fcb59ffa3d1
msgid ""
"In general, the encoding is ambiguous as soon as there are two "
"dynamically-sized elements, because of the missing length field."
msgstr ""

#: ../../abi-spec.rst:786 46ba496ffe5b4a6ea12bbe4267cfdc1d
msgid ""
"If padding is needed, explicit type conversions can be used: "
"``abi.encodePacked(uint16(0x12)) == hex\"0012\"``."
msgstr ""

#: ../../abi-spec.rst:788 2ffec10b26294d7284b76df8194aab8c
msgid ""
"Since packed encoding is not used when calling functions, there is no "
"special support for prepending a function selector. Since the encoding is"
" ambiguous, there is no decoding function."
msgstr ""

#: ../../abi-spec.rst:793 1b77aa14985c4c75995d8c2365735460
msgid ""
"If you use ``keccak256(abi.encodePacked(a, b))`` and both ``a`` and ``b``"
" are dynamic types, it is easy to craft collisions in the hash value by "
"moving parts of ``a`` into ``b`` and vice-versa. More specifically, "
"``abi.encodePacked(\"a\", \"bc\") == abi.encodePacked(\"ab\", \"c\")``. "
"If you use ``abi.encodePacked`` for signatures, authentication or data "
"integrity, make sure to always use the same types and check that at most "
"one of them is dynamic. Unless there is a compelling reason, "
"``abi.encode`` should be preferred."
msgstr ""

#: ../../abi-spec.rst:804 7b72f25955d946f58926b6350d7f8ea5
msgid "Encoding of Indexed Event Parameters"
msgstr ""

#: ../../abi-spec.rst:806 1484cef9065e4e3294a4972f47e7bf2d
msgid ""
"Indexed event parameters that are not value types, i.e. arrays and "
"structs are not stored directly but instead a keccak256-hash of an "
"encoding is stored. This encoding is defined as follows:"
msgstr ""

#: ../../abi-spec.rst:810 54a5a323324f41b39ee82bfdfa5332cc
msgid ""
"the encoding of a ``bytes`` and ``string`` value is just the string "
"contents without any padding or length prefix."
msgstr ""

#: ../../abi-spec.rst:812 fa2c468ec540498fb68afeec543ca217
msgid ""
"the encoding of a struct is the concatenation of the encoding of its "
"members, always padded to a multiple of 32 bytes (even ``bytes`` and "
"``string``)."
msgstr ""

#: ../../abi-spec.rst:814 40083b10e5964bbb83ce6c141fdef0f9
msgid ""
"the encoding of an array (both dynamically- and statically-sized) is the "
"concatenation of the encoding of its elements, always padded to a "
"multiple of 32 bytes (even ``bytes`` and ``string``) and without any "
"length prefix"
msgstr ""

#: ../../abi-spec.rst:818 a9f50cf773e94f038910e4ccaffc2492
msgid ""
"In the above, as usual, a negative number is padded by sign extension and"
" not zero padded. ``bytesNN`` types are padded on the right while "
"``uintNN`` / ``intNN`` are padded on the left."
msgstr ""

#: ../../abi-spec.rst:823 929baa60edee4b16bb96b459b0d566fb
msgid ""
"The encoding of a struct is ambiguous if it contains more than one "
"dynamically-sized array. Because of that, always re-check the event data "
"and do not rely on the search result based on the indexed parameters "
"alone."
msgstr ""

