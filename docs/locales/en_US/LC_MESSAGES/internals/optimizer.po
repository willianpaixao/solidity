# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2016-2021, Ethereum
# This file is distributed under the same license as the Solidity package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Solidity 0.8.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-01-13 16:47+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../internals/optimizer.rst:6 0f6ccac2a1a045fe987dc901da25194c
msgid "The Optimizer"
msgstr ""

#: ../../internals/optimizer.rst:8 2bef3ac4d48c40e8bfedef4f16c19116
msgid ""
"The Solidity compiler uses two different optimizer modules: The \"old\" "
"optimizer that operates at the opcode level and the \"new\" optimizer "
"that operates on Yul IR code."
msgstr ""

#: ../../internals/optimizer.rst:11 1da3e0e0f21a4c6a8da74fdbeabd2059
msgid ""
"The opcode-based optimizer applies a set of `simplification rules "
"<https://github.com/ethereum/solidity/blob/develop/libevmasm/RuleList.h>`_"
" to opcodes. It also combines equal code sets and removes unused code."
msgstr ""

#: ../../internals/optimizer.rst:14 0194d1b4a0424cf9ba9fae49e61d899d
msgid ""
"The Yul-based optimizer is much more powerful, because it can work across"
" function calls. For example, arbitrary jumps are not possible in Yul, so"
" it is possible to compute the side-effects of each function. Consider "
"two function calls, where the first does not modify storage and the "
"second does modify storage. If their arguments and return values do not "
"depend on each other, we can reorder the function calls. Similarly, if a "
"function is side-effect free and its result is multiplied by zero, you "
"can remove the function call completely."
msgstr ""

#: ../../internals/optimizer.rst:23 6ba8527fb02e4b1fb3d96917c03a142b
msgid ""
"Currently, the parameter ``--optimize`` activates the opcode-based "
"optimizer for the generated bytecode and the Yul optimizer for the Yul "
"code generated internally, for example for ABI coder v2. One can use "
"``solc --ir-optimized --optimize`` to produce an optimized experimental "
"Yul IR for a Solidity source. Similarly, one can use ``solc --strict-"
"assembly --optimize`` for a stand-alone Yul mode."
msgstr ""

#: ../../internals/optimizer.rst:29 8dbbf799879346c981e7203b314b55ee
msgid ""
"You can find more details on both optimizer modules and their "
"optimization steps below."
msgstr ""

#: ../../internals/optimizer.rst:32 ce5b9fdfa48b48c4a4a9210276a31701
msgid "Benefits of Optimizing Solidity Code"
msgstr ""

#: ../../internals/optimizer.rst:34 83f3c5b59a3e4453a48803f73d8a88e8
msgid ""
"Overall, the optimizer tries to simplify complicated expressions, which "
"reduces both code size and execution cost, i.e., it can reduce gas needed"
" for contract deployment as well as for external calls made to the "
"contract. It also specializes or inlines functions. Especially function "
"inlining is an operation that can cause much bigger code, but it is often"
" done because it results in opportunities for more simplifications."
msgstr ""

#: ../../internals/optimizer.rst:42 d12240e697cd4fe6a3755dbb08fffbd2
msgid "Differences between Optimized and Non-Optimized Code"
msgstr ""

#: ../../internals/optimizer.rst:44 663b99e27cf04625b2c4ef97e05a8ac4
msgid ""
"Generally, the most visible difference is that constant expressions are "
"evaluated at compile time. When it comes to the ASM output, one can also "
"notice a reduction of equivalent or duplicate code blocks (compare the "
"output of the flags ``--asm`` and ``--asm --optimize``). However, when it"
" comes to the Yul/intermediate-representation, there can be significant "
"differences, for example, functions may be inlined, combined, or "
"rewritten to eliminate redundancies, etc. (compare the output between the"
" flags ``--ir`` and ``--optimize --ir-optimized``)."
msgstr ""

#: ../../internals/optimizer.rst:55 3060ae9831be4d659faa176317b895a2
msgid "Optimizer Parameter Runs"
msgstr ""

#: ../../internals/optimizer.rst:57 54d7234c9b27457abeaeda1eac25194d
msgid ""
"The number of runs (``--optimize-runs``) specifies roughly how often each"
" opcode of the deployed code will be executed across the life-time of the"
" contract. This means it is a trade-off parameter between code size "
"(deploy cost) and code execution cost (cost after deployment). A \"runs\""
" parameter of \"1\" will produce short but expensive code. In contrast, a"
" larger \"runs\" parameter will produce longer but more gas efficient "
"code. The maximum value of the parameter is ``2**32-1``."
msgstr ""

#: ../../internals/optimizer.rst:66 0c7a9cc161f6485da4a1a8e790fb5962
msgid ""
"A common misconception is that this parameter specifies the number of "
"iterations of the optimizer. This is not true: The optimizer will always "
"run as many times as it can still improve the code."
msgstr ""

#: ../../internals/optimizer.rst:70 09d9d7994a3e4251b6fa7a5a6944445c
msgid "Opcode-Based Optimizer Module"
msgstr ""

#: ../../internals/optimizer.rst:72 4663f20169aa45b2985af915b6b36ad6
msgid ""
"The opcode-based optimizer module operates on assembly code. It splits "
"the sequence of instructions into basic blocks at ``JUMPs`` and "
"``JUMPDESTs``. Inside these blocks, the optimizer analyzes the "
"instructions and records every modification to the stack, memory, or "
"storage as an expression which consists of an instruction and a list of "
"arguments which are pointers to other expressions."
msgstr ""

#: ../../internals/optimizer.rst:78 1f8eb50de9fc40bc984f52d89adc7796
msgid ""
"Additionally, the opcode-based optimizer uses a component called "
"\"CommonSubexpressionEliminator\" that, amongst other tasks, finds "
"expressions that are always equal (on every input) and combines them into"
" an expression class. It first tries to find each new expression in a "
"list of already known expressions. If no such matches are found, it "
"simplifies the expression according to rules like ``constant + constant ="
" sum_of_constants`` or ``X * 1 = X``. Since this is a recursive process, "
"we can also apply the latter rule if the second factor is a more complex "
"expression which we know always evaluates to one."
msgstr ""

#: ../../internals/optimizer.rst:88 f33c836914134f7b810dc66161298201
msgid ""
"Certain optimizer steps symbolically track the storage and memory "
"locations. For example, this information is used to compute Keccak-256 "
"hashes that can be evaluated during compile time. Consider the sequence:"
msgstr ""

#: ../../internals/optimizer.rst:102 af4f7ee4306344b8ad24df9f0bb44905
msgid "or the equivalent Yul"
msgstr ""

#: ../../internals/optimizer.rst:110 4252fb53a085411199506afd16123627
msgid ""
"In this case, the optimizer tracks the value at a memory location "
"``calldataload(0)`` and then realizes that the Keccak-256 hash can be "
"evaluated at compile time. This only works if there is no other "
"instruction that modifies memory between the ``mstore`` and "
"``keccak256``. So if there is an instruction that writes to memory (or "
"storage), then we need to erase the knowledge of the current memory (or "
"storage). There is, however, an exception to this erasing, when we can "
"easily see that the instruction doesn't write to a certain location."
msgstr ""

#: ../../internals/optimizer.rst:117 ee12d99109cd4932b8580489e18fdd84
msgid "For example,"
msgstr ""

#: ../../internals/optimizer.rst:130 4ec1b12527bb4e479f1584bfe62bead5
msgid ""
"Therefore, modifications to storage and memory locations, of say location"
" ``l``, must erase knowledge about storage or memory locations which may "
"be equal to ``l``. More specifically, for storage, the optimizer has to "
"erase all knowledge of symbolic locations, that may be equal to ``l`` and"
" for memory, the optimizer has to erase all knowledge of symbolic "
"locations that may not be at least 32 bytes away. If ``m`` denotes an "
"arbitrary location, then this decision on erasure is done by computing "
"the value ``sub(l, m)``. For storage, if this value evaluates to a "
"literal that is non-zero, then the knowledge about ``m`` will be kept. "
"For memory, if the value evaluates to a literal that is between ``32`` "
"and ``2**256 - 32``, then the knowledge about ``m`` will be kept. In all "
"other cases, the knowledge about ``m`` will be erased."
msgstr ""

#: ../../internals/optimizer.rst:140 ddb8ca5d2a3a4f229d592fbef64bbe97
msgid ""
"After this process, we know which expressions have to be on the stack at "
"the end, and have a list of modifications to memory and storage. This "
"information is stored together with the basic blocks and is used to link "
"them. Furthermore, knowledge about the stack, storage and memory "
"configuration is forwarded to the next block(s)."
msgstr ""

#: ../../internals/optimizer.rst:146 4aca67b0e3b3460186e6bd5623a45bc6
msgid ""
"If we know the targets of all ``JUMP`` and ``JUMPI`` instructions, we can"
" build a complete control flow graph of the program. If there is only one"
" target we do not know (this can happen as in principle, jump targets can"
" be computed from inputs), we have to erase all knowledge about the input"
" state of a block as it can be the target of the unknown ``JUMP``. If the"
" opcode-based optimizer module finds a ``JUMPI`` whose condition "
"evaluates to a constant, it transforms it to an unconditional jump."
msgstr ""

#: ../../internals/optimizer.rst:154 0d649ee309bb42309a564e1bd8325a80
msgid ""
"As the last step, the code in each block is re-generated. The optimizer "
"creates a dependency graph from the expressions on the stack at the end "
"of the block, and it drops every operation that is not part of this "
"graph. It generates code that applies the modifications to memory and "
"storage in the order they were made in the original code (dropping "
"modifications which were found not to be needed). Finally, it generates "
"all values that are required to be on the stack in the correct place."
msgstr ""

#: ../../internals/optimizer.rst:162 6e392b24029f4b8fb07e32e64240e5af
msgid ""
"These steps are applied to each basic block and the newly generated code "
"is used as replacement if it is smaller. If a basic block is split at a "
"``JUMPI`` and during the analysis, the condition evaluates to a constant,"
" the ``JUMPI`` is replaced based on the value of the constant. Thus code "
"like"
msgstr ""

#: ../../internals/optimizer.rst:176 bc0ea48f0e14490ab0e5097024b93659
msgid "simplifies to this:"
msgstr ""

#: ../../internals/optimizer.rst:184 12c276f2e5cb49cd92b04418911156ec
msgid "Simple Inlining"
msgstr ""

#: ../../internals/optimizer.rst:186 76b24a39ff914bb6aa7f9514995c942c
msgid ""
"Since Solidity version 0.8.2, there is another optimizer step that "
"replaces certain jumps to blocks containing \"simple\" instructions "
"ending with a \"jump\" by a copy of these instructions. This corresponds "
"to inlining of simple, small Solidity or Yul functions. In particular, "
"the sequence ``PUSHTAG(tag) JUMP`` may be replaced, whenever the ``JUMP``"
" is marked as jump \"into\" a function and behind ``tag`` there is a "
"basic block (as described above for the "
"\"CommonSubexpressionEliminator\") that ends in another ``JUMP`` which is"
" marked as a jump \"out of\" a function."
msgstr ""

#: ../../internals/optimizer.rst:194 6c45cde2b3874de5a93d5f7ec6501821
msgid ""
"In particular, consider the following prototypical example of assembly "
"generated for a call to an internal Solidity function:"
msgstr ""

#: ../../internals/optimizer.rst:209 85cc8d999cff4c0fa2f8dc32524d58e5
msgid ""
"As long as the body of the function is a continuous basic block, the "
"\"Inliner\" can replace ``tag_f jump`` by the block at ``tag_f`` "
"resulting in:"
msgstr ""

#: ../../internals/optimizer.rst:224 51fe8decf37445fb84712685857e751a
msgid ""
"Now ideally, the other optimizer steps described above will result in the"
" return tag push being moved towards the remaining jump resulting in:"
msgstr ""

#: ../../internals/optimizer.rst:239 dd53aa9f7aeb4ee79204684e49d85ec0
msgid ""
"In this situation the \"PeepholeOptimizer\" will remove the return jump. "
"Ideally, all of this can be done for all references to ``tag_f`` leaving "
"it unused, s.t. it can be removed, yielding:"
msgstr ""

#: ../../internals/optimizer.rst:247 bbb119aef08a44cf9e57903026b7d89a
msgid ""
"So the call to function ``f`` is inlined and the original definition of "
"``f`` can be removed."
msgstr ""

#: ../../internals/optimizer.rst:249 cceccfe59e954c5e99436b59d0b2cec9
msgid ""
"Inlining like this is attempted, whenever a heuristics suggests that "
"inlining is cheaper over the lifetime of a contract than not inlining. "
"This heuristics depends on the size of the function body, the number of "
"other references to its tag (approximating the number of calls to the "
"function) and the expected number of executions of the contract (the "
"global optimizer parameter \"runs\")."
msgstr ""

#: ../../internals/optimizer.rst:256 e9dc1e110fbd4dc798dc444189bc9868
msgid "Yul-Based Optimizer Module"
msgstr ""

#: ../../internals/optimizer.rst:258 8957dc75c38c450e89f11563f6ed5743
msgid ""
"The Yul-based optimizer consists of several stages and components that "
"all transform the AST in a semantically equivalent way. The goal is to "
"end up either with code that is shorter or at least only marginally "
"longer but will allow further optimization steps."
msgstr ""

#: ../../internals/optimizer.rst:265 1de3cec7dfc84f0b844e1d364656378d
msgid ""
"Since the optimizer is under heavy development, the information here "
"might be outdated. If you rely on a certain functionality, please reach "
"out to the team directly."
msgstr ""

#: ../../internals/optimizer.rst:268 ba773449c7b74ba1b4fec8eb353c2c45
msgid ""
"The optimizer currently follows a purely greedy strategy and does not do "
"any backtracking."
msgstr ""

#: ../../internals/optimizer.rst:271 e0219b8c8a724c5ea074eef159880994
msgid ""
"All components of the Yul-based optimizer module are explained below. The"
" following transformation steps are the main components:"
msgstr ""

#: ../../internals/optimizer.rst:274 9cfaf81f09714d519efcb5d02b6be03a
msgid "SSA Transform"
msgstr ""

#: ../../internals/optimizer.rst:275 5e122b9be311494890d3acfcac0e185d
msgid "Common Subexpression Eliminator"
msgstr ""

#: ../../internals/optimizer.rst:276 ../../internals/optimizer.rst:800
#: 7599fbfc66624eff8a6f7536b5d24ac2 b807e6ae3e764326b3ce09c1c45085e9
msgid "Expression Simplifier"
msgstr ""

#: ../../internals/optimizer.rst:277 b3dd7765f1e147b3976635b879fd7855
msgid "Redundant Assign Eliminator"
msgstr ""

#: ../../internals/optimizer.rst:278 97e56878fcbd4b45aec861f8753b2f04
msgid "Full Inliner"
msgstr ""

#: ../../internals/optimizer.rst:281 923d7750d4864fc5b872b79c30a69e76
msgid "Optimizer Steps"
msgstr ""

#: ../../internals/optimizer.rst:283 86a9074a00d945a6a10244d4ec0233c3
msgid ""
"This is a list of all steps the Yul-based optimizer sorted "
"alphabetically. You can find more information on the individual steps and"
" their sequence below."
msgstr ""

#: ../../internals/optimizer.rst:286 956e097e75b04ee09e0fcd0bd40a5b27
msgid ":ref:`block-flattener`."
msgstr ""

#: ../../internals/optimizer.rst:287 d52499ba5c9c466082ee5fe48949775b
msgid ":ref:`circular-reference-pruner`."
msgstr ""

#: ../../internals/optimizer.rst:288 628fb51a13384243898e8493e0dac0e9
msgid ":ref:`common-subexpression-eliminator`."
msgstr ""

#: ../../internals/optimizer.rst:289 c8d29f5cb5254db79792abb74b68a9d0
msgid ":ref:`conditional-simplifier`."
msgstr ""

#: ../../internals/optimizer.rst:290 9b2706d0b5554c01a966beee286691f5
msgid ":ref:`conditional-unsimplifier`."
msgstr ""

#: ../../internals/optimizer.rst:291 5417bbd11a65410ea77f79076e2e4cf2
msgid ":ref:`control-flow-simplifier`."
msgstr ""

#: ../../internals/optimizer.rst:292 b1e57b4438b049beb646a1777442cf47
msgid ":ref:`dead-code-eliminator`."
msgstr ""

#: ../../internals/optimizer.rst:293 a07afa19ad33413d967933b3b7f7c387
msgid ":ref:`equal-store-eliminator`."
msgstr ""

#: ../../internals/optimizer.rst:294 de4b9ab6a9064375b19f6e811c40562e
msgid ":ref:`equivalent-function-combiner`."
msgstr ""

#: ../../internals/optimizer.rst:295 e918bd52022445b49bf88adfd1b5721b
msgid ":ref:`expression-joiner`."
msgstr ""

#: ../../internals/optimizer.rst:296 080b5cd6082b4cc399076740fa7fb6d5
msgid ":ref:`expression-simplifier`."
msgstr ""

#: ../../internals/optimizer.rst:297 01f07f0a65754a1a9774c1d8c2cf461c
msgid ":ref:`expression-splitter`."
msgstr ""

#: ../../internals/optimizer.rst:298 80fcd625b33249e3b107c9c0331efef3
msgid ":ref:`for-loop-condition-into-body`."
msgstr ""

#: ../../internals/optimizer.rst:299 3a19ba5a78b140e1aa3bbedb0e3ab568
msgid ":ref:`for-loop-condition-out-of-body`."
msgstr ""

#: ../../internals/optimizer.rst:300 e2b95113bbb94290b803b389e6d8a83e
msgid ":ref:`for-loop-init-rewriter`."
msgstr ""

#: ../../internals/optimizer.rst:301 1deea5d0e44142208df23ba4ac1c8ad3
msgid ":ref:`expression-inliner`."
msgstr ""

#: ../../internals/optimizer.rst:302 4384fee804694cf584b09eb4af0d221c
msgid ":ref:`full-inliner`."
msgstr ""

#: ../../internals/optimizer.rst:303 194a76d338234933b48e0d5b9f2b777f
msgid ":ref:`function-grouper`."
msgstr ""

#: ../../internals/optimizer.rst:304 8659cb3fff524bbca2dfcac03ba1d139
msgid ":ref:`function-hoister`."
msgstr ""

#: ../../internals/optimizer.rst:305 a582cb2a7537467cb389d424b70e75d0
msgid ":ref:`function-specializer`."
msgstr ""

#: ../../internals/optimizer.rst:306 d5e98d8efde14e7f860cace88a51012a
msgid ":ref:`literal-rematerialiser`."
msgstr ""

#: ../../internals/optimizer.rst:307 7a6f4f5907e94e298a1b8d6686460b33
msgid ":ref:`load-resolver`."
msgstr ""

#: ../../internals/optimizer.rst:308 425b7f5f089c487abda71cd930e835c9
msgid ":ref:`loop-invariant-code-motion`."
msgstr ""

#: ../../internals/optimizer.rst:309 7c4eee45139c4552a359a456dfd54d70
msgid ":ref:`redundant-assign-eliminator`."
msgstr ""

#: ../../internals/optimizer.rst:310 a6e6ca8d6bdd43d89b79f42255b0421b
msgid ":ref:`reasoning-based-simplifier`."
msgstr ""

#: ../../internals/optimizer.rst:311 ef93723e09aa4ddfad17e8c93834f431
msgid ":ref:`rematerialiser`."
msgstr ""

#: ../../internals/optimizer.rst:312 79a7ef4c7c834d03a9299105eab96204
msgid ":ref:`SSA-reverser`."
msgstr ""

#: ../../internals/optimizer.rst:313 cc7d0dc8170a4947baffc4eb2b9eae9f
msgid ":ref:`SSA-transform`."
msgstr ""

#: ../../internals/optimizer.rst:314 f1af133f43b542bf89c85c86a73b12c3
msgid ":ref:`structural-simplifier`."
msgstr ""

#: ../../internals/optimizer.rst:315 3b5b04bffd93414292889889c224b73a
msgid ":ref:`unused-function-parameter-pruner`."
msgstr ""

#: ../../internals/optimizer.rst:316 290b8e988a9c45fbacc5ca698ce128ea
msgid ":ref:`unused-pruner`."
msgstr ""

#: ../../internals/optimizer.rst:317 dfdbf53eb94c4f938bda8057fc5227a0
msgid ":ref:`var-decl-initializer`."
msgstr ""

#: ../../internals/optimizer.rst:320 00ae06a45cca40c98b2b816072640041
msgid "Selecting Optimizations"
msgstr ""

#: ../../internals/optimizer.rst:322 e501fcdc47114980b7a0f1a5ab9b5790
msgid ""
"By default the optimizer applies its predefined sequence of optimization "
"steps to the generated assembly. You can override this sequence and "
"supply your own using the ``--yul-optimizations`` option:"
msgstr ""

#: ../../internals/optimizer.rst:330 823c4ea9560d4880a099d14c1eec3322
msgid ""
"The sequence inside ``[...]`` will be applied multiple times in a loop "
"until the Yul code remains unchanged or until the maximum number of "
"rounds (currently 12) has been reached."
msgstr ""

#: ../../internals/optimizer.rst:333 ce9f76315cec40428f18e36ae025aabd
msgid ""
"Available abbreviations are listed in the `Yul optimizer docs <yul.rst"
"#optimization-step-sequence>`_."
msgstr ""

#: ../../internals/optimizer.rst:336 5f4314beee804f528740a3f17a3e664d
msgid "Preprocessing"
msgstr ""

#: ../../internals/optimizer.rst:338 fac3724ae1614d969b628bc98d4fd243
msgid ""
"The preprocessing components perform transformations to get the program "
"into a certain normal form that is easier to work with. This normal form "
"is kept during the rest of the optimization process."
msgstr ""

#: ../../internals/optimizer.rst:345 964bba6eef644290ba857d25546e4559
msgid "Disambiguator"
msgstr ""

#: ../../internals/optimizer.rst:347 e145dd087e2b44e4af91606c1c0d827e
msgid ""
"The disambiguator takes an AST and returns a fresh copy where all "
"identifiers have unique names in the input AST. This is a prerequisite "
"for all other optimizer stages. One of the benefits is that identifier "
"lookup does not need to take scopes into account which simplifies the "
"analysis needed for other steps."
msgstr ""

#: ../../internals/optimizer.rst:352 70d40a00ecda41df9a8b15804b42b204
msgid ""
"All subsequent stages have the property that all names stay unique. This "
"means if a new identifier needs to be introduced, a new unique name is "
"generated."
msgstr ""

#: ../../internals/optimizer.rst:358 8f27032399a24aafaff7af5765eb75e3
msgid "FunctionHoister"
msgstr ""

#: ../../internals/optimizer.rst:360 19bf425912d1488bb5ec1eb8ad82f2cf
msgid ""
"The function hoister moves all function definitions to the end of the "
"topmost block. This is a semantically equivalent transformation as long "
"as it is performed after the disambiguation stage. The reason is that "
"moving a definition to a higher-level block cannot decrease its "
"visibility and it is impossible to reference variables defined in a "
"different function."
msgstr ""

#: ../../internals/optimizer.rst:365 a42a03ef37564a389685754bea481a71
msgid ""
"The benefit of this stage is that function definitions can be looked up "
"more easily and functions can be optimized in isolation without having to"
" traverse the AST completely."
msgstr ""

#: ../../internals/optimizer.rst:371 cbc6d391b2414eefa043625b8771a971
msgid "FunctionGrouper"
msgstr ""

#: ../../internals/optimizer.rst:373 87a233dbe083455fb2d4e7e0123081ac
msgid ""
"The function grouper has to be applied after the disambiguator and the "
"function hoister. Its effect is that all topmost elements that are not "
"function definitions are moved into a single block which is the first "
"statement of the root block."
msgstr ""

#: ../../internals/optimizer.rst:377 42c4fc24d42e41ef8c51747d538b4fb3
msgid "After this step, a program has the following normal form:"
msgstr ""

#: ../../internals/optimizer.rst:383 00a20c0a790a47d3bd3cf538f3ee20c6
msgid ""
"Where ``I`` is a (potentially empty) block that does not contain any "
"function definitions (not even recursively) and ``F`` is a list of "
"function definitions such that no function contains a function "
"definition."
msgstr ""

#: ../../internals/optimizer.rst:386 e6c5fc42b0f74755b140e10be8be2464
msgid ""
"The benefit of this stage is that we always know where the list of "
"function begins."
msgstr ""

#: ../../internals/optimizer.rst:391 d600e98b64ee4257a6b54fe7a0a68242
msgid "ForLoopConditionIntoBody"
msgstr ""

#: ../../internals/optimizer.rst:393 aea51931126d4120b2fdf1a8f7609609
msgid ""
"This transformation moves the loop-iteration condition of a for-loop into"
" loop body. We need this transformation because :ref:`expression-"
"splitter` will not apply to iteration condition expressions (the ``C`` in"
" the following example)."
msgstr ""

#: ../../internals/optimizer.rst:403 ../../internals/optimizer.rst:429
#: ../../internals/optimizer.rst:578 ../../internals/optimizer.rst:1011
#: 7d151076dc244bddb45b3fc8e10c60ca 9ab535bffb654d4eb1365e95b8983f27
#: b41035ab384042a3b091a9fb5144801b ec84a847b7bc49288f45bb9aa3034c54
msgid "is transformed to"
msgstr ""

#: ../../internals/optimizer.rst:412 22eb4cdeb5424f20b3e66ef142efc41f
msgid ""
"This transformation can also be useful when paired with "
"``LoopInvariantCodeMotion``, since invariants in the loop-invariant "
"conditions can then be taken outside the loop."
msgstr ""

#: ../../internals/optimizer.rst:418 c30b2d587137451bbb2b1f6f1d58ba3e
msgid "ForLoopInitRewriter"
msgstr ""

#: ../../internals/optimizer.rst:420 fc06c2ed0a21448897b493e22d5036e6
msgid ""
"This transformation moves the initialization part of a for-loop to before"
" the loop:"
msgstr ""

#: ../../internals/optimizer.rst:438 f92d2c2e522f4e3199b9f1ae39bf71af
msgid ""
"This eases the rest of the optimization process because we can ignore the"
" complicated scoping rules of the for loop initialisation block."
msgstr ""

#: ../../internals/optimizer.rst:444 07eb1f9f77a54f78b22259501bf738a4
msgid "VarDeclInitializer"
msgstr ""

#: ../../internals/optimizer.rst:445 60953906d7754092bdcf42729ada733d
msgid ""
"This step rewrites variable declarations so that all of them are "
"initialized. Declarations like ``let x, y`` are split into multiple "
"declaration statements."
msgstr ""

#: ../../internals/optimizer.rst:448 b5cc97e4594748b9a96b071365cc2ba7
msgid "Only supports initializing with the zero literal for now."
msgstr ""

#: ../../internals/optimizer.rst:451 ab52d0fca317491083c62ba4aa1c1877
msgid "Pseudo-SSA Transformation"
msgstr ""

#: ../../internals/optimizer.rst:453 0877f620a2c34cc780a553bde86ca4fb
msgid ""
"The purpose of this components is to get the program into a longer form, "
"so that other components can more easily work with it. The final "
"representation will be similar to a static-single-assignment (SSA) form, "
"with the difference that it does not make use of explicit \"phi\" "
"functions which combines the values from different branches of control "
"flow because such a feature does not exist in the Yul language. Instead, "
"when control flow merges, if a variable is re-assigned in one of the "
"branches, a new SSA variable is declared to hold its current value, so "
"that the following expressions still only need to reference SSA "
"variables."
msgstr ""

#: ../../internals/optimizer.rst:462 70b658f6f2594a92b4c94b2226f9e51f
msgid "An example transformation is the following:"
msgstr ""

#: ../../internals/optimizer.rst:477 5a60043edfde4b74a6a0242e243bb5a6
msgid ""
"When all the following transformation steps are applied, the program will"
" look as follows:"
msgstr ""

#: ../../internals/optimizer.rst:505 e6a12808356a4327a3da077f12ad482e
msgid ""
"Note that the only variable that is re-assigned in this snippet is ``b``."
" This re-assignment cannot be avoided because ``b`` has different values "
"depending on the control flow. All other variables never change their "
"value once they are defined. The advantage of this property is that "
"variables can be freely moved around and references to them can be "
"exchanged by their initial value (and vice-versa), as long as these "
"values are still valid in the new context."
msgstr ""

#: ../../internals/optimizer.rst:513 b859e5fc73eb4067895f47cd11f80fb3
msgid ""
"Of course, the code here is far from being optimized. To the contrary, it"
" is much longer. The hope is that this code will be easier to work with "
"and furthermore, there are optimizer steps that undo these changes and "
"make the code more compact again at the end."
msgstr ""

#: ../../internals/optimizer.rst:521 d9d07bd5ea7240d38263362c10f3e712
msgid "ExpressionSplitter"
msgstr ""

#: ../../internals/optimizer.rst:523 3f51a2a337c841c6a6e9079934ea9a3b
msgid ""
"The expression splitter turns expressions like ``add(mload(0x123), "
"mul(mload(0x456), 0x20))`` into a sequence of declarations of unique "
"variables that are assigned sub-expressions of that expression so that "
"each function call has only variables as arguments."
msgstr ""

#: ../../internals/optimizer.rst:528 73ecf978852d44ccbc4ff3a7deda5844
msgid "The above would be transformed into"
msgstr ""

#: ../../internals/optimizer.rst:542 281dd70c75564eab94ce687874379701
msgid ""
"Note that this transformation does not change the order of opcodes or "
"function calls."
msgstr ""

#: ../../internals/optimizer.rst:544 adcd22cd39bd41fc9714a9d17552fa0e
msgid ""
"It is not applied to loop iteration-condition, because the loop control "
"flow does not allow this \"outlining\" of the inner expressions in all "
"cases. We can sidestep this limitation by applying :ref:`for-loop-"
"condition-into-body` to move the iteration condition into loop body."
msgstr ""

#: ../../internals/optimizer.rst:548 9b100e86b70e461f99a6a6ddc21c1b92
msgid ""
"The final program should be in a form such that (with the exception of "
"loop conditions) function calls cannot appear nested inside expressions "
"and all function call arguments have to be variables."
msgstr ""

#: ../../internals/optimizer.rst:552 dbb498e616c6487eb77d36947433738f
msgid ""
"The benefits of this form are that it is much easier to re-order the "
"sequence of opcodes and it is also easier to perform function call "
"inlining. Furthermore, it is simpler to replace individual parts of "
"expressions or re-organize the \"expression tree\". The drawback is that "
"such code is much harder to read for humans."
msgstr ""

#: ../../internals/optimizer.rst:560 18add70fbe774e8094e7775e4baf8f5f
msgid "SSATransform"
msgstr ""

#: ../../internals/optimizer.rst:562 193d68e1bf10475cbb4321c382f026a6
msgid ""
"This stage tries to replace repeated assignments to existing variables by"
" declarations of new variables as much as possible. The reassignments are"
" still there, but all references to the reassigned variables are replaced"
" by the newly declared variables."
msgstr ""

#: ../../internals/optimizer.rst:568 9bec4d8dcf45401b912ceb255f0c486e
msgid "Example:"
msgstr ""

#: ../../internals/optimizer.rst:590 c5ae38071795411caf06c354212e735e
msgid "Exact semantics:"
msgstr ""

#: ../../internals/optimizer.rst:592 b8e0b554c2904e7ba6a555444830cdd8
msgid ""
"For any variable ``a`` that is assigned to somewhere in the code "
"(variables that are declared with value and never re-assigned are not "
"modified) perform the following transforms:"
msgstr ""

#: ../../internals/optimizer.rst:596 14ff9b2ee7414556941f16dac26065bc
msgid "replace ``let a := v`` by ``let a_i := v   let a := a_i``"
msgstr ""

#: ../../internals/optimizer.rst:597 2f6e7b82b0cb468e881b3ccad53a42b0
msgid ""
"replace ``a := v`` by ``let a_i := v   a := a_i`` where ``i`` is a number"
" such that ``a_i`` is yet unused."
msgstr ""

#: ../../internals/optimizer.rst:599 b7c033ae07e947ce91d73fb0310d44cb
msgid ""
"Furthermore, always record the current value of ``i`` used for ``a`` and "
"replace each reference to ``a`` by ``a_i``. The current value mapping is "
"cleared for a variable ``a`` at the end of each block in which it was "
"assigned to and at the end of the for loop init block if it is assigned "
"inside the for loop body or post block. If a variable's value is cleared "
"according to the rule above and the variable is declared outside the "
"block, a new SSA variable will be created at the location where control "
"flow joins, this includes the beginning of loop post/body block and the "
"location right after If/Switch/ForLoop/Block statement."
msgstr ""

#: ../../internals/optimizer.rst:609 2f51f92e90ab4e3389fd3922af1b205b
msgid ""
"After this stage, the Redundant Assign Eliminator is recommended to "
"remove the unnecessary intermediate assignments."
msgstr ""

#: ../../internals/optimizer.rst:612 7a12b28dbb8d4032a7faff7fb1778d46
msgid ""
"This stage provides best results if the Expression Splitter and the "
"Common Subexpression Eliminator are run right before it, because then it "
"does not generate excessive amounts of variables. On the other hand, the "
"Common Subexpression Eliminator could be more efficient if run after the "
"SSA transform."
msgstr ""

#: ../../internals/optimizer.rst:620 a4542b62eb294b3697f35106301d1180
msgid "RedundantAssignEliminator"
msgstr ""

#: ../../internals/optimizer.rst:622 aff6226c799d4a708d51a4d1043a19f5
msgid ""
"The SSA transform always generates an assignment of the form ``a := "
"a_i``, even though these might be unnecessary in many cases, like the "
"following example:"
msgstr ""

#: ../../internals/optimizer.rst:634 b8db6502aad34472b64325cfdd55a40a
msgid "The SSA transform converts this snippet to the following:"
msgstr ""

#: ../../internals/optimizer.rst:648 063f46277bb84ebaa904aa1ef6ce486e
msgid ""
"The Redundant Assign Eliminator removes all the three assignments to "
"``a``, because the value of ``a`` is not used and thus turn this snippet "
"into strict SSA form:"
msgstr ""

#: ../../internals/optimizer.rst:661 b084f0696786429a8595d44d208f6559
msgid ""
"Of course the intricate parts of determining whether an assignment is "
"redundant or not are connected to joining control flow."
msgstr ""

#: ../../internals/optimizer.rst:664 3ea7f529e33340fea26d1d89d7f87392
msgid "The component works as follows in detail:"
msgstr ""

#: ../../internals/optimizer.rst:666 bbb74fb8b4234c50994feb6de675f553
msgid ""
"The AST is traversed twice: in an information gathering step and in the "
"actual removal step. During information gathering, we maintain a mapping "
"from assignment statements to the three states \"unused\", \"undecided\" "
"and \"used\" which signifies whether the assigned value will be used "
"later by a reference to the variable."
msgstr ""

#: ../../internals/optimizer.rst:672 11a58a99568e4a679b5d6fbba52c3ece
msgid ""
"When an assignment is visited, it is added to the mapping in the "
"\"undecided\" state (see remark about for loops below) and every other "
"assignment to the same variable that is still in the \"undecided\" state "
"is changed to \"unused\". When a variable is referenced, the state of any"
" assignment to that variable still in the \"undecided\" state is changed "
"to \"used\"."
msgstr ""

#: ../../internals/optimizer.rst:678 004c5974bba24155a67596fcfe6bd0b3
msgid ""
"At points where control flow splits, a copy of the mapping is handed over"
" to each branch. At points where control flow joins, the two mappings "
"coming from the two branches are combined in the following way: "
"Statements that are only in one mapping or have the same state are used "
"unchanged. Conflicting values are resolved in the following way:"
msgstr ""

#: ../../internals/optimizer.rst:684 edfbf727bede4946ab4725fdb1a99a39
msgid "\"unused\", \"undecided\" -> \"undecided\""
msgstr ""

#: ../../internals/optimizer.rst:685 2f7167761a144b8aa1c320b65158e200
msgid "\"unused\", \"used\" -> \"used\""
msgstr ""

#: ../../internals/optimizer.rst:686 36f7550a145a442581dd545e71efb120
msgid "\"undecided, \"used\" -> \"used\""
msgstr ""

#: ../../internals/optimizer.rst:688 330c759eace0489098a5c6aa445434ba
msgid ""
"For for-loops, the condition, body and post-part are visited twice, "
"taking the joining control-flow at the condition into account. In other "
"words, we create three control flow paths: Zero runs of the loop, one run"
" and two runs and then combine them at the end."
msgstr ""

#: ../../internals/optimizer.rst:693 2c84575cf6a948a798a2363a7de1eb89
msgid ""
"Simulating a third run or even more is unnecessary, which can be seen as "
"follows:"
msgstr ""

#: ../../internals/optimizer.rst:695 92b11c8771124f50839c9feb39cae70d
msgid ""
"A state of an assignment at the beginning of the iteration will "
"deterministically result in a state of that assignment at the end of the "
"iteration. Let this state mapping function be called ``f``. The "
"combination of the three different states ``unused``, ``undecided`` and "
"``used`` as explained above is the ``max`` operation where ``unused = "
"0``, ``undecided = 1`` and ``used = 2``."
msgstr ""

#: ../../internals/optimizer.rst:701 b9d6cbd4edb34291bf1f77defeeb80a9
msgid "The proper way would be to compute"
msgstr ""

#: ../../internals/optimizer.rst:707 5ed9869a5c794fd28d9f3208c351e90b
msgid ""
"as state after the loop. Since ``f`` just has a range of three different "
"values, iterating it has to reach a cycle after at most three iterations,"
" and thus ``f(f(f(s)))`` has to equal one of ``s``, ``f(s)``, or "
"``f(f(s))`` and thus"
msgstr ""

#: ../../internals/optimizer.rst:716 f2dcb4dd820d4e73b548cbed4a76e49a
msgid ""
"In summary, running the loop at most twice is enough because there are "
"only three different states."
msgstr ""

#: ../../internals/optimizer.rst:719 1c19b8bc8b81488cab1ab64c209ce5da
msgid ""
"For switch statements that have a \"default\"-case, there is no control-"
"flow part that skips the switch."
msgstr ""

#: ../../internals/optimizer.rst:722 80c2ca2a0757470194958c41684bad97
msgid ""
"When a variable goes out of scope, all statements still in the "
"\"undecided\" state are changed to \"unused\", unless the variable is the"
" return parameter of a function - there, the state changes to \"used\"."
msgstr ""

#: ../../internals/optimizer.rst:726 4e11675a7456486da3919728b337d8d0
msgid ""
"In the second traversal, all assignments that are in the \"unused\" state"
" are removed."
msgstr ""

#: ../../internals/optimizer.rst:728 ac7393b2e6c3422b94769c849c9afe6b
msgid ""
"This step is usually run right after the SSA transform to complete the "
"generation of the pseudo-SSA."
msgstr ""

#: ../../internals/optimizer.rst:732 eeb21bebb345416d849ed01a889993ec
msgid "Tools"
msgstr ""

#: ../../internals/optimizer.rst:735 1f9471f6a20c47aeaea7b044325688ca
msgid "Movability"
msgstr ""

#: ../../internals/optimizer.rst:737 b0ed89a6642a4679988656a39c9e422c
msgid ""
"Movability is a property of an expression. It roughly means that the "
"expression is side-effect free and its evaluation only depends on the "
"values of variables and the call-constant state of the environment. Most "
"expressions are movable. The following parts make an expression non-"
"movable:"
msgstr ""

#: ../../internals/optimizer.rst:742 9efc7397c5314ad2b5d6f91d297e46eb
msgid ""
"function calls (might be relaxed in the future if all statements in the "
"function are movable)"
msgstr ""

#: ../../internals/optimizer.rst:743 86a669c81bca47d98844869e43187134
msgid "opcodes that (can) have side-effects (like ``call`` or ``selfdestruct``)"
msgstr ""

#: ../../internals/optimizer.rst:744 c40577ee3c1543f0b13faf602f9cf815
msgid "opcodes that read or write memory, storage or external state information"
msgstr ""

#: ../../internals/optimizer.rst:745 4ac2500907de48b0825391401a4838e3
msgid "opcodes that depend on the current PC, memory size or returndata size"
msgstr ""

#: ../../internals/optimizer.rst:748 f321f83515a743f8a33acfef501b4b52
msgid "DataflowAnalyzer"
msgstr ""

#: ../../internals/optimizer.rst:750 9ba4df2b9c0d4f50bec15d042e849902
msgid ""
"The Dataflow Analyzer is not an optimizer step itself but is used as a "
"tool by other components. While traversing the AST, it tracks the current"
" value of each variable, as long as that value is a movable expression. "
"It records the variables that are part of the expression that is "
"currently assigned to each other variable. Upon each assignment to a "
"variable ``a``, the current stored value of ``a`` is updated and all "
"stored values of all variables ``b`` are cleared whenever ``a`` is part "
"of the currently stored expression for ``b``."
msgstr ""

#: ../../internals/optimizer.rst:759 5405fc44be114e3481327434dc1532c0
msgid ""
"At control-flow joins, knowledge about variables is cleared if they have "
"or would be assigned in any of the control-flow paths. For instance, upon"
" entering a for loop, all variables are cleared that will be assigned "
"during the body or the post block."
msgstr ""

#: ../../internals/optimizer.rst:765 f1fe355b0a2a44a282ad113a763b6fe2
msgid "Expression-Scale Simplifications"
msgstr ""

#: ../../internals/optimizer.rst:767 f5dc963a0730426ea45894da6925d6a7
msgid ""
"These simplification passes change expressions and replace them by "
"equivalent and hopefully simpler expressions."
msgstr ""

#: ../../internals/optimizer.rst:773 f2e0b367fab34e59a28af3d4293400d7
msgid "CommonSubexpressionEliminator"
msgstr ""

#: ../../internals/optimizer.rst:775 a717362e010745c1a175fda5a7979b4d
msgid ""
"This step uses the Dataflow Analyzer and replaces subexpressions that "
"syntactically match the current value of a variable by a reference to "
"that variable. This is an equivalence transform because such "
"subexpressions have to be movable."
msgstr ""

#: ../../internals/optimizer.rst:780 7d6b781dd3cd4e1c8a30b18ff743aeca
msgid ""
"All subexpressions that are identifiers themselves are replaced by their "
"current value if the value is an identifier."
msgstr ""

#: ../../internals/optimizer.rst:783 b87f64828e704e1c87ae25534dfad856
msgid ""
"The combination of the two rules above allow to compute a local value "
"numbering, which means that if two variables have the same value, one of "
"them will always be unused. The Unused Pruner or the Redundant Assign "
"Eliminator will then be able to fully eliminate such variables."
msgstr ""

#: ../../internals/optimizer.rst:789 f1f57d96cccf4f7b9e7e3fef45153303
msgid ""
"This step is especially efficient if the expression splitter is run "
"before. If the code is in pseudo-SSA form, the values of variables are "
"available for a longer time and thus we have a higher chance of "
"expressions to be replaceable."
msgstr ""

#: ../../internals/optimizer.rst:794 425dbc16508049588eff91a7ae99002e
msgid ""
"The expression simplifier will be able to perform better replacements if "
"the common subexpression eliminator was run right before it."
msgstr ""

#: ../../internals/optimizer.rst:802 0b84a50827c5487a81261ff840c6585b
msgid ""
"The Expression Simplifier uses the Dataflow Analyzer and makes use of a "
"list of equivalence transforms on expressions like ``X + 0 -> X`` to "
"simplify the code."
msgstr ""

#: ../../internals/optimizer.rst:806 68e5d28819eb46779ee914dbd0ed40a8
msgid ""
"It tries to match patterns like ``X + 0`` on each subexpression. During "
"the matching procedure, it resolves variables to their currently assigned"
" expressions to be able to match more deeply nested patterns even when "
"the code is in pseudo-SSA form."
msgstr ""

#: ../../internals/optimizer.rst:811 1722425f7ac34a538219866069d773e1
msgid ""
"Some of the patterns like ``X - X -> 0`` can only be applied as long as "
"the expression ``X`` is movable, because otherwise it would remove its "
"potential side-effects. Since variable references are always movable, "
"even if their current value might not be, the Expression Simplifier is "
"again more powerful in split or pseudo-SSA form."
msgstr ""

#: ../../internals/optimizer.rst:820 13ee56658ef74731b8ed2394d1dbb610
msgid "LiteralRematerialiser"
msgstr ""

#: ../../internals/optimizer.rst:822 9cf07b7fb676420e83af832ec5065ee9
msgid "To be documented."
msgstr ""

#: ../../internals/optimizer.rst:827 a5ab1786973c4a329c8610e649e5a887
msgid "LoadResolver"
msgstr ""

#: ../../internals/optimizer.rst:829 f08fa9c17e1245b68acfcf0db2de48a8
msgid ""
"Optimisation stage that replaces expressions of type ``sload(x)`` and "
"``mload(x)`` by the value currently stored in storage resp. memory, if "
"known."
msgstr ""

#: ../../internals/optimizer.rst:832 6fe1b079d0824e6497f9631e909dbb4c
msgid "Works best if the code is in SSA form."
msgstr ""

#: ../../internals/optimizer.rst:834 185926201bd14cb191718701e525de7d
msgid "Prerequisite: Disambiguator, ForLoopInitRewriter."
msgstr ""

#: ../../internals/optimizer.rst:839 93a2741ba3534b8aa7515d3779bcf9cb
msgid "ReasoningBasedSimplifier"
msgstr ""

#: ../../internals/optimizer.rst:841 17655e3d8d7447888af6e526f897b2bd
msgid ""
"This optimizer uses SMT solvers to check whether ``if`` conditions are "
"constant."
msgstr ""

#: ../../internals/optimizer.rst:843 ff00df2e72c44e1b898e639a38043c78
msgid ""
"If ``constraints AND condition`` is UNSAT, the condition is never true "
"and the whole body can be removed."
msgstr ""

#: ../../internals/optimizer.rst:844 95b96dd4da8b460ca255861c611e5c6c
msgid ""
"If ``constraints AND NOT condition`` is UNSAT, the condition is always "
"true and can be replaced by ``1``."
msgstr ""

#: ../../internals/optimizer.rst:846 d6c93691a69f471ca73c561280a751ad
msgid "The simplifications above can only be applied if the condition is movable."
msgstr ""

#: ../../internals/optimizer.rst:848 640b1c03d9684a7d995caf9b5bb5a299
msgid ""
"It is only effective on the EVM dialect, but safe to use on other "
"dialects."
msgstr ""

#: ../../internals/optimizer.rst:850 e7c6e57c93cd4b7ba9a684e0e0f52d3d
msgid "Prerequisite: Disambiguator, SSATransform."
msgstr ""

#: ../../internals/optimizer.rst:853 cfa04e68223441729e7d3dab00582bed
msgid "Statement-Scale Simplifications"
msgstr ""

#: ../../internals/optimizer.rst:858 f8c47b15cc144763be292ccab7e3da14
msgid "CircularReferencesPruner"
msgstr ""

#: ../../internals/optimizer.rst:860 0112a3c8363c4bdba8e97d2308e369ce
msgid ""
"This stage removes functions that call each other but are neither "
"externally referenced nor referenced from the outermost context."
msgstr ""

#: ../../internals/optimizer.rst:866 be161017768844bb871964cc723a3a82
msgid "ConditionalSimplifier"
msgstr ""

#: ../../internals/optimizer.rst:868 8b6b2ef2f347412a8e8098bae15c8656
msgid ""
"The Conditional Simplifier inserts assignments to condition variables if "
"the value can be determined from the control-flow."
msgstr ""

#: ../../internals/optimizer.rst:871 bd52c1306808449589ba6ba7e18550aa
msgid "Destroys SSA form."
msgstr ""

#: ../../internals/optimizer.rst:873 15c1a44bfcba4455a8401605f144e583
msgid ""
"Currently, this tool is very limited, mostly because we do not yet have "
"support for boolean types. Since conditions only check for expressions "
"being nonzero, we cannot assign a specific value."
msgstr ""

#: ../../internals/optimizer.rst:877 d7eced34665249e8af1c4a72ac782cfe
msgid "Current features:"
msgstr ""

#: ../../internals/optimizer.rst:879 2188595abb854104ab80b9d0e90624cf
msgid "switch cases: insert \"<condition> := <caseLabel>\""
msgstr ""

#: ../../internals/optimizer.rst:880 1056496bc1fd4057833b5d6b886d298d
msgid ""
"after if statement with terminating control-flow, insert \"<condition> :="
" 0\""
msgstr ""

#: ../../internals/optimizer.rst:882 e655aa47d2df49a1ac5f3557b75d6105
msgid "Future features:"
msgstr ""

#: ../../internals/optimizer.rst:884 e006af43303240f0bbb37acdc6e02c4a
msgid "allow replacements by \"1\""
msgstr ""

#: ../../internals/optimizer.rst:885 8ae81577fb0e43078e73b0138fd275d1
msgid "take termination of user-defined functions into account"
msgstr ""

#: ../../internals/optimizer.rst:887 419156b11e7d4145982770922dd83329
msgid "Works best with SSA form and if dead code removal has run before."
msgstr ""

#: ../../internals/optimizer.rst:889 306f3543ab5a47fc8a709e084d130c51
msgid "Prerequisite: Disambiguator."
msgstr ""

#: ../../internals/optimizer.rst:894 b7d49904218742338829a0f9f808911a
msgid "ConditionalUnsimplifier"
msgstr ""

#: ../../internals/optimizer.rst:896 d0dde42df8864a5aa4abaf306f90ed85
msgid "Reverse of Conditional Simplifier."
msgstr ""

#: ../../internals/optimizer.rst:901 8667fd05d8ae4d90ab9b17324feaba41
msgid "ControlFlowSimplifier"
msgstr ""

#: ../../internals/optimizer.rst:903 ec33d14d144a4150a0f780de2995fcfe
msgid "Simplifies several control-flow structures:"
msgstr ""

#: ../../internals/optimizer.rst:905 f1167c0029ac41bf95d55c4f8ee7b581
msgid "replace if with empty body with pop(condition)"
msgstr ""

#: ../../internals/optimizer.rst:906 7380c89efc794569bd80d2419975a8cd
msgid "remove empty default switch case"
msgstr ""

#: ../../internals/optimizer.rst:907 324b80cd5e8d4bc48c14a4ccd5fec028
msgid "remove empty switch case if no default case exists"
msgstr ""

#: ../../internals/optimizer.rst:908 421a46699a15459d9cf93ef86bc54da4
msgid "replace switch with no cases with pop(expression)"
msgstr ""

#: ../../internals/optimizer.rst:909 ../../internals/optimizer.rst:982
#: 1699623ecc8f4dd3a0a465f331f9b29d 92eb94af1fc844e09e38a70ccc16124a
msgid "turn switch with single case into if"
msgstr ""

#: ../../internals/optimizer.rst:910 7b89d8361cb44819bb98de783b5565f2
msgid "replace switch with only default case with pop(expression) and body"
msgstr ""

#: ../../internals/optimizer.rst:911 c69c06e563474384b1fe7e6d250dc2af
msgid "replace switch with const expr with matching case body"
msgstr ""

#: ../../internals/optimizer.rst:912 0de737ed07fb4d7cb70b3656a7b3784a
msgid ""
"replace ``for`` with terminating control flow and without other "
"break/continue by ``if``"
msgstr ""

#: ../../internals/optimizer.rst:913 754eb31c0f314eccb5cf56a1545540e6
msgid "remove ``leave`` at the end of a function."
msgstr ""

#: ../../internals/optimizer.rst:915 697180b20d7241df94e201fc7c6e5a78
msgid ""
"None of these operations depend on the data flow. The "
"StructuralSimplifier performs similar tasks that do depend on data flow."
msgstr ""

#: ../../internals/optimizer.rst:918 c88308bd36304225b6fe68c962f77807
msgid ""
"The ControlFlowSimplifier does record the presence or absence of "
"``break`` and ``continue`` statements during its traversal."
msgstr ""

#: ../../internals/optimizer.rst:921 3abe2c0ff48641bdacfa028b8ad887ea
msgid ""
"Prerequisite: Disambiguator, FunctionHoister, ForLoopInitRewriter. "
"Important: Introduces EVM opcodes and thus can only be used on EVM code "
"for now."
msgstr ""

#: ../../internals/optimizer.rst:927 b462251391c34d9ea45fcf10f4005c34
msgid "DeadCodeEliminator"
msgstr ""

#: ../../internals/optimizer.rst:929 4a0ef0aa43534e9aa5868fb54f16083f
msgid "This optimization stage removes unreachable code."
msgstr ""

#: ../../internals/optimizer.rst:931 57df07b7ac264ff0be6959347fb3f8c1
msgid ""
"Unreachable code is any code within a block which is preceded by a leave,"
" return, invalid, break, continue, selfdestruct or revert."
msgstr ""

#: ../../internals/optimizer.rst:934 a448b240846148d6a09272f8ea999646
msgid ""
"Function definitions are retained as they might be called by earlier code"
" and thus are considered reachable."
msgstr ""

#: ../../internals/optimizer.rst:937 75bab2525217438eb8af062386d741f9
msgid ""
"Because variables declared in a for loop's init block have their scope "
"extended to the loop body, we require ForLoopInitRewriter to run before "
"this step."
msgstr ""

#: ../../internals/optimizer.rst:940 a5b2510b205f46f8bef56d24f4b991d5
msgid "Prerequisite: ForLoopInitRewriter, Function Hoister, Function Grouper"
msgstr ""

#: ../../internals/optimizer.rst:945 2eb88f460d6943cca63d5767c7095c15
msgid "EqualStoreEliminator"
msgstr ""

#: ../../internals/optimizer.rst:947 f2b7812222344ac3a12da59ab883619d
msgid ""
"This steps removes ``mstore(k, v)`` and ``sstore(k, v)`` calls if there "
"was a previous call to ``mstore(k, v)`` / ``sstore(k, v)``, no other "
"store in between and the values of ``k`` and ``v`` did not change."
msgstr ""

#: ../../internals/optimizer.rst:951 208006d6c1824b0cba39e3cdddb39587
msgid ""
"This simple step is effective if run after the SSA transform and the "
"Common Subexpression Eliminator, because SSA will make sure that the "
"variables will not change and the Common Subexpression Eliminator re-uses"
" exactly the same variable if the value is known to be the same."
msgstr ""

#: ../../internals/optimizer.rst:956 3898d2e4920a408ab967ea126a87f475
msgid "Prerequisites: Disambiguator, ForLoopInitRewriter"
msgstr ""

#: ../../internals/optimizer.rst:961 ff8b68344b1146c9b0b1b4cf5781e81c
msgid "UnusedPruner"
msgstr ""

#: ../../internals/optimizer.rst:963 1cadd26b11924f49aca3f7e3741cd2b5
msgid ""
"This step removes the definitions of all functions that are never "
"referenced."
msgstr ""

#: ../../internals/optimizer.rst:965 126a707fb4b8475ebbba08c4eb6f27a2
msgid ""
"It also removes the declaration of variables that are never referenced. "
"If the declaration assigns a value that is not movable, the expression is"
" retained, but its value is discarded."
msgstr ""

#: ../../internals/optimizer.rst:969 f15a2af01c5d418cb3037c24d8434455
msgid ""
"All movable expression statements (expressions that are not assigned) are"
" removed."
msgstr ""

#: ../../internals/optimizer.rst:974 6521b276f4014a2db33482cc116c0245
msgid "StructuralSimplifier"
msgstr ""

#: ../../internals/optimizer.rst:976 4ec841ad6bd145f7a51a600014807297
msgid ""
"This is a general step that performs various kinds of simplifications on "
"a structural level:"
msgstr ""

#: ../../internals/optimizer.rst:979 afbbd69d5bc4482fa5f5fb59c94f3260
msgid "replace if statement with empty body by ``pop(condition)``"
msgstr ""

#: ../../internals/optimizer.rst:980 6a72cfb15f0248548765327ab17c5066
msgid "replace if statement with true condition by its body"
msgstr ""

#: ../../internals/optimizer.rst:981 543bf134cfbb482d83520b9489a0780d
msgid "remove if statement with false condition"
msgstr ""

#: ../../internals/optimizer.rst:983 ea40a683aec54912a8241c5ea1f325f1
msgid "replace switch with only default case by ``pop(expression)`` and body"
msgstr ""

#: ../../internals/optimizer.rst:984 dc643d7934f141b9b49ad85abca37cc6
msgid "replace switch with literal expression by matching case body"
msgstr ""

#: ../../internals/optimizer.rst:985 0af82570d0b8492dab10b64441f71e53
msgid "replace for loop with false condition by its initialization part"
msgstr ""

#: ../../internals/optimizer.rst:987 4bd548a3e89a41dca3dce14849f8c9bc
msgid "This component uses the Dataflow Analyzer."
msgstr ""

#: ../../internals/optimizer.rst:992 8b5572423dd34f97b7a2b3ad6e24ea92
msgid "BlockFlattener"
msgstr ""

#: ../../internals/optimizer.rst:994 972be74b30fb49f5963a22ccde9c7a9d
msgid ""
"This stage eliminates nested blocks by inserting the statement in the "
"inner block at the appropriate place in the outer block. It depends on "
"the FunctionGrouper and does not flatten the outermost block to keep the "
"form produced by the FunctionGrouper."
msgstr ""

#: ../../internals/optimizer.rst:1023 6700326149a641538c630cc36b820a48
msgid ""
"As long as the code is disambiguated, this does not cause a problem "
"because the scopes of variables can only grow."
msgstr ""

#: ../../internals/optimizer.rst:1029 d5542063fb7b451ea0f3db328d25a4cc
msgid "LoopInvariantCodeMotion"
msgstr ""

#: ../../internals/optimizer.rst:1030 4a9bdd2f9f0d472c88f66b868aa87d1d
msgid ""
"This optimization moves movable SSA variable declarations outside the "
"loop."
msgstr ""

#: ../../internals/optimizer.rst:1032 42b4a08345b24675bfb19e81bb52c887
msgid ""
"Only statements at the top level in a loop's body or post block are "
"considered, i.e variable declarations inside conditional branches will "
"not be moved out of the loop."
msgstr ""

#: ../../internals/optimizer.rst:1035 15125cf2e5384d018d1d7c15bbefa94f
msgid "Requirements:"
msgstr ""

#: ../../internals/optimizer.rst:1037 7f2f5d56adc146959dd6db173c21a123
msgid ""
"The Disambiguator, ForLoopInitRewriter and FunctionHoister must be run "
"upfront."
msgstr ""

#: ../../internals/optimizer.rst:1038 cbd754fa4bf74e32a7bf2a383ff02fa5
msgid ""
"Expression splitter and SSA transform should be run upfront to obtain "
"better result."
msgstr ""

#: ../../internals/optimizer.rst:1042 84a8c7229a984222ab4121d9b17545f2
msgid "Function-Level Optimizations"
msgstr ""

#: ../../internals/optimizer.rst:1047 bb000f295f1e42ff8595ec525e687bf1
msgid "FunctionSpecializer"
msgstr ""

#: ../../internals/optimizer.rst:1049 1352b9a86c2a4ab1854cce8255186be8
msgid "This step specializes the function with its literal arguments."
msgstr ""

#: ../../internals/optimizer.rst:1051 67c79d63867d41169f407c1ff7c1db4d
msgid ""
"If a function, say, ``function f(a, b) { sstore (a, b) }``, is called "
"with literal arguments, for example, ``f(x, 5)``, where ``x`` is an "
"identifier, it could be specialized by creating a new function ``f_1`` "
"that takes only one argument, i.e.,"
msgstr ""

#: ../../internals/optimizer.rst:1062 bd13e4d2841843cc926d2875437448a8
msgid ""
"Other optimization steps will be able to make more simplifications to the"
" function. The optimization step is mainly useful for functions that "
"would not be inlined."
msgstr ""

#: ../../internals/optimizer.rst:1065 feae2144950b421e99e6ca4f7f3d3dba
msgid "Prerequisites: Disambiguator, FunctionHoister"
msgstr ""

#: ../../internals/optimizer.rst:1067 80cad69f8bb044c888cba84727fdca23
msgid ""
"LiteralRematerialiser is recommended as a prerequisite, even though it's "
"not required for correctness."
msgstr ""

#: ../../internals/optimizer.rst:1073 ae10974389934824889c92110523af54
msgid "UnusedFunctionParameterPruner"
msgstr ""

#: ../../internals/optimizer.rst:1075 a519b8e87c0c4c33bb297c3472fbb721
msgid "This step removes unused parameters in a function."
msgstr ""

#: ../../internals/optimizer.rst:1077 b86aaef9bad248c3b87b19dd16192ead
msgid ""
"If a parameter is unused, like ``c`` and ``y`` in, ``function f(a,b,c) ->"
" x, y { x := div(a,b) }``, we remove the parameter and create a new "
"\"linking\" function as follows:"
msgstr ""

#: ../../internals/optimizer.rst:1085 8c9246d69f5b41c3814acec73e79c3cf
msgid ""
"and replace all references to ``f`` by ``f2``. The inliner should be run "
"afterwards to make sure that all references to ``f2`` are replaced by "
"``f``."
msgstr ""

#: ../../internals/optimizer.rst:1089 80d00acfccd54e39a63e96c2db51065e
msgid "Prerequisites: Disambiguator, FunctionHoister, LiteralRematerialiser."
msgstr ""

#: ../../internals/optimizer.rst:1091 c3829194b9274d5cae695c55a9a70e0e
msgid ""
"The step LiteralRematerialiser is not required for correctness. It helps "
"deal with cases such as: ``function f(x) -> y { revert(y, y} }`` where "
"the literal ``y`` will be replaced by its value ``0``, allowing us to "
"rewrite the function."
msgstr ""

#: ../../internals/optimizer.rst:1098 5616553715d743bfa596ef7e8b5eb12e
msgid "EquivalentFunctionCombiner"
msgstr ""

#: ../../internals/optimizer.rst:1100 f42b13703a1f4332b54c139ec1dd2d2b
msgid ""
"If two functions are syntactically equivalent, while allowing variable "
"renaming but not any re-ordering, then any reference to one of the "
"functions is replaced by the other."
msgstr ""

#: ../../internals/optimizer.rst:1104 067f1a7667504eb99cc124118756e48c
msgid "The actual removal of the function is performed by the Unused Pruner."
msgstr ""

#: ../../internals/optimizer.rst:1108 c828456c95e44d209cb212979c3de551
msgid "Function Inlining"
msgstr ""

#: ../../internals/optimizer.rst:1113 63d25e04e04140e89e13d8db3b0c74f5
msgid "ExpressionInliner"
msgstr ""

#: ../../internals/optimizer.rst:1115 c40d5087102d4deebcd616af1292528a
msgid ""
"This component of the optimizer performs restricted function inlining by "
"inlining functions that can be inlined inside functional expressions, "
"i.e. functions that:"
msgstr ""

#: ../../internals/optimizer.rst:1118 2d4885b1ee9645c784e351dd34fa69af
msgid "return a single value."
msgstr ""

#: ../../internals/optimizer.rst:1119 a755e9363cf240169ed538f6e47d2f8c
msgid "have a body like ``r := <functional expression>``."
msgstr ""

#: ../../internals/optimizer.rst:1120 e1f9439eb55843e1a862ec31fc2ed430
msgid "neither reference themselves nor ``r`` in the right hand side."
msgstr ""

#: ../../internals/optimizer.rst:1122 5a25565d655442a68e25d23a98ee1e7b
msgid "Furthermore, for all parameters, all of the following need to be true:"
msgstr ""

#: ../../internals/optimizer.rst:1124 538112e61d714905801c9c81dad7da45
msgid "The argument is movable."
msgstr ""

#: ../../internals/optimizer.rst:1125 60123ca2d79e427480e02998933dc046
msgid ""
"The parameter is either referenced less than twice in the function body, "
"or the argument is rather cheap (\"cost\" of at most 1, like a constant "
"up to 0xff)."
msgstr ""

#: ../../internals/optimizer.rst:1128 52e70b58a4d54750a8499c0359912a6e
msgid ""
"Example: The function to be inlined has the form of ``function f(...) -> "
"r { r := E }`` where ``E`` is an expression that does not reference ``r``"
" and all arguments in the function call are movable expressions."
msgstr ""

#: ../../internals/optimizer.rst:1131 8498322dc184415f8911f80f0161df71
msgid "The result of this inlining is always a single expression."
msgstr ""

#: ../../internals/optimizer.rst:1133 bbc5099a45c546bbbc0ca9ffc894149e
msgid "This component can only be used on sources with unique names."
msgstr ""

#: ../../internals/optimizer.rst:1138 2e3e2892a09e4ccab99e59c0caeb8e4b
msgid "FullInliner"
msgstr ""

#: ../../internals/optimizer.rst:1140 8e8028bd3e494739a7084328974e8b65
msgid ""
"The Full Inliner replaces certain calls of certain functions by the "
"function's body. This is not very helpful in most cases, because it just "
"increases the code size but does not have a benefit. Furthermore, code is"
" usually very expensive and we would often rather have shorter code than "
"more efficient code. In same cases, though, inlining a function can have "
"positive effects on subsequent optimizer steps. This is the case if one "
"of the function arguments is a constant, for example."
msgstr ""

#: ../../internals/optimizer.rst:1148 3e2e264d8c984168ad74905f2bb59194
msgid ""
"During inlining, a heuristic is used to tell if the function call should "
"be inlined or not. The current heuristic does not inline into \"large\" "
"functions unless the called function is tiny. Functions that are only "
"used once are inlined, as well as medium-sized functions, while function "
"calls with constant arguments allow slightly larger functions."
msgstr ""

#: ../../internals/optimizer.rst:1156 57ea8ee7e5c64854916543ba5af6a935
msgid ""
"In the future, we may include a backtracking component that, instead of "
"inlining a function right away, only specializes it, which means that a "
"copy of the function is generated where a certain parameter is always "
"replaced by a constant. After that, we can run the optimizer on this "
"specialized function. If it results in heavy gains, the specialized "
"function is kept, otherwise the original function is used instead."
msgstr ""

#: ../../internals/optimizer.rst:1165 b9110b6b963c4799adf14158a5a48f1d
msgid "Cleanup"
msgstr ""

#: ../../internals/optimizer.rst:1167 b7304e9c050c46ce8db5eccf701fe9eb
msgid ""
"The cleanup is performed at the end of the optimizer run. It tries to "
"combine split expressions into deeply nested ones again and also improves"
" the \"compilability\" for stack machines by eliminating variables as "
"much as possible."
msgstr ""

#: ../../internals/optimizer.rst:1175 3be7f629b4ea4633a2649fc2f863de24
msgid "ExpressionJoiner"
msgstr ""

#: ../../internals/optimizer.rst:1177 f213328b2cc4475a9eb6efa40f17aeed
msgid ""
"This is the opposite operation of the expression splitter. It turns a "
"sequence of variable declarations that have exactly one reference into a "
"complex expression. This stage fully preserves the order of function "
"calls and opcode executions. It does not make use of any information "
"concerning the commutativity of the opcodes; if moving the value of a "
"variable to its place of use would change the order of any function call "
"or opcode execution, the transformation is not performed."
msgstr ""

#: ../../internals/optimizer.rst:1184 bd18ee0b382e4cbdbcf8bc853ce2d95d
msgid ""
"Note that the component will not move the assigned value of a variable "
"assignment or a variable that is referenced more than once."
msgstr ""

#: ../../internals/optimizer.rst:1187 fd8c87c6076941d4adb1c7d445a84397
msgid ""
"The snippet ``let x := add(0, 2) let y := mul(x, mload(2))`` is not "
"transformed, because it would cause the order of the call to the opcodes "
"``add`` and ``mload`` to be swapped - even though this would not make a "
"difference because ``add`` is movable."
msgstr ""

#: ../../internals/optimizer.rst:1192 49677140ff114b42b90974a4fdf7a298
msgid ""
"When reordering opcodes like that, variable references and literals are "
"ignored. Because of that, the snippet ``let x := add(0, 2) let y := "
"mul(x, 3)`` is transformed to ``let y := mul(add(0, 2), 3)``, even though"
" the ``add`` opcode would be executed after the evaluation of the literal"
" ``3``."
msgstr ""

#: ../../internals/optimizer.rst:1200 357a6ae04795411c80b1a870c7796496
msgid "SSAReverser"
msgstr ""

#: ../../internals/optimizer.rst:1202 1c076c07a73a4351b14cc962a830f126
msgid ""
"This is a tiny step that helps in reversing the effects of the SSA "
"transform if it is combined with the Common Subexpression Eliminator and "
"the Unused Pruner."
msgstr ""

#: ../../internals/optimizer.rst:1206 424d3cd649184b3cb0df8bde55575294
msgid ""
"The SSA form we generate is detrimental to code generation on the EVM and"
" WebAssembly alike because it generates many local variables. It would be"
" better to just re-use existing variables with assignments instead of "
"fresh variable declarations."
msgstr ""

#: ../../internals/optimizer.rst:1211 b37adb33f70a49b1a067be409a83733f
msgid "The SSA transform rewrites"
msgstr ""

#: ../../internals/optimizer.rst:1218 8aea294278d4406cbf4edd2405a99b00
msgid "to"
msgstr ""

#: ../../internals/optimizer.rst:1228 11431dffcd9243ca9b62fa6c905f3fea
msgid ""
"The problem is that instead of ``a``, the variable ``a_1`` is used "
"whenever ``a`` was referenced. The SSA transform changes statements of "
"this form by just swapping out the declaration and the assignment. The "
"above snippet is turned into"
msgstr ""

#: ../../internals/optimizer.rst:1241 b56fac20c15e44f6ae434974ba5b8ce1
msgid ""
"This is a very simple equivalence transform, but when we now run the "
"Common Subexpression Eliminator, it will replace all occurrences of "
"``a_1`` by ``a`` (until ``a`` is re-assigned). The Unused Pruner will "
"then eliminate the variable ``a_1`` altogether and thus fully reverse the"
" SSA transform."
msgstr ""

#: ../../internals/optimizer.rst:1250 288517c518fd45ada30ccf5188a100ee
msgid "StackCompressor"
msgstr ""

#: ../../internals/optimizer.rst:1252 5be07345a69344afb13709af01b0ab2e
msgid ""
"One problem that makes code generation for the Ethereum Virtual Machine "
"hard is the fact that there is a hard limit of 16 slots for reaching down"
" the expression stack. This more or less translates to a limit of 16 "
"local variables. The stack compressor takes Yul code and compiles it to "
"EVM bytecode. Whenever the stack difference is too large, it records the "
"function this happened in."
msgstr ""

#: ../../internals/optimizer.rst:1259 e182b706c5de47b9a2a667647ee54579
msgid ""
"For each function that caused such a problem, the Rematerialiser is "
"called with a special request to aggressively eliminate specific "
"variables sorted by the cost of their values."
msgstr ""

#: ../../internals/optimizer.rst:1263 1a3f530e15bf479d82ef8f6d24ac41a5
msgid "On failure, this procedure is repeated multiple times."
msgstr ""

#: ../../internals/optimizer.rst:1268 7d6922e2adc7469b8a557c0c45608223
msgid "Rematerialiser"
msgstr ""

#: ../../internals/optimizer.rst:1270 b85f45995b844fc68c2f9c8275445f9e
msgid ""
"The rematerialisation stage tries to replace variable references by the "
"expression that was last assigned to the variable. This is of course only"
" beneficial if this expression is comparatively cheap to evaluate. "
"Furthermore, it is only semantically equivalent if the value of the "
"expression did not change between the point of assignment and the point "
"of use. The main benefit of this stage is that it can save stack slots if"
" it leads to a variable being eliminated completely (see below), but it "
"can also save a DUP opcode on the EVM if the expression is very cheap."
msgstr ""

#: ../../internals/optimizer.rst:1278 79106337a94a42ec9787246cf7fc1e3a
msgid ""
"The Rematerialiser uses the Dataflow Analyzer to track the current values"
" of variables, which are always movable. If the value is very cheap or "
"the variable was explicitly requested to be eliminated, the variable "
"reference is replaced by its current value."
msgstr ""

#: ../../internals/optimizer.rst:1286 a65e83d23ba048f59e7b70c186d3ca73
msgid "ForLoopConditionOutOfBody"
msgstr ""

#: ../../internals/optimizer.rst:1288 ef5e04ccd6c24807bf96617d4cfbd069
msgid "Reverses the transformation of ForLoopConditionIntoBody."
msgstr ""

#: ../../internals/optimizer.rst:1290 761a06dd73d949fd9839df9ab35930b0
msgid "For any movable ``c``, it turns"
msgstr ""

#: ../../internals/optimizer.rst:1299 ../../internals/optimizer.rst:1316
#: c1276dd4545444efb28297ebacfa5c9c c57a4973d848475184db213848753146
msgid "into"
msgstr ""

#: ../../internals/optimizer.rst:1307 9949e35f28d843df965ee02e9403ea2c
msgid "and it turns"
msgstr ""

#: ../../internals/optimizer.rst:1324 158a4369f4144e61ab8a29c6f0646ab9
msgid "The LiteralRematerialiser should be run before this step."
msgstr ""

#: ../../internals/optimizer.rst:1328 0ebee052063f4458bae33ae49f9d0385
msgid "WebAssembly specific"
msgstr ""

#: ../../internals/optimizer.rst:1331 6061c6f7e93b428582a1129967347f97
msgid "MainFunction"
msgstr ""

#: ../../internals/optimizer.rst:1333 cf1c15e962ca45f3a40879814d15399f
msgid ""
"Changes the topmost block to be a function with a specific name "
"(\"main\") which has no inputs nor outputs."
msgstr ""

#: ../../internals/optimizer.rst:1336 3f082d0608704de0a487db474c8df302
msgid "Depends on the Function Grouper."
msgstr ""

