# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2016-2021, Ethereum
# This file is distributed under the same license as the Solidity package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Solidity 0.8.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-01-13 16:47+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../internals/source_mappings.rst:5 fecce89828534329b778bab42fcfa9f1
msgid "Source Mappings"
msgstr ""

#: ../../internals/source_mappings.rst:7 983793d97b354c9a9f95fd51ed7476f4
msgid ""
"As part of the AST output, the compiler provides the range of the source "
"code that is represented by the respective node in the AST. This can be "
"used for various purposes ranging from static analysis tools that report "
"errors based on the AST and debugging tools that highlight local "
"variables and their uses."
msgstr ""

#: ../../internals/source_mappings.rst:13 f270882bc6c94fa2ba960968aada87dc
msgid ""
"Furthermore, the compiler can also generate a mapping from the bytecode "
"to the range in the source code that generated the instruction. This is "
"again important for static analysis tools that operate on bytecode level "
"and for displaying the current position in the source code inside a "
"debugger or for breakpoint handling. This mapping also contains other "
"information, like the jump type and the modifier depth (see below)."
msgstr ""

#: ../../internals/source_mappings.rst:20 117ba426d7ef4d27ac1c62ff6cb10da6
msgid ""
"Both kinds of source mappings use integer identifiers to refer to source "
"files. The identifier of a source file is stored in "
"``output['sources'][sourceName]['id']`` where ``output`` is the output of"
" the standard-json compiler interface parsed as JSON. For some utility "
"routines, the compiler generates \"internal\" source files that are not "
"part of the original input but are referenced from the source mappings. "
"These source files together with their identifiers can be obtained via "
"``output['contracts'][sourceName][contractName]['evm']['bytecode']['generatedSources']``."
msgstr ""

#: ../../internals/source_mappings.rst:30 0de03adcfc734b088ddaf2ca6a2194eb
msgid ""
"In the case of instructions that are not associated with any particular "
"source file, the source mapping assigns an integer identifier of ``-1``. "
"This may happen for bytecode sections stemming from compiler-generated "
"inline assembly statements."
msgstr ""

#: ../../internals/source_mappings.rst:34 aadc988714d64f909b3e81434e5f0f88
msgid "The source mappings inside the AST use the following notation:"
msgstr ""

#: ../../internals/source_mappings.rst:37 af6f5fc4308e4764bb331ebce3102cb8
msgid "``s:l:f``"
msgstr ""

#: ../../internals/source_mappings.rst:39 11a02f20a09e49a7bc35496eb2388923
msgid ""
"Where ``s`` is the byte-offset to the start of the range in the source "
"file, ``l`` is the length of the source range in bytes and ``f`` is the "
"source index mentioned above."
msgstr ""

#: ../../internals/source_mappings.rst:43 8f88dd1b367d4ae3a73d6324383c250f
msgid ""
"The encoding in the source mapping for the bytecode is more complicated: "
"It is a list of ``s:l:f:j:m`` separated by ``;``. Each of these elements "
"corresponds to an instruction, i.e. you cannot use the byte offset but "
"have to use the instruction offset (push instructions are longer than a "
"single byte). The fields ``s``, ``l`` and ``f`` are as above. ``j`` can "
"be either ``i``, ``o`` or ``-`` signifying whether a jump instruction "
"goes into a function, returns from a function or is a regular jump as "
"part of e.g. a loop. The last field, ``m``, is an integer that denotes "
"the \"modifier depth\". This depth is increased whenever the placeholder "
"statement (``_``) is entered in a modifier and decreased when it is left "
"again. This allows debuggers to track tricky cases like the same modifier"
" being used twice or multiple placeholder statements being used in a "
"single modifier."
msgstr ""

#: ../../internals/source_mappings.rst:56 0a722dbe8c14407f8cd09647d9036e69
msgid ""
"In order to compress these source mappings especially for bytecode, the "
"following rules are used:"
msgstr ""

#: ../../internals/source_mappings.rst:59 6e15b45532b24256b0146bd62ae53caf
msgid "If a field is empty, the value of the preceding element is used."
msgstr ""

#: ../../internals/source_mappings.rst:60 3deb4b2b3c1443cca312362cc72c3126
msgid "If a ``:`` is missing, all following fields are considered empty."
msgstr ""

#: ../../internals/source_mappings.rst:62 59432cb4458b4ab3ad7be3d4258bae86
msgid "This means the following source mappings represent the same information:"
msgstr ""

#: ../../internals/source_mappings.rst:64 5a5c1a3add634c61b45a181479ddd80a
msgid "``1:2:1;1:9:1;2:1:2;2:1:2;2:1:2``"
msgstr ""

#: ../../internals/source_mappings.rst:66 eb79f3b1c8ff4bd298006d662e0ec953
msgid "``1:2:1;:9;2:1:2;;``"
msgstr ""

#: ../../internals/source_mappings.rst:68 22446482cbbd45b69ac4869e9dd3c3c5
msgid ""
"Important to note is that when the :ref:`verbatim <yul-verbatim>` builtin"
" is used, the source mappings will be invalid: The builtin is considered "
"a single instruction instead of potentially multiple."
msgstr ""

