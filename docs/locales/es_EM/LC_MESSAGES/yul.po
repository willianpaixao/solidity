msgid ""
msgstr ""
"Project-Id-Version: solidity-test\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-01-13 16:47+0100\n"
"PO-Revision-Date: 2022-01-13 16:14\n"
"Last-Translator: \n"
"Language-Team: Spanish (Modern)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Crowdin-Project: solidity-test\n"
"X-Crowdin-Project-ID: 494285\n"
"X-Crowdin-Language: es-EM\n"
"X-Crowdin-File: yul.po\n"
"X-Crowdin-File-ID: 67\n"
"Language: es_EM\n"

#: ../../yul.rst:5 bc8621cc2a3d4ac48a9054073763a82d
msgid "Yul"
msgstr ""

#: ../../yul.rst:9 22b632bc89e74d1a97382e3baa109e10
msgid "Yul (previously also called JULIA or IULIA) is an intermediate language that can be compiled to bytecode for different backends."
msgstr ""

#: ../../yul.rst:12 452928eeb33f4a759b996cd9b6e382b0
msgid "Support for EVM 1.0, EVM 1.5 and Ewasm is planned, and it is designed to be a usable common denominator of all three platforms. It can already be used in stand-alone mode and for \"inline assembly\" inside Solidity and there is an experimental implementation of the Solidity compiler that uses Yul as an intermediate language. Yul is a good target for high-level optimisation stages that can benefit all target platforms equally."
msgstr ""

#: ../../yul.rst:21 ac52c70a1db346ccb47ed0afbf82c362
msgid "Motivation and High-level Description"
msgstr ""

#: ../../yul.rst:23 ed111342de6e46e49de52d18de5c07fa
msgid "The design of Yul tries to achieve several goals:"
msgstr ""

#: ../../yul.rst:25 649a0fe38c644c6cb4bae6795cc0c9a1
msgid "Programs written in Yul should be readable, even if the code is generated by a compiler from Solidity or another high-level language."
msgstr ""

#: ../../yul.rst:26 e5546a6832264aed89d97d85e7ff0476
msgid "Control flow should be easy to understand to help in manual inspection, formal verification and optimization."
msgstr ""

#: ../../yul.rst:27 2533143bf2b044c48b8c457ed57f55d2
msgid "The translation from Yul to bytecode should be as straightforward as possible."
msgstr ""

#: ../../yul.rst:28 f0c6286fc9734bd9870336c594768e23
msgid "Yul should be suitable for whole-program optimization."
msgstr ""

#: ../../yul.rst:30 58a60da6dcaa4fd9b713a9193703e806
msgid "In order to achieve the first and second goal, Yul provides high-level constructs like ``for`` loops, ``if`` and ``switch`` statements and function calls. These should be sufficient for adequately representing the control flow for assembly programs. Therefore, no explicit statements for ``SWAP``, ``DUP``, ``JUMPDEST``, ``JUMP`` and ``JUMPI`` are provided, because the first two obfuscate the data flow and the last two obfuscate control flow. Furthermore, functional statements of the form ``mul(add(x, y), 7)`` are preferred over pure opcode statements like ``7 y x add mul`` because in the first form, it is much easier to see which operand is used for which opcode."
msgstr ""

#: ../../yul.rst:40 c713d3808edf4e2db3fa691b86eb7142
msgid "Even though it was designed for stack machines, Yul does not expose the complexity of the stack itself. The programmer or auditor should not have to worry about the stack."
msgstr ""

#: ../../yul.rst:43 1e8d5c7639c14d0f8e3a59cd0c178632
msgid "The third goal is achieved by compiling the higher level constructs to bytecode in a very regular way. The only non-local operation performed by the assembler is name lookup of user-defined identifiers (functions, variables, ...) and cleanup of local variables from the stack."
msgstr ""

#: ../../yul.rst:49 0fb6115c65414d929fed99f69e91d809
msgid "To avoid confusions between concepts like values and references, Yul is statically typed. At the same time, there is a default type (usually the integer word of the target machine) that can always be omitted to help readability."
msgstr ""

#: ../../yul.rst:54 3a1ee8d6e74b49f48ac848e7a8651b6d
msgid "To keep the language simple and flexible, Yul does not have any built-in operations, functions or types in its pure form. These are added together with their semantics when specifying a dialect of Yul, which allows specializing Yul to the requirements of different target platforms and feature sets."
msgstr ""

#: ../../yul.rst:60 873c8c0b3d234f499cf3f2cd8f8fc7bf
msgid "Currently, there is only one specified dialect of Yul. This dialect uses the EVM opcodes as builtin functions (see below) and defines only the type ``u256``, which is the native 256-bit type of the EVM. Because of that, we will not provide types in the examples below."
msgstr ""

#: ../../yul.rst:67 1d5423a5a99d44b3adc5755c7b166bad
msgid "Simple Example"
msgstr ""

#: ../../yul.rst:69 9deb74cfd1814d5eb7f802c1028c8b08
msgid "The following example program is written in the EVM dialect and computes exponentiation. It can be compiled using ``solc --strict-assembly``. The builtin functions ``mul`` and ``div`` compute product and division, respectively."
msgstr ""

#: ../../yul.rst:90 0fb29d0fa157412abcabc8a1e323b4c9
msgid "It is also possible to implement the same function using a for-loop instead of with recursion. Here, ``lt(a, b)`` computes whether ``a`` is less than ``b``. less-than comparison."
msgstr ""

#: ../../yul.rst:107 1529853b8ba14adc80bbdb745f50760a
msgid "At the :ref:`end of the section <erc20yul>`, a complete implementation of the ERC-20 standard can be found."
msgstr ""

#: ../../yul.rst:113 c437fc6b39e8455f9edc925dd8fc67af
msgid "Stand-Alone Usage"
msgstr ""

#: ../../yul.rst:115 d85469b4a4ff41b2bb0756233a3c9feb
msgid "You can use Yul in its stand-alone form in the EVM dialect using the Solidity compiler. This will use the :ref:`Yul object notation <yul-object>` so that it is possible to refer to code as data to deploy contracts. This Yul mode is available for the commandline compiler (use ``--strict-assembly``) and for the :ref:`standard-json interface <compiler-api>`:"
msgstr ""

#: ../../yul.rst:133 29eb68de753f43e6bc811590a876e6a6
msgid "Yul is in active development and bytecode generation is only fully implemented for the EVM dialect of Yul with EVM 1.0 as target."
msgstr ""

#: ../../yul.rst:138 d707e9e97aa84028a7496e367c869a0c
msgid "Informal Description of Yul"
msgstr ""

#: ../../yul.rst:140 b37f0cf28a334191aa6ac3dda33d5fa7
msgid "In the following, we will talk about each individual aspect of the Yul language. In examples, we will use the default EVM dialect."
msgstr ""

#: ../../yul.rst:144 100261bdbfb544d8a2e8a9448ffa5d62
msgid "Syntax"
msgstr ""

#: ../../yul.rst:146 246c3bd15cda4e6ca09f7a519f65937e
msgid "Yul parses comments, literals and identifiers in the same way as Solidity, so you can e.g. use ``//`` and ``/* */`` to denote comments. There is one exception: Identifiers in Yul can contain dots: ``.``."
msgstr ""

#: ../../yul.rst:150 54e38f359b82460fb803df6ef45f0955
msgid "Yul can specify \"objects\" that consist of code, data and sub-objects. Please see :ref:`Yul Objects <yul-object>` below for details on that. In this section, we are only concerned with the code part of such an object. This code part always consists of a curly-braces delimited block. Most tools support specifying just a code block where an object is expected."
msgstr ""

#: ../../yul.rst:157 2d0a4ebe32ce4ebe914ba8321839d6b3
msgid "Inside a code block, the following elements can be used (see the later sections for more details):"
msgstr ""

#: ../../yul.rst:160 305aac1ddd3347a9a088c1c2b06f8b9c
msgid "literals, i.e. ``0x123``, ``42`` or ``\"abc\"`` (strings up to 32 characters)"
msgstr ""

#: ../../yul.rst:161 0e2acff821d441d290d34e198e127da7
msgid "calls to builtin functions, e.g. ``add(1, mload(0))``"
msgstr ""

#: ../../yul.rst:162 050f7cf62ca545c49be3fa19e2abb97a
msgid "variable declarations, e.g. ``let x := 7``, ``let x := add(y, 3)`` or ``let x`` (initial value of 0 is assigned)"
msgstr ""

#: ../../yul.rst:163 18fa1b4b5d6440afbc7f2743c8dba898
msgid "identifiers (variables), e.g. ``add(3, x)``"
msgstr ""

#: ../../yul.rst:164 73565fed691f45579ae0e433ddd4f692
msgid "assignments, e.g. ``x := add(y, 3)``"
msgstr ""

#: ../../yul.rst:165 ebd9122191c34fb0bd78bdaed1a03cbb
msgid "blocks where local variables are scoped inside, e.g. ``{ let x := 3 { let y := add(x, 1) } }``"
msgstr ""

#: ../../yul.rst:166 31466fd907de499888cb43523e3f2205
msgid "if statements, e.g. ``if lt(a, b) { sstore(0, 1) }``"
msgstr ""

#: ../../yul.rst:167 bdc750775c234143a231c75d4c81771a
msgid "switch statements, e.g. ``switch mload(0) case 0 { revert() } default { mstore(0, 1) }``"
msgstr ""

#: ../../yul.rst:168 98832226fd52429f9b51b5ce0efd5c12
msgid "for loops, e.g. ``for { let i := 0} lt(i, 10) { i := add(i, 1) } { mstore(i, 7) }``"
msgstr ""

#: ../../yul.rst:169 661c235ae1a54fd19cf2b15510a9c678
msgid "function definitions, e.g. ``function f(a, b) -> c { c := add(a, b) }``"
msgstr ""

#: ../../yul.rst:171 f299e84c7f8e47978e1e46228f52e11c
msgid "Multiple syntactical elements can follow each other simply separated by whitespace, i.e. there is no terminating ``;`` or newline required."
msgstr ""

#: ../../yul.rst:175 2a1bdee60e4440088a2d5419337e8a55
msgid "Literals"
msgstr ""

#: ../../yul.rst:177 4568b969602641acabf3eb6b316d7c76
msgid "As literals, you can use:"
msgstr ""

#: ../../yul.rst:179 8fcd9749b13f406998a9f12bebbe21c6
msgid "Integer constants in decimal or hexadecimal notation."
msgstr ""

#: ../../yul.rst:181 2b4e1458b7474277a8470610453ed492
msgid "ASCII strings (e.g. ``\"abc\"``), which may contain hex escapes ``\\xNN`` and Unicode escapes ``\\uNNNN`` where ``N`` are hexadecimal digits."
msgstr ""

#: ../../yul.rst:183 ffbe437d017641b8881f0d54acd8ec88
msgid "Hex strings (e.g. ``hex\"616263\"``)."
msgstr ""

#: ../../yul.rst:185 e9e6d10e600a43e3becadd0f8153fb22
msgid "In the EVM dialect of Yul, literals represent 256-bit words as follows:"
msgstr ""

#: ../../yul.rst:187 2bd1b546b0a24795bbd2608cf935c2ec
msgid "Decimal or hexadecimal constants must be less than ``2**256``. They represent the 256-bit word with that value as an unsigned integer in big endian encoding."
msgstr ""

#: ../../yul.rst:190 9fb6165cbcc1450c98fffe408f18d0ca
msgid "An ASCII string is first viewed as a byte sequence, by viewing a non-escape ASCII character as a single byte whose value is the ASCII code, an escape ``\\xNN`` as single byte with that value, and an escape ``\\uNNNN`` as the UTF-8 sequence of bytes for that code point. The byte sequence must not exceed 32 bytes. The byte sequence is padded with zeros on the right to reach 32 bytes in length; in other words, the string is stored left-aligned. The padded byte sequence represents a 256-bit word whose most significant 8 bits are the ones from the first byte, i.e. the bytes are interpreted in big endian form."
msgstr ""

#: ../../yul.rst:200 ebd8f197095645cd8591967cd0412a0a
msgid "A hex string is first viewed as a byte sequence, by viewing each pair of contiguous hex digits as a byte. The byte sequence must not exceed 32 bytes (i.e. 64 hex digits), and is treated as above."
msgstr ""

#: ../../yul.rst:204 ccfead2e3757414dac520e5a8b25f874
msgid "When compiling for the EVM, this will be translated into an appropriate ``PUSHi`` instruction. In the following example, ``3`` and ``2`` are added resulting in 5 and then the bitwise ``and`` with the string \"abc\" is computed. The final value is assigned to a local variable called ``x``."
msgstr ""

#: ../../yul.rst:210 b6e666bb49a74e198aea6282d810dd2b
msgid "The 32-byte limit above does not apply to string literals passed to builtin functions that require literal arguments (e.g. ``setimmutable`` or ``loadimmutable``). Those strings never end up in the generated bytecode."
msgstr ""

#: ../../yul.rst:218 8ef8d0dee94042db85481cd44392df68
msgid "Unless it is the default type, the type of a literal has to be specified after a colon:"
msgstr ""

#: ../../yul.rst:228 09e95a20665e4af1836828e49b410ae7
msgid "Function Calls"
msgstr ""

#: ../../yul.rst:230 efb2ab6c7b0f44738de85a9d93d7479b
msgid "Both built-in and user-defined functions (see below) can be called in the same way as shown in the previous example. If the function returns a single value, it can be directly used inside an expression again. If it returns multiple values, they have to be assigned to local variables."
msgstr ""

#: ../../yul.rst:243 a6747673744f44da81ea6d3df7a0cb9f
msgid "For built-in functions of the EVM, functional expressions can be directly translated to a stream of opcodes: You just read the expression from right to left to obtain the opcodes. In the case of the first line in the example, this is ``PUSH1 3 PUSH1 0x80 MLOAD ADD PUSH1 0x80 MSTORE``."
msgstr ""

#: ../../yul.rst:249 6677e5e48bed49c9944024e4085409d2
msgid "For calls to user-defined functions, the arguments are also put on the stack from right to left and this is the order in which argument lists are evaluated. The return values, though, are expected on the stack from left to right, i.e. in this example, ``y`` is on top of the stack and ``x`` is below it."
msgstr ""

#: ../../yul.rst:257 28322a85d71e41fa96d3518df99ffca5
msgid "Variable Declarations"
msgstr ""

#: ../../yul.rst:259 4fc8ff321aed4a2a926a6f7efd366103
msgid "You can use the ``let`` keyword to declare variables. A variable is only visible inside the ``{...}``-block it was defined in. When compiling to the EVM, a new stack slot is created that is reserved for the variable and automatically removed again when the end of the block is reached. You can provide an initial value for the variable. If you do not provide a value, the variable will be initialized to zero."
msgstr ""

#: ../../yul.rst:267 8e3d8e8526b347bf840e0e0fdcfcd72d
msgid "Since variables are stored on the stack, they do not directly influence memory or storage, but they can be used as pointers to memory or storage locations in the built-in functions ``mstore``, ``mload``, ``sstore`` and ``sload``. Future dialects might introduce specific types for such pointers."
msgstr ""

#: ../../yul.rst:273 86b6e9a421554580af8dc669de59d873
msgid "When a variable is referenced, its current value is copied. For the EVM, this translates to a ``DUP`` instruction."
msgstr ""

#: ../../yul.rst:289 9fce99e989ae46e48d85ef405031f0c2
msgid "If the declared variable should have a type different from the default type, you denote that following a colon. You can also declare multiple variables in one statement when you assign from a function call that returns multiple values."
msgstr ""

#: ../../yul.rst:303 55beeb7981b64ff7a4337cebb96602fb
msgid "Depending on the optimiser settings, the compiler can free the stack slots already after the variable has been used for the last time, even though it is still in scope."
msgstr ""

#: ../../yul.rst:309 4f76b971f5bd445cb4319f085c060636
msgid "Assignments"
msgstr ""

#: ../../yul.rst:311 09620cbeef9d4aeb8160e5760a2273ad
msgid "Variables can be assigned to after their definition using the ``:=`` operator. It is possible to assign multiple variables at the same time. For this, the number and types of the values have to match. If you want to assign the values returned from a function that has multiple return parameters, you have to provide multiple variables. The same variable may not occur multiple times on the left-hand side of an assignment, e.g. ``x, x := f()`` is invalid."
msgstr ""

#: ../../yul.rst:332 335275ee568e467980752ed461233450
msgid "If"
msgstr ""

#: ../../yul.rst:334 cbb66fc10ca44b6984ab30e58719bc64
msgid "The if statement can be used for conditionally executing code. No \"else\" block can be defined. Consider using \"switch\" instead (see below) if you need multiple alternatives."
msgstr ""

#: ../../yul.rst:342 9cbd9d4af8b34b0dbdfb9b7aa2f38e27
msgid "The curly braces for the body are required."
msgstr ""

#: ../../yul.rst:345 b317a33e0f6b4c79aadca478376ccd33
msgid "Switch"
msgstr ""

#: ../../yul.rst:347 3ce0df08c96247e2807851586a303c46
msgid "You can use a switch statement as an extended version of the if statement. It takes the value of an expression and compares it to several literal constants. The branch corresponding to the matching constant is taken. Contrary to other programming languages, for safety reasons, control flow does not continue from one case to the next. There can be a fallback or default case called ``default`` which is taken if none of the literal constants matches."
msgstr ""

#: ../../yul.rst:368 a570f49e0d884d7e92fc76278c6de811
msgid "The list of cases is not enclosed by curly braces, but the body of a case does require them."
msgstr ""

#: ../../yul.rst:372 8cd88f4fc7fe4b749242a4d0666af957
msgid "Loops"
msgstr ""

#: ../../yul.rst:374 656a595b0ae04e99994cabba19228a8a
msgid "Yul supports for-loops which consist of a header containing an initializing part, a condition, a post-iteration part and a body. The condition has to be an expression, while the other three are blocks. If the initializing part declares any variables at the top level, the scope of these variables extends to all other parts of the loop."
msgstr ""

#: ../../yul.rst:381 bcaa3528fba84c5e86e0e1552d280242
msgid "The ``break`` and ``continue`` statements can be used in the body to exit the loop or skip to the post-part, respectively."
msgstr ""

#: ../../yul.rst:384 2c8bde7b58cc41cc8c10a0f4e4a32fc2
msgid "The following example computes the sum of an area in memory."
msgstr ""

#: ../../yul.rst:395 f8363d5591494060b3a7127ee4c5fde2
msgid "For loops can also be used as a replacement for while loops: Simply leave the initialization and post-iteration parts empty."
msgstr ""

#: ../../yul.rst:410 7925962629374390ada4ab7cfd234b02
msgid "Function Declarations"
msgstr ""

#: ../../yul.rst:412 424c5602a44c41f8912465414480e9f6
msgid "Yul allows the definition of functions. These should not be confused with functions in Solidity since they are never part of an external interface of a contract and are part of a namespace separate from the one for Solidity functions."
msgstr ""

#: ../../yul.rst:416 c4ccc9f1e5404fd0bbe40c7f4a09d9ed
msgid "For the EVM, Yul functions take their arguments (and a return PC) from the stack and also put the results onto the stack. User-defined functions and built-in functions are called in exactly the same way."
msgstr ""

#: ../../yul.rst:420 387aa65c85eb43fc8a57b088e593c739
msgid "Functions can be defined anywhere and are visible in the block they are declared in. Inside a function, you cannot access local variables defined outside of that function."
msgstr ""

#: ../../yul.rst:424 ea93dbf717164657b2a3b0408efe064e
msgid "Functions declare parameters and return variables, similar to Solidity. To return a value, you assign it to the return variable(s)."
msgstr ""

#: ../../yul.rst:427 59f349bc48264668ba11e9af04bdc6d2
msgid "If you call a function that returns multiple values, you have to assign them to multiple variables using ``a, b := f(x)`` or ``let a, b := f(x)``."
msgstr ""

#: ../../yul.rst:430 e05e29e5e7754230ba84806da07fc388
msgid "The ``leave`` statement can be used to exit the current function. It works like the ``return`` statement in other languages just that it does not take a value to return, it just exits the functions and the function will return whatever values are currently assigned to the return variable(s)."
msgstr ""

#: ../../yul.rst:435 ed74fd380fc740c387bdefd22fe3a984
msgid "Note that the EVM dialect has a built-in function called ``return`` that quits the full execution context (internal message call) and not just the current yul function."
msgstr ""

#: ../../yul.rst:439 337d55204e8c4eb1995a99300ca76f9c
msgid "The following example implements the power function by square-and-multiply."
msgstr ""

#: ../../yul.rst:457 a9fd43d5f6e54800aebf80cf276ff0a3
msgid "Specification of Yul"
msgstr ""

#: ../../yul.rst:459 51586135106b4df180b05cf1a42d1721
msgid "This chapter describes Yul code formally. Yul code is usually placed inside Yul objects, which are explained in their own chapter."
msgstr ""

#: ../../yul.rst:515 948fd043e38142e6b55b1a9ad142462b
msgid "Restrictions on the Grammar"
msgstr ""

#: ../../yul.rst:517 a24506eaffdf4377821063da5c3324b3
msgid "Apart from those directly imposed by the grammar, the following restrictions apply:"
msgstr ""

#: ../../yul.rst:520 3167afcb2036411f96b8679193c92556
msgid "Switches must have at least one case (including the default case). All case values need to have the same type and distinct values. If all possible values of the expression type are covered, a default case is not allowed (i.e. a switch with a ``bool`` expression that has both a true and a false case do not allow a default case)."
msgstr ""

#: ../../yul.rst:526 0539a82f4cd046a8bdb1359709b8d384
msgid "Every expression evaluates to zero or more values. Identifiers and Literals evaluate to exactly one value and function calls evaluate to a number of values equal to the number of return variables of the function called."
msgstr ""

#: ../../yul.rst:531 ba052e5a8cf24adfbfb03b4596d85c2f
msgid "In variable declarations and assignments, the right-hand-side expression (if present) has to evaluate to a number of values equal to the number of variables on the left-hand-side. This is the only situation where an expression evaluating to more than one value is allowed. The same variable name cannot occur more than once in the left-hand-side of an assignment or variable declaration."
msgstr ""

#: ../../yul.rst:539 448c871defc44e6788f05b3137804358
msgid "Expressions that are also statements (i.e. at the block level) have to evaluate to zero values."
msgstr ""

#: ../../yul.rst:542 4c67916f59d94f148e874c5191d2b326
msgid "In all other situations, expressions have to evaluate to exactly one value."
msgstr ""

#: ../../yul.rst:544 e1c0ca912ade4ce4826f7708af8b0d42
msgid "A ``continue`` or ``break`` statement can only be used inside the body of a for-loop, as follows. Consider the innermost loop that contains the statement. The loop and the statement must be in the same function, or both must be at the top level. The statement must be in the loop's body block; it cannot be in the loop's initialization block or update block. It is worth emphasizing that this restriction applies just to the innermost loop that contains the ``continue`` or ``break`` statement: this innermost loop, and therefore the ``continue`` or ``break`` statement, may appear anywhere in an outer loop, possibly in an outer loop's initialization block or update block. For example, the following is legal, because the ``break`` occurs in the body block of the inner loop, despite also occurring in the update block of the outer loop:"
msgstr ""

#: ../../yul.rst:563 0ca006150c5547a28ddc36ef03420efd
msgid "The condition part of the for-loop has to evaluate to exactly one value."
msgstr ""

#: ../../yul.rst:565 9f88117cc98c40b2a558aa3d1f98359f
msgid "The ``leave`` statement can only be used inside a function."
msgstr ""

#: ../../yul.rst:567 9563d7ec31ec4d678046687a11915011
msgid "Functions cannot be defined anywhere inside for loop init blocks."
msgstr ""

#: ../../yul.rst:569 ecd34b3f62d34848895c6cac787af52d
msgid "Literals cannot be larger than their type. The largest type defined is 256-bit wide."
msgstr ""

#: ../../yul.rst:571 1779e997325e4518b01a2fcdf6ac4726
msgid "During assignments and function calls, the types of the respective values have to match. There is no implicit type conversion. Type conversion in general can only be achieved if the dialect provides an appropriate built-in function that takes a value of one type and returns a value of a different type."
msgstr ""

#: ../../yul.rst:577 136eddeeec254511b39a0ebb7641dbd0
msgid "Scoping Rules"
msgstr ""

#: ../../yul.rst:579 060c5517650f4c978d1f333c92514f50
msgid "Scopes in Yul are tied to Blocks (exceptions are functions and the for loop as explained below) and all declarations (``FunctionDefinition``, ``VariableDeclaration``) introduce new identifiers into these scopes."
msgstr ""

#: ../../yul.rst:584 4acd43fd993045218c8166e64312dea3
msgid "Identifiers are visible in the block they are defined in (including all sub-nodes and sub-blocks): Functions are visible in the whole block (even before their definitions) while variables are only visible starting from the statement after the ``VariableDeclaration``."
msgstr ""

#: ../../yul.rst:589 c317d5efd0094c60b0347da54f254611
msgid "In particular, variables cannot be referenced in the right hand side of their own variable declaration. Functions can be referenced already before their declaration (if they are visible)."
msgstr ""

#: ../../yul.rst:594 f9d910edab644223a42911a9183ce38b
msgid "As an exception to the general scoping rule, the scope of the \"init\" part of the for-loop (the first block) extends across all other parts of the for loop. This means that variables (and functions) declared in the init part (but not inside a block inside the init part) are visible in all other parts of the for-loop."
msgstr ""

#: ../../yul.rst:599 f675e90aa03d446abc66a135cb9c1e0b
msgid "Identifiers declared in the other parts of the for loop respect the regular syntactical scoping rules."
msgstr ""

#: ../../yul.rst:602 ff7f724a619f4d07bd07493f131af4e8
msgid "This means a for-loop of the form ``for { I... } C { P... } { B... }`` is equivalent to ``{ I... for {} C { P... } { B... } }``."
msgstr ""

#: ../../yul.rst:605 cfcb3d92533b48cd8e327f6d87a43a5c
msgid "The parameters and return parameters of functions are visible in the function body and their names have to be distinct."
msgstr ""

#: ../../yul.rst:608 8438164ea4f14650830ef0cc6a8ef52a
msgid "Inside functions, it is not possible to reference a variable that was declared outside of that function."
msgstr ""

#: ../../yul.rst:611 ec618cf0a3324da3abeb26188029e774
msgid "Shadowing is disallowed, i.e. you cannot declare an identifier at a point where another identifier with the same name is also visible, even if it is not possible to reference it because it was declared outside the current function."
msgstr ""

#: ../../yul.rst:616 69d3d80d834943278966fba4e44457e7
msgid "Formal Specification"
msgstr ""

#: ../../yul.rst:618 a9599611e06a4942abe68836e7e76879
msgid "We formally specify Yul by providing an evaluation function E overloaded on the various nodes of the AST. As builtin functions can have side effects, E takes two state objects and the AST node and returns two new state objects and a variable number of other values. The two state objects are the global state object (which in the context of the EVM is the memory, storage and state of the blockchain) and the local state object (the state of local variables, i.e. a segment of the stack in the EVM)."
msgstr ""

#: ../../yul.rst:627 4511182dfb394e0d9a791467181cfd80
msgid "If the AST node is a statement, E returns the two state objects and a \"mode\", which is used for the ``break``, ``continue`` and ``leave`` statements. If the AST node is an expression, E returns the two state objects and as many values as the expression evaluates to."
msgstr ""

#: ../../yul.rst:633 53f9b9a7fc76490fbacaaaa56d886ee0
msgid "The exact nature of the global state is unspecified for this high level description. The local state ``L`` is a mapping of identifiers ``i`` to values ``v``, denoted as ``L[i] = v``."
msgstr ""

#: ../../yul.rst:637 5ae03d69da8b487582a94b554dd38002
msgid "For an identifier ``v``, let ``$v`` be the name of the identifier."
msgstr ""

#: ../../yul.rst:639 5533b13cbbab421ebe0e342502309ac3
msgid "We will use a destructuring notation for the AST nodes."
msgstr ""

#: ../../yul.rst:744 d6bd408dd08c44038c29b676db38fed5
msgid "EVM Dialect"
msgstr ""

#: ../../yul.rst:746 b666d462aaca42fd95e3194d5d09db25
msgid "The default dialect of Yul currently is the EVM dialect for the currently selected version of the EVM. with a version of the EVM. The only type available in this dialect is ``u256``, the 256-bit native type of the Ethereum Virtual Machine. Since it is the default type of this dialect, it can be omitted."
msgstr ""

#: ../../yul.rst:751 e6c07b87773941ddbd92989369ca859c
msgid "The following table lists all builtin functions (depending on the EVM version) and provides a short description of the semantics of the function / opcode. This document does not want to be a full description of the Ethereum virtual machine. Please refer to a different document if you are interested in the precise semantics."
msgstr ""

#: ../../yul.rst:757 6d99858752fb42d9b585a389c822c3ab
msgid "Opcodes marked with ``-`` do not return a result and all others return exactly one value. Opcodes marked with ``F``, ``H``, ``B``, ``C``, ``I`` and ``L`` are present since Frontier, Homestead, Byzantium, Constantinople, Istanbul or London respectively."
msgstr ""

#: ../../yul.rst:761 8af439b7ac324a53928bf19aa8fb9365
msgid "In the following, ``mem[a...b)`` signifies the bytes of memory starting at position ``a`` up to but not including position ``b`` and ``storage[p]`` signifies the storage contents at slot ``p``."
msgstr ""

#: ../../yul.rst:764 20ecac7a35bd468fbe88fe5e7fa3d0cf
msgid "Since Yul manages local variables and control-flow, opcodes that interfere with these features are not available. This includes the ``dup`` and ``swap`` instructions as well as ``jump`` instructions, labels and the ``push`` instructions."
msgstr ""

#: ../../yul.rst:769 c8483ef9f03b4089bb94c89f1a464ec8
msgid "Instruction"
msgstr ""

#: ../../yul.rst:769 4753a1121d894ec8a33fae25807fe7d7
msgid "Explanation"
msgstr ""

#: ../../yul.rst:771 6609ea0d8e0f468a8448da9c377ac856
msgid "stop()"
msgstr ""

#: ../../yul.rst:771 ../../yul.rst:827 ../../yul.rst:831 ../../yul.rst:833
#: ../../yul.rst:837 ../../yul.rst:857 ../../yul.rst:861 ../../yul.rst:865
#: ../../yul.rst:869 ../../yul.rst:901 ../../yul.rst:903 ../../yul.rst:905
#: ../../yul.rst:907 ../../yul.rst:909 ../../yul.rst:911 ../../yul.rst:913
#: ../../yul.rst:915 ../../yul.rst:917 0c30a7a102304faa8f965569c5728810
#: 1dd20779e4af4ceb8a26027667d5099e 2200f39485f34734b6ff9e684e556ba7
#: 43aaadda6d5e4e0daa8f7a1614c01b5d 62e160920b7a4520b2be3718ea23081d
#: 7a30ee0bfe804eec9439030bc991946a 808fe21fa6f045aa9de617dd34b1ee11
#: 81fa17b5c9b547a285d7fde31ce35de0 88ec5215dcd74a58a58b345ab2b050c1
#: a1372d60be9643f5abc6162b932ddf65 beb9afefb0db4e4f94bf11194812584a
#: c39d71e4834145d3beab42043b5d97db e15319950a4a4f52859996fd073053e0
#: e4e2fe0ed0c54f828e64a2064a18284f e7030cc5108541afab3a62e5acd9c9f4
#: e7a7c71232b34291bc4c0ed809489d36 e963173335d644c59379e2ed45124ec3
#: f04a082555a340b1926a2670c0a9ff30
msgid "`-`"
msgstr ""

#: ../../yul.rst:771 ../../yul.rst:773 ../../yul.rst:775 ../../yul.rst:777
#: ../../yul.rst:779 ../../yul.rst:781 ../../yul.rst:783 ../../yul.rst:785
#: ../../yul.rst:787 ../../yul.rst:789 ../../yul.rst:791 ../../yul.rst:793
#: ../../yul.rst:795 ../../yul.rst:797 ../../yul.rst:799 ../../yul.rst:801
#: ../../yul.rst:803 ../../yul.rst:805 ../../yul.rst:807 ../../yul.rst:809
#: ../../yul.rst:817 ../../yul.rst:819 ../../yul.rst:821 ../../yul.rst:823
#: ../../yul.rst:825 ../../yul.rst:827 ../../yul.rst:829 ../../yul.rst:831
#: ../../yul.rst:833 ../../yul.rst:835 ../../yul.rst:837 ../../yul.rst:839
#: ../../yul.rst:841 ../../yul.rst:843 ../../yul.rst:845 ../../yul.rst:849
#: ../../yul.rst:851 ../../yul.rst:853 ../../yul.rst:855 ../../yul.rst:857
#: ../../yul.rst:859 ../../yul.rst:861 ../../yul.rst:863 ../../yul.rst:865
#: ../../yul.rst:873 ../../yul.rst:883 ../../yul.rst:889 ../../yul.rst:901
#: ../../yul.rst:905 ../../yul.rst:907 ../../yul.rst:909 ../../yul.rst:911
#: ../../yul.rst:913 ../../yul.rst:915 ../../yul.rst:917 ../../yul.rst:924
#: ../../yul.rst:926 ../../yul.rst:928 ../../yul.rst:930 ../../yul.rst:932
#: ../../yul.rst:934 ../../yul.rst:936 ../../yul.rst:938
#: 00da712c2d7c4f328aa2faf74f58d956 0177d15b1f48424c9dc45c0bb171ab15
#: 01dbb6f0ff9d4b64800852ab30e6aaba 03ccaa2614564344937e6adfde1275dc
#: 165de3712b964e38953c6fc240202066 186d460e34f44a0b8ce1576a9740bf3e
#: 1c3d93af8f4a44ec8c72fc7cc1a79cd8 1ebd0e15f38d4b088f4a0317fa43a178
#: 228c2ce37d434385bc237cd1c1f0cc90 2296c9c0ab3543718f0717d17a95870b
#: 2614a6e1102a43399731c1ec6101e04c 26bb1607221846f2a971f30cd3565785
#: 2881cfa6c9fe4009945fc762f8a029c9 29ef620fa3274a29b8de4032fae7f4ce
#: 2b7a6b94fdc748cb8e353fc6826200ee 2f7082170065443d86ea6cb2760600f2
#: 3240d58deebd4ea0b233233af19694ec 3262a9e06a474ccdb6bee914c7083242
#: 359869af073f45b9ab1d0926e07eef6c 361916adf5194a97a57aa8b921a143c5
#: 3c27ff4797cd4c0483bb5913939ac6ff 409cf0e00f024e8ba10f20ef8de4bae9
#: 521ba4dc796d42429fd022058f301f80 5373a06500e84e9c8b8dc97f366b750e
#: 55f790c5e7894e3ca68a73f8b1db6c90 57c89f39998a4d0ab5b401a1507df372
#: 59f57de26e3d478aab7d80578a56d2e2 61dde584228d4a619de393e6be3fe082
#: 69726809b29047ecb6ce7191fcd9b2b3 69bd71f2149f4d8589149a71d9e39049
#: 6dee51190d2743d2adee9b1a0a78fb5e 714d5d651060428991214d256eae4de3
#: 738ff09999ea466a8bbca9b06e7a2229 7ce765f546494af0b7f944ec0bb6a756
#: 7f4cc7dfc2194570933d93a5cc02e44f 80aab972e6f84445b9e973027b63bc7c
#: 8a703cf62d5e48f2bcd3caf874864f96 8bc490c439014ed6862b59a9ae7f28ec
#: 8d6a004d8274465e9805c7f306ab48da 975cee71cd514601930101cbf6006c3e
#: 9760e700a40f426b9220c9bda9a4dc6a 9d58b38c05674f28a969412cba9f3bad
#: a568ec73180e40c986a38f6f5e5cddaa a78ce2d456454ddd8e3985f79f79b7e9
#: a9d90080666f432a8c0da4322c7da906 ac6177b968a446ef960aa50ed20317f8
#: acd0ec82a1354df9a91071a4e5c5d82d bc61c2369f7c4f788fdf346f9ef2fc63
#: c6ba568aec3549ae91e85aecab628652 c710471a8ede4e4687e4c84e3bed6143
#: cb5aecd46524470e8b2e52eb1f6f9ad6 cf530363809549708f641949c582a76a
#: d39cb19865ec43978f2b406329a54b5d d97fb5c928c047109445eeda48b21760
#: dc6b540c578c4949900592c4227e82c4 e1569583b87a41f79fe58e4dbf4b96db
#: e1704d87d70b4d4894622cc6efdee2b5 e45865a0f223448fac4b450cf4f417de
#: e5161bd4e25e44878b8fca58b0d981fe e729a7a3eeff437bb57c9e82e6334100
#: e93b353c9dd548d1a37eecbabb3d36e6 e9c9d3ff35a64cf2b06c5d023d462d07
#: f9b19deea2eb4ad3ab0c8404948a813c
msgid "F"
msgstr ""

#: ../../yul.rst:771 99a4571dbc224da0ad5243977cbec9ef
msgid "stop execution, identical to return(0, 0)"
msgstr ""

#: ../../yul.rst:773 f068f1da465d4299ae278a8eb3f04c4d
msgid "add(x, y)"
msgstr ""

#: ../../yul.rst:773 0233737696e64af5b2dfe17e51a89661
msgid "x + y"
msgstr ""

#: ../../yul.rst:775 97fb363ba3234ccdb1f3546ea8e175a2
msgid "sub(x, y)"
msgstr ""

#: ../../yul.rst:775 d43262cd0b3a4a83aa70b1bccb283575
msgid "x - y"
msgstr ""

#: ../../yul.rst:777 29e3749b5f4d41518b3f836ca9219f33
msgid "mul(x, y)"
msgstr ""

#: ../../yul.rst:777 9bdc7acd90614eca8432b11b145a4d19
msgid "x * y"
msgstr ""

#: ../../yul.rst:779 c7a0265c344b4e6bb7beb7e91f5b44e7
msgid "div(x, y)"
msgstr ""

#: ../../yul.rst:779 5cc6d419517144b4a35edf0009e4dc07
msgid "x / y or 0 if y == 0"
msgstr ""

#: ../../yul.rst:781 63776dce0ed14afd80b88a923fa90568
msgid "sdiv(x, y)"
msgstr ""

#: ../../yul.rst:781 f9ad87491f8b4354bd7e19792186dd80
msgid "x / y, for signed numbers in two's complement, 0 if y == 0"
msgstr ""

#: ../../yul.rst:783 e62062211d0b47f0aeb7ee1729bcc528
msgid "mod(x, y)"
msgstr ""

#: ../../yul.rst:783 109b2a06451444cb9178a71bd75f2992
msgid "x % y, 0 if y == 0"
msgstr ""

#: ../../yul.rst:785 5fd458ddc8e6437896efe0b8de2b4e04
msgid "smod(x, y)"
msgstr ""

#: ../../yul.rst:785 234186c69fa9419fb3e0217799c0d0cc
msgid "x % y, for signed numbers in two's complement, 0 if y == 0"
msgstr ""

#: ../../yul.rst:787 50f0b7e603184c3dbd3fe1df7ad7a562
msgid "exp(x, y)"
msgstr ""

#: ../../yul.rst:787 8d475fac268445eabe0a2e92d73c2a14
msgid "x to the power of y"
msgstr ""

#: ../../yul.rst:789 9dd1b5be6814446ca3fe75ef08f35a17
msgid "not(x)"
msgstr ""

#: ../../yul.rst:789 5adc36cc347f4bd6a2868abf15e6acd1
msgid "bitwise \"not\" of x (every bit of x is negated)"
msgstr ""

#: ../../yul.rst:791 78b6404e25e74fcb87cba98be5dec56b
msgid "lt(x, y)"
msgstr ""

#: ../../yul.rst:791 03d0074987e04249a319662ad26ef8aa
msgid "1 if x < y, 0 otherwise"
msgstr ""

#: ../../yul.rst:793 0bb283d58f5e44d3bff94558bee51d33
msgid "gt(x, y)"
msgstr ""

#: ../../yul.rst:793 d58996ce7b8d4e4db81911be3e5b509f
msgid "1 if x > y, 0 otherwise"
msgstr ""

#: ../../yul.rst:795 d9b0fb8903524fe68d3d29efb8e24f6d
msgid "slt(x, y)"
msgstr ""

#: ../../yul.rst:795 2ac6536852034b45a874e01e3e15f6eb
msgid "1 if x < y, 0 otherwise, for signed numbers in two's complement"
msgstr ""

#: ../../yul.rst:797 792a53e0c04c4e83a57a1481f9bafdee
msgid "sgt(x, y)"
msgstr ""

#: ../../yul.rst:797 02728927d5d741c296993434afebceeb
msgid "1 if x > y, 0 otherwise, for signed numbers in two's complement"
msgstr ""

#: ../../yul.rst:799 16c3275b8cd444b19375f8ee981597f7
msgid "eq(x, y)"
msgstr ""

#: ../../yul.rst:799 d9fd977a6b2645c4b7ac0c4b26acc8ee
msgid "1 if x == y, 0 otherwise"
msgstr ""

#: ../../yul.rst:801 7eb5886027694f1d89dd95bf58ed694d
msgid "iszero(x)"
msgstr ""

#: ../../yul.rst:801 da94230c525a414ba79c122739ecea6c
msgid "1 if x == 0, 0 otherwise"
msgstr ""

#: ../../yul.rst:803 c5eb443a08e2490b85d775d2bfd78d8c
msgid "and(x, y)"
msgstr ""

#: ../../yul.rst:803 7c02c5a9951d45cdb7048c1a3ea0f6e8
msgid "bitwise \"and\" of x and y"
msgstr ""

#: ../../yul.rst:805 4452ef92c91541ae81175e1aec5fddeb
msgid "or(x, y)"
msgstr ""

#: ../../yul.rst:805 187e5f10812747239d7b0c817e98c28a
msgid "bitwise \"or\" of x and y"
msgstr ""

#: ../../yul.rst:807 e6e914b97b014dca9a855d21fcc9e92b
msgid "xor(x, y)"
msgstr ""

#: ../../yul.rst:807 754b39d7171845a3a620bc868b6188c1
msgid "bitwise \"xor\" of x and y"
msgstr ""

#: ../../yul.rst:809 0abf37774b7444f7b9d2c7a3f7c055cf
msgid "byte(n, x)"
msgstr ""

#: ../../yul.rst:809 2d921edcf723400bb46046539b7f232c
msgid "nth byte of x, where the most significant byte is the 0th byte"
msgstr ""

#: ../../yul.rst:811 2d51c855f7af49428bcd6e460ec6233f
msgid "shl(x, y)"
msgstr ""

#: ../../yul.rst:811 ../../yul.rst:813 ../../yul.rst:815 ../../yul.rst:871
#: ../../yul.rst:876 50fa1bb469014e359d70d9c25c5e1882
#: 9befc1d104124ef2bd4e8fc1157002aa d6cea737aa9643d78627e3164706936e
#: db03d10764844d3d8bbddb996b8cf0ed e7adaf8124cb4b0097766e13b1dec561
msgid "C"
msgstr ""

#: ../../yul.rst:811 8cc3e0cb1b5b4d1a82c6ce52d1fab14f
msgid "logical shift left y by x bits"
msgstr ""

#: ../../yul.rst:813 62e8a16286294be69d5e642d61796da8
msgid "shr(x, y)"
msgstr ""

#: ../../yul.rst:813 27c44c59a147498fb0aebd05a2c681ff
msgid "logical shift right y by x bits"
msgstr ""

#: ../../yul.rst:815 3139e54824d54307b0892d0e35fcd6de
msgid "sar(x, y)"
msgstr ""

#: ../../yul.rst:815 f89df65acf3a4800966b93a927674d52
msgid "signed arithmetic shift right y by x bits"
msgstr ""

#: ../../yul.rst:817 3509bb245880453a99d82ea014d103b9
msgid "addmod(x, y, m)"
msgstr ""

#: ../../yul.rst:817 e17508fb21bf48b0a5ba9031b05aadeb
msgid "(x + y) % m with arbitrary precision arithmetic, 0 if m == 0"
msgstr ""

#: ../../yul.rst:819 31f1c614e3ae463eb72cdc8c9753858c
msgid "mulmod(x, y, m)"
msgstr ""

#: ../../yul.rst:819 de5f14556a1e43a0aa9d55371c62b5b7
msgid "(x * y) % m with arbitrary precision arithmetic, 0 if m == 0"
msgstr ""

#: ../../yul.rst:821 2a8b279ff1b848e8a289cd6b7a13ba8f
msgid "signextend(i, x)"
msgstr ""

#: ../../yul.rst:821 aabaefc9354847c381c874a9f208c4a2
msgid "sign extend from (i*8+7)th bit counting from least significant"
msgstr ""

#: ../../yul.rst:823 471d4de5b5cd4c8c918926603ab2d28b
msgid "keccak256(p, n)"
msgstr ""

#: ../../yul.rst:823 5f2ac869fea24c5f8473a76eb5c3627b
msgid "keccak(mem[p...(p+n)))"
msgstr ""

#: ../../yul.rst:825 6438b5f43fb24704900e38495cb10159
msgid "pc()"
msgstr ""

#: ../../yul.rst:825 799a5dc2bb1b44059ca5380f081b33ef
msgid "current position in code"
msgstr ""

#: ../../yul.rst:827 c39712d7057c4205b35bb705cb819999
msgid "pop(x)"
msgstr ""

#: ../../yul.rst:827 d522fb2764ab459cbca20d28c0547c87
msgid "discard value x"
msgstr ""

#: ../../yul.rst:829 755cf5db2ded477f9f3abd02938917ee
msgid "mload(p)"
msgstr ""

#: ../../yul.rst:829 e06680e7ee274aef94eae0becf01204c
msgid "mem[p...(p+32))"
msgstr ""

#: ../../yul.rst:831 2ad59fe88a704d03a7398d5e62e780e2
msgid "mstore(p, v)"
msgstr ""

#: ../../yul.rst:831 0f1ca328b7af49d1ae3100317321c1ca
msgid "mem[p...(p+32)) := v"
msgstr ""

#: ../../yul.rst:833 af6a078317e54449bb214949a6798835
msgid "mstore8(p, v)"
msgstr ""

#: ../../yul.rst:833 d6fdc082576a4e88a64448cb8db42c47
msgid "mem[p] := v & 0xff (only modifies a single byte)"
msgstr ""

#: ../../yul.rst:835 4d18579c6bee4c8293d618c5e5fc6a85
msgid "sload(p)"
msgstr ""

#: ../../yul.rst:835 c02d18fe838147ef98603e7dc9531071
msgid "storage[p]"
msgstr ""

#: ../../yul.rst:837 ff38ec36978942118c3b206296ac52bc
msgid "sstore(p, v)"
msgstr ""

#: ../../yul.rst:837 549eedccf07b4af1a3d76505991f1e16
msgid "storage[p] := v"
msgstr ""

#: ../../yul.rst:839 002520d24dfc4b23845305a9d9a14ef0
msgid "msize()"
msgstr ""

#: ../../yul.rst:839 129de22d4d904dffbe2be05dec15589a
msgid "size of memory, i.e. largest accessed memory index"
msgstr ""

#: ../../yul.rst:841 e7131dbe7ef044dbb498d6f82d086543
msgid "gas()"
msgstr ""

#: ../../yul.rst:841 7e2c705ae83e4c1aaad9b2b8e1636188
msgid "gas still available to execution"
msgstr ""

#: ../../yul.rst:843 313f2082973d4241be66270f97e9528a
msgid "address()"
msgstr ""

#: ../../yul.rst:843 9e17233c65b14b759415befbdd7ba2dc
msgid "address of the current contract / execution context"
msgstr ""

#: ../../yul.rst:845 a4871320d8f94e5c939fd720910ee46e
msgid "balance(a)"
msgstr ""

#: ../../yul.rst:845 07ed91c4bfa54820a54b5435168cff34
msgid "wei balance at address a"
msgstr ""

#: ../../yul.rst:847 037fb86aabb94deb960b5d1fc3e657f5
msgid "selfbalance()"
msgstr ""

#: ../../yul.rst:847 ../../yul.rst:920 400e23062374412ca281a027b35e61d8
#: 47fa3e684ee44daf99e6e8caf35ea22a
msgid "I"
msgstr ""

#: ../../yul.rst:847 f2fc7eeb2ec841c090b214c8b701d007
msgid "equivalent to balance(address()), but cheaper"
msgstr ""

#: ../../yul.rst:849 4a976c4da5d24ed58c26327ea8d839b0
msgid "caller()"
msgstr ""

#: ../../yul.rst:849 73c0d689dfa94b22b35c986230f254bf
msgid "call sender (excluding ``delegatecall``)"
msgstr ""

#: ../../yul.rst:851 c0b696e17d3c46c3affafd7b29326457
msgid "callvalue()"
msgstr ""

#: ../../yul.rst:851 e11866fa16a1494abe5f2b56800410d1
msgid "wei sent together with the current call"
msgstr ""

#: ../../yul.rst:853 f0cb39bf52ff440aa15e082aa28f54ee
msgid "calldataload(p)"
msgstr ""

#: ../../yul.rst:853 2af98ee328a848a5bf10472434a33543
msgid "call data starting from position p (32 bytes)"
msgstr ""

#: ../../yul.rst:855 bd684c624b804451b0e26c7f36aefcb8
msgid "calldatasize()"
msgstr ""

#: ../../yul.rst:855 48b7d71fc25a4422a89aacfdefec9b0f
msgid "size of call data in bytes"
msgstr ""

#: ../../yul.rst:857 cdbe8b652c51403bb28dacc8fc30c4e3
msgid "calldatacopy(t, f, s)"
msgstr ""

#: ../../yul.rst:857 c02228915a054ea8b6ce8e0ab8fa3f95
msgid "copy s bytes from calldata at position f to mem at position t"
msgstr ""

#: ../../yul.rst:859 5848185a2a5d45a79de789ec2d1b67a1
msgid "codesize()"
msgstr ""

#: ../../yul.rst:859 84e6e72fc6b945649e52064074e921fa
msgid "size of the code of the current contract / execution context"
msgstr ""

#: ../../yul.rst:861 bd84b27c70f94c2694a519e7a7e63973
msgid "codecopy(t, f, s)"
msgstr ""

#: ../../yul.rst:861 d7b3becb73ea4f9583ed7f92a59da8e7
msgid "copy s bytes from code at position f to mem at position t"
msgstr ""

#: ../../yul.rst:863 d5fb73311ad74b7584a30339e64ba818
msgid "extcodesize(a)"
msgstr ""

#: ../../yul.rst:863 58caa1841f254dfdb8ee82098013eda8
msgid "size of the code at address a"
msgstr ""

#: ../../yul.rst:865 1b80910d0cd94f659aa285d62e972de6
msgid "extcodecopy(a, t, f, s)"
msgstr ""

#: ../../yul.rst:865 af9af12f4a7e41ea8dc435d04063e90d
msgid "like codecopy(t, f, s) but take code at address a"
msgstr ""

#: ../../yul.rst:867 5e3feaebb5054782b4ed242c0913b5e2
msgid "returndatasize()"
msgstr ""

#: ../../yul.rst:867 ../../yul.rst:869 ../../yul.rst:897 ../../yul.rst:903
#: 66fb7879519a4a848f29fa02081650dd af09eb6abc034d839da2311662e58fd5
#: b686082fca6347f384f891eb2bf80915 ea4e5ef21bc1445594760b75fc0046f6
msgid "B"
msgstr ""

#: ../../yul.rst:867 984f606daf4841bfaee277b0b7fe5534
msgid "size of the last returndata"
msgstr ""

#: ../../yul.rst:869 9eebc0783aec4291981ae739707aacdd
msgid "returndatacopy(t, f, s)"
msgstr ""

#: ../../yul.rst:869 308a0d54c7804c1ba0d5b106e02ef1c4
msgid "copy s bytes from returndata at position f to mem at position t"
msgstr ""

#: ../../yul.rst:871 08e1dd570e41406f81663df3e8cd2efe
msgid "extcodehash(a)"
msgstr ""

#: ../../yul.rst:871 eea4c884ef7142d7a17b0df6ebe39030
msgid "code hash of address a"
msgstr ""

#: ../../yul.rst:873 ac7fc10fda4446889ee335e38d67e7c9
msgid "create(v, p, n)"
msgstr ""

#: ../../yul.rst:873 59c32e01b8e8404c8c7f5341f2cd1cce
msgid "create new contract with code mem[p...(p+n)) and send v wei and return the new address; returns 0 on error"
msgstr ""

#: ../../yul.rst:876 50001a5f7c8c4815a524d7aa325a2ed5
msgid "create2(v, p, n, s)"
msgstr ""

#: ../../yul.rst:876 a4b9776f62574d8dbd2bae3e57b6d482
msgid "create new contract with code mem[p...(p+n)) at address keccak256(0xff . this . s . keccak256(mem[p...(p+n))) and send v wei and return the new address, where ``0xff`` is a 1 byte value, ``this`` is the current contract's address as a 20 byte value and ``s`` is a big-endian 256-bit value; returns 0 on error"
msgstr ""

#: ../../yul.rst:883 f720187cef1f4505b726351ad6cbbbb1
msgid "call(g, a, v, in, insize, out, outsize)"
msgstr ""

#: ../../yul.rst:883 abdfb13bedfd4005b47b03eeba47436d
msgid "call contract at address a with input mem[in...(in+insize)) providing g gas and v wei and output area mem[out...(out+outsize)) returning 0 on error (eg. out of gas) and 1 on success :ref:`See more <yul-call-return-area>`"
msgstr ""

#: ../../yul.rst:889 4eb9f986586045709a5ca2aa85796404
msgid "callcode(g, a, v, in, insize, out, outsize)"
msgstr ""

#: ../../yul.rst:889 3d558ef2b4d849eaaa90f49ed2976ef2
msgid "identical to ``call`` but only use the code from a and stay in the context of the current contract otherwise :ref:`See more <yul-call-return-area>`"
msgstr ""

#: ../../yul.rst:893 d73bd3e3d1ba40c4939345fc268255f3
msgid "delegatecall(g, a, in, insize, out, outsize)"
msgstr ""

#: ../../yul.rst:893 7dd1f17e6c38488ab894b379e9c5af8f
msgid "H"
msgstr ""

#: ../../yul.rst:893 d008fb0c60414356ab0e2414c22b4d70
msgid "identical to ``callcode`` but also keep ``caller`` and ``callvalue`` :ref:`See more <yul-call-return-area>`"
msgstr ""

#: ../../yul.rst:897 c0f85a8272c24c208ddb4629349e3a5b
msgid "staticcall(g, a, in, insize, out, outsize)"
msgstr ""

#: ../../yul.rst:897 5716abb7d1ce4e389a28851517b4d950
msgid "identical to ``call(g, a, 0, in, insize, out, outsize)`` but do not allow state modifications :ref:`See more <yul-call-return-area>`"
msgstr ""

#: ../../yul.rst:901 d07cae7a41ff401dae2d9014d2a98365
msgid "return(p, s)"
msgstr ""

#: ../../yul.rst:901 f19684e99b024e569dbc1b2b4337c5a8
msgid "end execution, return data mem[p...(p+s))"
msgstr ""

#: ../../yul.rst:903 38fa60acee5f4c9f8ef4ad30121137d5
msgid "revert(p, s)"
msgstr ""

#: ../../yul.rst:903 3a0b1be0b6594f98aec6f7dc4c0d24dd
msgid "end execution, revert state changes, return data mem[p...(p+s))"
msgstr ""

#: ../../yul.rst:905 60995567d3364df6be98d5acd9bb12ae
msgid "selfdestruct(a)"
msgstr ""

#: ../../yul.rst:905 c4dfa39e5fe745bc8b5cf0173dc9cc16
msgid "end execution, destroy current contract and send funds to a"
msgstr ""

#: ../../yul.rst:907 ac10ada317cb4c9aa41c48e323dc7fee
msgid "invalid()"
msgstr ""

#: ../../yul.rst:907 cc76ed2744bf4d4fabd9dfadd1098252
msgid "end execution with invalid instruction"
msgstr ""

#: ../../yul.rst:909 46318582b7ee430990c3c91aa8a07571
msgid "log0(p, s)"
msgstr ""

#: ../../yul.rst:909 71a472bce0664c7895bbd7829840129f
msgid "log without topics and data mem[p...(p+s))"
msgstr ""

#: ../../yul.rst:911 51390dffbe6c40ff8cbcb33bd3d8dffd
msgid "log1(p, s, t1)"
msgstr ""

#: ../../yul.rst:911 8fd5cedec06d42e998916c92ae34716f
msgid "log with topic t1 and data mem[p...(p+s))"
msgstr ""

#: ../../yul.rst:913 438740e6794a47968c0f940701d202da
msgid "log2(p, s, t1, t2)"
msgstr ""

#: ../../yul.rst:913 a1389a4cfef74e5b8cf6b46936d7a0fb
msgid "log with topics t1, t2 and data mem[p...(p+s))"
msgstr ""

#: ../../yul.rst:915 1dd95aab24894cd29d84fd42a33c8569
msgid "log3(p, s, t1, t2, t3)"
msgstr ""

#: ../../yul.rst:915 5facf2d3a588414ca5da01dde1dda910
msgid "log with topics t1, t2, t3 and data mem[p...(p+s))"
msgstr ""

#: ../../yul.rst:917 e685a42ab8ee44e59326f237b3ad83da
msgid "log4(p, s, t1, t2, t3, t4)"
msgstr ""

#: ../../yul.rst:917 0549ab19aec743fba5aa0c6cf5a86e60
msgid "log with topics t1, t2, t3, t4 and data mem[p...(p+s))"
msgstr ""

#: ../../yul.rst:920 9123c69830ac49888b60bf376db85787
msgid "chainid()"
msgstr ""

#: ../../yul.rst:920 6f1e3d989cd649a6800d32590bb08a4b
msgid "ID of the executing chain (EIP-1344)"
msgstr ""

#: ../../yul.rst:922 086b9227d75e4a449a4d0e5dd54e6955
msgid "basefee()"
msgstr ""

#: ../../yul.rst:922 64e656c30f5742f38ae41e13e186e310
msgid "L"
msgstr ""

#: ../../yul.rst:922 5926198213184f929839747c2d0da9f7
msgid "current block's base fee (EIP-3198 and EIP-1559)"
msgstr ""

#: ../../yul.rst:924 195d577c4a934d37bc1465f80e0937ca
msgid "origin()"
msgstr ""

#: ../../yul.rst:924 043c253eb7554abd9fc9034a2ccffab9
msgid "transaction sender"
msgstr ""

#: ../../yul.rst:926 9386427790ae4851b885af11d158f753
msgid "gasprice()"
msgstr ""

#: ../../yul.rst:926 467632d08d5a443abce878d23b9e1809
msgid "gas price of the transaction"
msgstr ""

#: ../../yul.rst:928 eed75069558c47cf8a56ecc24ceefaa8
msgid "blockhash(b)"
msgstr ""

#: ../../yul.rst:928 9ade0ca14a00493984536479eee237fe
msgid "hash of block nr b - only for last 256 blocks excluding current"
msgstr ""

#: ../../yul.rst:930 13d64398ccb74a03b706ee48d9ee3b57
msgid "coinbase()"
msgstr ""

#: ../../yul.rst:930 ee3ab3eb9ddc46aebd2ed5dad46113f4
msgid "current mining beneficiary"
msgstr ""

#: ../../yul.rst:932 8be25e06d5da4c35982e6f94bda8635f
msgid "timestamp()"
msgstr ""

#: ../../yul.rst:932 4bd5cc3bfbea45729566878738edb9ce
msgid "timestamp of the current block in seconds since the epoch"
msgstr ""

#: ../../yul.rst:934 bb078753bf624f90a61ee41fe0ce81dc
msgid "number()"
msgstr ""

#: ../../yul.rst:934 3875b1f2032344a585ad8f378983ec2f
msgid "current block number"
msgstr ""

#: ../../yul.rst:936 ba4363b0b0ea497ca2c885c837faba77
msgid "difficulty()"
msgstr ""

#: ../../yul.rst:936 2f07fb6e918e424db607676f283cf806
msgid "difficulty of the current block"
msgstr ""

#: ../../yul.rst:938 f41af3b472494b23a16f77ce1ab23c0a
msgid "gaslimit()"
msgstr ""

#: ../../yul.rst:938 7936b7008e974bf58a9b93186c91a838
msgid "block gas limit of the current block"
msgstr ""

#: ../../yul.rst:944 ba778f862ace41c389feab5ad06ea0bd
msgid "The ``call*`` instructions use the ``out`` and ``outsize`` parameters to define an area in memory where the return or failure data is placed. This area is written to depending on how many bytes the called contract returns. If it returns more data, only the first ``outsize`` bytes are written. You can access the rest of the data using the ``returndatacopy`` opcode. If it returns less data, then the remaining bytes are not touched at all. You need to use the ``returndatasize`` opcode to check which part of this memory area contains the return data. The remaining bytes will retain their values as of before the call."
msgstr ""

#: ../../yul.rst:952 cd9cbcff025442ed9126f9d1a49c7996
msgid "In some internal dialects, there are additional functions:"
msgstr ""

#: ../../yul.rst:955 96cc49bfe50243f3913f9e0729c46784
msgid "datasize, dataoffset, datacopy"
msgstr ""

#: ../../yul.rst:957 df621a9f11cb4e348929c276ee1193af
msgid "The functions ``datasize(x)``, ``dataoffset(x)`` and ``datacopy(t, f, l)`` are used to access other parts of a Yul object."
msgstr ""

#: ../../yul.rst:960 906efce9953f4444bdb196199a612582
msgid "``datasize`` and ``dataoffset`` can only take string literals (the names of other objects) as arguments and return the size and offset in the data area, respectively. For the EVM, the ``datacopy`` function is equivalent to ``codecopy``."
msgstr ""

#: ../../yul.rst:966 c6af840949284e7ab085af8264297cc2
msgid "setimmutable, loadimmutable"
msgstr ""

#: ../../yul.rst:968 7ed6c4e742104b868645ffdd4adad432
msgid "The functions ``setimmutable(offset, \"name\", value)`` and ``loadimmutable(\"name\")`` are used for the immutable mechanism in Solidity and do not nicely map to pure Yul. The call to ``setimmutable(offset, \"name\", value)`` assumes that the runtime code of the contract containing the given named immutable was copied to memory at offset ``offset`` and will write ``value`` to all positions in memory (relative to ``offset``) that contain the placeholder that was generated for calls to ``loadimmutable(\"name\")`` in the runtime code."
msgstr ""

#: ../../yul.rst:977 3baad63caa7d4ebe84801cd3bdebd994
msgid "linkersymbol"
msgstr ""

#: ../../yul.rst:978 69f7ffeae0954115a5a8e5226b1ef833
msgid "The function ``linkersymbol(\"library_id\")`` is a placeholder for an address literal to be substituted by the linker. Its first and only argument must be a string literal and uniquely represents the address to be inserted. Identifiers can be arbitrary but when the compiler produces Yul code from Solidity sources, it uses a library name qualified with the name of the source unit that defines that library. To link the code with a particular library address, the same identifier must be provided to the ``--libraries`` option on the command line."
msgstr ""

#: ../../yul.rst:986 9d83dbaf9718482aa5b7ff26b633c0fc
msgid "For example this code"
msgstr ""

#: ../../yul.rst:992 be1f12848c28411084823883a16ecb54
msgid "is equivalent to"
msgstr ""

#: ../../yul.rst:998 652e393218fc44679e78d18344e14079
msgid "when the linker is invoked with ``--libraries \"file.sol:Math=0x1234567890123456789012345678901234567890`` option."
msgstr ""

#: ../../yul.rst:1001 56e56405deec47d5a84d62c98f6b6133
msgid "See :ref:`Using the Commandline Compiler <commandline-compiler>` for details about the Solidity linker."
msgstr ""

#: ../../yul.rst:1004 db5ade65c4384a0db0965fda06b426b5
msgid "memoryguard"
msgstr ""

#: ../../yul.rst:1006 53780445f20d4d7aaed8696d227c93f8
msgid "This function is available in the EVM dialect with objects. The caller of ``let ptr := memoryguard(size)`` (where ``size`` has to be a literal number) promises that they only use memory in either the range ``[0, size)`` or the unbounded range starting at ``ptr``."
msgstr ""

#: ../../yul.rst:1011 0092d710b26a47d887468867273f0d14
msgid "Since the presence of a ``memoryguard`` call indicates that all memory access adheres to this restriction, it allows the optimizer to perform additional optimization steps, for example the stack limit evader, which attempts to move stack variables that would otherwise be unreachable to memory."
msgstr ""

#: ../../yul.rst:1016 2e3e075ec08c4cbb8cbfd83c35b40452
msgid "The Yul optimizer promises to only use the memory range ``[size, ptr)`` for its purposes. If the optimizer does not need to reserve any memory, it holds that ``ptr == size``."
msgstr ""

#: ../../yul.rst:1019 abd74fbe6de046958b77d92f584a27ef
msgid "``memoryguard`` can be called multiple times, but needs to have the same literal as argument within one Yul subobject. If at least one ``memoryguard`` call is found in a subobject, the additional optimiser steps will be run on it."
msgstr ""

#: ../../yul.rst:1027 4f696754e1d44c3ea2dc4c682bfc3dcf
msgid "verbatim"
msgstr ""

#: ../../yul.rst:1029 dc52f97a3df64db08ea0381b80df9db8
msgid "The set of ``verbatim...`` builtin functions lets you create bytecode for opcodes that are not known to the Yul compiler. It also allows you to create bytecode sequences that will not be modified by the optimizer."
msgstr ""

#: ../../yul.rst:1033 21659a36e816479e96705be41e35a960
msgid "The functions are ``verbatim_<n>i_<m>o(\"<data>\", ...)``, where"
msgstr ""

#: ../../yul.rst:1035 690b2813aee7459082b4a686694c182c
msgid "``n`` is a decimal between 0 and 99 that specifies the number of input stack slots / variables"
msgstr ""

#: ../../yul.rst:1036 764c30e26a07423a816e3f56ea11a7a0
msgid "``m`` is a decimal between 0 and 99 that specifies the number of output stack slots / variables"
msgstr ""

#: ../../yul.rst:1037 552a1d4179d24d679f6a39f1f6ac91b4
msgid "``data`` is a string literal that contains the sequence of bytes"
msgstr ""

#: ../../yul.rst:1039 cf3cea7c1c20417b88773c121907e05f
msgid "If you for example want to define a function that multiplies the input by two, without the optimizer touching the constant two, you can use"
msgstr ""

#: ../../yul.rst:1047 26183a38b36c43d4aab4f5f9d3c3c5ae
msgid "This code will result in a ``dup1`` opcode to retrieve ``x`` (the optimizer might directly re-use result of the ``calldataload`` opcode, though) directly followed by ``600202``. The code is assumed to consume the copied value of ``x`` and produce the result on the top of the stack. The compiler then generates code to allocate a stack slot for ``double`` and store the result there."
msgstr ""

#: ../../yul.rst:1055 580bc77fc1314276902ffdee0ac5b92c
msgid "As with all opcodes, the arguments are arranged on the stack with the leftmost argument on the top, while the return values are assumed to be laid out such that the rightmost variable is at the top of the stack."
msgstr ""

#: ../../yul.rst:1060 80d87263c75e466baa8a6d1fad66cf1a
msgid "Since ``verbatim`` can be used to generate arbitrary opcodes or even opcodes unknown to the Solidity compiler, care has to be taken when using ``verbatim`` together with the optimizer. Even when the optimizer is switched off, the code generator has to determine the stack layout, which means that e.g. using ``verbatim`` to modify the stack height can lead to undefined behaviour."
msgstr ""

#: ../../yul.rst:1067 e820a0a3159147d4b726a41af66f80d5
msgid "The following is a non-exhaustive list of restrictions on verbatim bytecode that are not checked by the compiler. Violations of these restrictions can result in undefined behaviour."
msgstr ""

#: ../../yul.rst:1072 8880d03b31014fb4b9df8a3f6d5e33d9
msgid "Control-flow should not jump into or out of verbatim blocks, but it can jump within the same verbatim block."
msgstr ""

#: ../../yul.rst:1074 a1981195619c4fe0afece236f6bc67a5
msgid "Stack contents apart from the input and output parameters should not be accessed."
msgstr ""

#: ../../yul.rst:1076 c31fe4d6e10d4d2c8b05a7c82f67dbe7
msgid "The stack height difference should be exactly ``m - n`` (output slots minus input slots)."
msgstr ""

#: ../../yul.rst:1078 c7bce5db12f14bcab898bc6ec7d3262c
msgid "Verbatim bytecode cannot make any assumptions about the surrounding bytecode. All required parameters have to be passed in as stack variables."
msgstr ""

#: ../../yul.rst:1082 5f84a93b528941a9be7d574c949c7312
msgid "The optimizer does not analyze verbatim bytecode and always assumes that it modifies all aspects of state and thus can only do very few optimizations across ``verbatim`` function calls."
msgstr ""

#: ../../yul.rst:1086 2765c1780a1a49c5a4c5a7f8c3d56d05
msgid "The optimizer treats verbatim bytecode as an opaque block of code. It will not split it but might move, duplicate or combine it with identical verbatim bytecode blocks. If a verbatim bytecode block is unreachable by the control-flow, it can be removed."
msgstr ""

#: ../../yul.rst:1095 a6590b7c885b48f49cb7fbff6737bfe8
msgid "During discussions about whether or not EVM improvements might break existing smart contracts, features inside ``verbatim`` cannot receive the same consideration as those used by the Solidity compiler itself."
msgstr ""

#: ../../yul.rst:1102 9f44a4820d7e43bfad4f5e7fc4c247a1
msgid "To avoid confusion, all identifiers starting with the string ``verbatim`` are reserved and cannot be used for user-defined identifiers."
msgstr ""

#: ../../yul.rst:1108 7c8a82b233a5484db49606b25a1ca316
msgid "Specification of Yul Object"
msgstr ""

#: ../../yul.rst:1110 88a636b5e4724d9eb34f0a76859afee0
msgid "Yul objects are used to group named code and data sections. The functions ``datasize``, ``dataoffset`` and ``datacopy`` can be used to access these sections from within code. Hex strings can be used to specify data in hex encoding, regular strings in native encoding. For code, ``datacopy`` will access its assembled binary representation."
msgstr ""

#: ../../yul.rst:1125 13fd9596a9f1491f809687c47837a485
msgid "Above, ``Block`` refers to ``Block`` in the Yul code grammar explained in the previous chapter."
msgstr ""

#: ../../yul.rst:1129 b77af61b535e4085a4d08824816aa5ad
msgid "Data objects or sub-objects whose names contain a ``.`` can be defined but it is not possible to access them through ``datasize``, ``dataoffset`` or ``datacopy`` because ``.`` is used as a separator to access objects inside another object."
msgstr ""

#: ../../yul.rst:1136 4a813b4e9f964923964ff3e8d8f5b913
msgid "The data object called ``\".metadata\"`` has a special meaning: It cannot be accessed from code and is always appended to the very end of the bytecode, regardless of its position in the object."
msgstr ""

#: ../../yul.rst:1140 d48685892a44440b879c6d6f083789da
msgid "Other data objects with special significance might be added in the future, but their names will always start with a ``.``."
msgstr ""

#: ../../yul.rst:1144 1befca54bf19443b863aa5c4b32a4d8e
msgid "An example Yul Object is shown below:"
msgstr ""

#: ../../yul.rst:1218 a9ffdb4d99e8447b85ba84d0269e3d03
msgid "Yul Optimizer"
msgstr ""

#: ../../yul.rst:1220 324004712dde44f6a0489c6d6b19b5ff
msgid "The Yul optimizer operates on Yul code and uses the same language for input, output and intermediate states. This allows for easy debugging and verification of the optimizer."
msgstr ""

#: ../../yul.rst:1223 0bb7973a9dae41a6b8e6d2cd1ec10855
msgid "Please refer to the general :ref:`optimizer documentation <optimizer>` for more details about the different optimization stages and how to use the optimizer."
msgstr ""

#: ../../yul.rst:1226 139d1cb56b814598b90e7488d404b804
msgid "If you want to use Solidity in stand-alone Yul mode, you activate the optimizer using ``--optimize`` and optionally specify the :ref:`expected number of contract executions <optimizer-parameter-runs>` with ``--optimize-runs``:"
msgstr ""

#: ../../yul.rst:1234 2fe6e9ca965e4307a99ef3acf65e21c9
msgid "In Solidity mode, the Yul optimizer is activated together with the regular optimizer."
msgstr ""

#: ../../yul.rst:1237 26c619575ff7497cb5a073ea3a87330b
msgid "Optimization Step Sequence"
msgstr ""

#: ../../yul.rst:1239 8a03ced1745d46e4a90783f095e22f69
msgid "By default the Yul optimizer applies its predefined sequence of optimization steps to the generated assembly. You can override this sequence and supply your own using the ``--yul-optimizations`` option:"
msgstr ""

#: ../../yul.rst:1246 a92b3c35c35945a6910297d1f9300d5b
msgid "The order of steps is significant and affects the quality of the output. Moreover, applying a step may uncover new optimization opportunities for others that were already applied so repeating steps is often beneficial. By enclosing part of the sequence in square brackets (``[]``) you tell the optimizer to repeatedly apply that part until it no longer improves the size of the resulting assembly. You can use brackets multiple times in a single sequence but they cannot be nested."
msgstr ""

#: ../../yul.rst:1253 cbb7b4f9ab9e492680f2a9b2e1bd6d16
msgid "The following optimization steps are available:"
msgstr ""

#: ../../yul.rst:1256 2a060640cdd844a189ecab61ed543eb8
msgid "Abbreviation"
msgstr ""

#: ../../yul.rst:1256 23de30186e4a4396ad0fdc81dca17666
msgid "Full name"
msgstr ""

#: ../../yul.rst:1258 3341aea113184861ac56cefa87f2963d
msgid "``f``"
msgstr ""

#: ../../yul.rst:1258 127d5af4964145f5862e021c8839ea1a
msgid "``BlockFlattener``"
msgstr ""

#: ../../yul.rst:1259 6e09ae1b09f041e1819fbb26cbbc4e22
msgid "``l``"
msgstr ""

#: ../../yul.rst:1259 c26d341462654cefb77c985403d09cb0
msgid "``CircularReferencesPruner``"
msgstr ""

#: ../../yul.rst:1260 87a8b445fe8b45ac9abc64ab7a9b2ba5
msgid "``c``"
msgstr ""

#: ../../yul.rst:1260 9af275e23da94a1597a701047c863fd1
msgid "``CommonSubexpressionEliminator``"
msgstr ""

#: ../../yul.rst:1261 c151d16c691c4820aa66a64ef10a2855
msgid "``C``"
msgstr ""

#: ../../yul.rst:1261 02417157c23a45b8a36d6c5933531721
msgid "``ConditionalSimplifier``"
msgstr ""

#: ../../yul.rst:1262 ce58c3ce46534ae0ba093281e77d338a
msgid "``U``"
msgstr ""

#: ../../yul.rst:1262 2dcf637cd45948349eea61472391ded7
msgid "``ConditionalUnsimplifier``"
msgstr ""

#: ../../yul.rst:1263 be5ffc698c274bc8ad26927029829095
msgid "``n``"
msgstr ""

#: ../../yul.rst:1263 ed2d637099124357a8a072c10c49f89c
msgid "``ControlFlowSimplifier``"
msgstr ""

#: ../../yul.rst:1264 be619b9ac1e34fa8bf423e8cf7592539
msgid "``D``"
msgstr ""

#: ../../yul.rst:1264 49184220cfa347979f7d8e8733858a22
msgid "``DeadCodeEliminator``"
msgstr ""

#: ../../yul.rst:1265 3846d9497afd4578bc54253819b4094a
msgid "``v``"
msgstr ""

#: ../../yul.rst:1265 2e3ff44c96a9444f9c993e184668e118
msgid "``EquivalentFunctionCombiner``"
msgstr ""

#: ../../yul.rst:1266 dbc404e3bcf646b08386c27c4fbe7477
msgid "``e``"
msgstr ""

#: ../../yul.rst:1266 3d84cc1b3dc0441b80119437be4dc148
msgid "``ExpressionInliner``"
msgstr ""

#: ../../yul.rst:1267 176b2b00c0a94dce8f3c8fbccb28e853
msgid "``j``"
msgstr ""

#: ../../yul.rst:1267 4e8aaee047b2445ba4c501c8f5740f57
msgid "``ExpressionJoiner``"
msgstr ""

#: ../../yul.rst:1268 575b21eacf9a4423b5da175302f30516
msgid "``s``"
msgstr ""

#: ../../yul.rst:1268 8b7df172b2664b2aa4779adaf3413e59
msgid "``ExpressionSimplifier``"
msgstr ""

#: ../../yul.rst:1269 19fd2aa739a045e185bc5198c72555a4
msgid "``x``"
msgstr ""

#: ../../yul.rst:1269 ee111fac274f4b2c8051c459c2186843
msgid "``ExpressionSplitter``"
msgstr ""

#: ../../yul.rst:1270 9b7476bdca864b4ebd1682a61d2b89f1
msgid "``I``"
msgstr ""

#: ../../yul.rst:1270 6574a678ad094a8c9a3344e06a444d9a
msgid "``ForLoopConditionIntoBody``"
msgstr ""

#: ../../yul.rst:1271 323b7e9b71e842888b2df6ebf07b458a
msgid "``O``"
msgstr ""

#: ../../yul.rst:1271 31cc8179bc9640b391142b660561f902
msgid "``ForLoopConditionOutOfBody``"
msgstr ""

#: ../../yul.rst:1272 a85810ce2c4b4e8e8c8d4e8e35c9adf9
msgid "``o``"
msgstr ""

#: ../../yul.rst:1272 1601b1506b2242288eb692db73b9ecaa
msgid "``ForLoopInitRewriter``"
msgstr ""

#: ../../yul.rst:1273 26bbb93d2ae547749b57030f205385fa
msgid "``i``"
msgstr ""

#: ../../yul.rst:1273 a6fb14f416f24e52bfe87cf484172175
msgid "``FullInliner``"
msgstr ""

#: ../../yul.rst:1274 80e811ab3b454f8c90284318fd0003ca
msgid "``g``"
msgstr ""

#: ../../yul.rst:1274 d912b429288d4f898408b807a75622aa
msgid "``FunctionGrouper``"
msgstr ""

#: ../../yul.rst:1275 c95d7496a9ce40b598d41acfa42ec898
msgid "``h``"
msgstr ""

#: ../../yul.rst:1275 3dc3877861a64bafa9278a1261758f05
msgid "``FunctionHoister``"
msgstr ""

#: ../../yul.rst:1276 92ccdda2640a4603a86b19398cc64683
msgid "``F``"
msgstr ""

#: ../../yul.rst:1276 0e226f0920ac46018300f5dd0d83b05b
msgid "``FunctionSpecializer``"
msgstr ""

#: ../../yul.rst:1277 5d74c2eb6e93493bb2089a650d7138b6
msgid "``T``"
msgstr ""

#: ../../yul.rst:1277 ffef2f59551c4b63a9429e42522cbf22
msgid "``LiteralRematerialiser``"
msgstr ""

#: ../../yul.rst:1278 0506617792694277a03ca3e7a1a7d1cf
msgid "``L``"
msgstr ""

#: ../../yul.rst:1278 21fdafbbd9644e1290b63e1d85e29d3e
msgid "``LoadResolver``"
msgstr ""

#: ../../yul.rst:1279 fd882afaa5164f7abcf620e5a4d3315c
msgid "``M``"
msgstr ""

#: ../../yul.rst:1279 20c1db5a83e347b28de5911a10f6a9af
msgid "``LoopInvariantCodeMotion``"
msgstr ""

#: ../../yul.rst:1280 abede364aaa5498a839217a6cc3df8cd
msgid "``r``"
msgstr ""

#: ../../yul.rst:1280 615a3be8e62344dcb3631348de18285d
msgid "``RedundantAssignEliminator``"
msgstr ""

#: ../../yul.rst:1281 255c844f3cae4c489ed035cb8a7002b1
msgid "``R``"
msgstr ""

#: ../../yul.rst:1281 34ac6851abcb4838ac9c05da0f8f00f7
msgid "``ReasoningBasedSimplifier`` - highly experimental"
msgstr ""

#: ../../yul.rst:1282 a542242d58c74fce85a464e57dc55ba7
msgid "``m``"
msgstr ""

#: ../../yul.rst:1282 8862e2994fd24a2dada4375d91741728
msgid "``Rematerialiser``"
msgstr ""

#: ../../yul.rst:1283 0cb13432e7584dcda19d25520024c8fc
msgid "``V``"
msgstr ""

#: ../../yul.rst:1283 1c378d5013984900bf6f638bfd70e7f4
msgid "``SSAReverser``"
msgstr ""

#: ../../yul.rst:1284 d275fba2f3684b9a9ec8fc4755264a17
msgid "``a``"
msgstr ""

#: ../../yul.rst:1284 a24d245ed2db4efd8b6fe64bdb3786f3
msgid "``SSATransform``"
msgstr ""

#: ../../yul.rst:1285 a9cdd4fb59324f22944d1f393bccebc4
msgid "``t``"
msgstr ""

#: ../../yul.rst:1285 9942cd0e9f9c468d92365a5e069218c1
msgid "``StructuralSimplifier``"
msgstr ""

#: ../../yul.rst:1286 dd3ed2757a50453fad73acaabc0fd63e
msgid "``u``"
msgstr ""

#: ../../yul.rst:1286 d8d827ccddcb438b80bcb42bb3f244a4
msgid "``UnusedPruner``"
msgstr ""

#: ../../yul.rst:1287 6634e20e387643d498c357cbb520e62d
msgid "``p``"
msgstr ""

#: ../../yul.rst:1287 dd9f7937f93a48fd9df2ce42c49a5211
msgid "``UnusedFunctionParameterPruner``"
msgstr ""

#: ../../yul.rst:1288 24e068dfb071423cbac624c304210e8a
msgid "``d``"
msgstr ""

#: ../../yul.rst:1288 24e64254fc3645648eacf9dc01690864
msgid "``VarDeclInitializer``"
msgstr ""

#: ../../yul.rst:1291 4475c3207ac54fa89b00e08ef9658e92
msgid "Some steps depend on properties ensured by ``BlockFlattener``, ``FunctionGrouper``, ``ForLoopInitRewriter``. For this reason the Yul optimizer always applies them before applying any steps supplied by the user."
msgstr ""

#: ../../yul.rst:1294 c7966ff146b1416089761cfe4298493a
msgid "The ReasoningBasedSimplifier is an optimizer step that is currently not enabled in the default set of steps. It uses an SMT solver to simplify arithmetic expressions and boolean conditions. It has not received thorough testing or validation yet and can produce non-reproducible results, so please use with care!"
msgstr ""

#: ../../yul.rst:1302 cfd6c535795a4840bae878620676bad7
msgid "Complete ERC20 Example"
msgstr ""

