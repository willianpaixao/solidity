msgid ""
msgstr ""
"Project-Id-Version: solidity-test\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-01-13 16:47+0100\n"
"PO-Revision-Date: 2022-01-13 16:14\n"
"Last-Translator: \n"
"Language-Team: Spanish (Modern)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Crowdin-Project: solidity-test\n"
"X-Crowdin-Project-ID: 494285\n"
"X-Crowdin-Language: es-EM\n"
"X-Crowdin-File: introduction-to-smart-contracts.po\n"
"X-Crowdin-File-ID: 45\n"
"Language: es_EM\n"

#: ../../introduction-to-smart-contracts.rst:3 960464bc317742758be8ebc7f913c75e
msgid "Introduction to Smart Contracts"
msgstr ""

#: ../../introduction-to-smart-contracts.rst:9 95f65f2a2d0d4fc5b2d949d6b6379f0e
msgid "A Simple Smart Contract"
msgstr ""

#: ../../introduction-to-smart-contracts.rst:11
#: 70606d96e4ed44febeff8685a787bedb
msgid "Let us begin with a basic example that sets the value of a variable and exposes it for other contracts to access. It is fine if you do not understand everything right now, we will go into more detail later."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:16
#: c542c6b098304fbc831b7a67941ac649
msgid "Storage Example"
msgstr ""

#: ../../introduction-to-smart-contracts.rst:35
#: b2943c798b41474080abb607775345c7
msgid "The first line tells you that the source code is licensed under the GPL version 3.0. Machine-readable license specifiers are important in a setting where publishing the source code is the default."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:39
#: 517d29389e5a4dada423ec0b1c2df174
msgid "The next line specifies that the source code is written for Solidity version 0.4.16, or a newer version of the language up to, but not including version 0.9.0. This is to ensure that the contract is not compilable with a new (breaking) compiler version, where it could behave differently. :ref:`Pragmas<pragma>` are common instructions for compilers about how to treat the source code (e.g. `pragma once <https://en.wikipedia.org/wiki/Pragma_once>`_)."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:45
#: de35f6f09a114c9ca669544824ec3a62
msgid "A contract in the sense of Solidity is a collection of code (its *functions*) and data (its *state*) that resides at a specific address on the Ethereum blockchain. The line ``uint storedData;`` declares a state variable called ``storedData`` of type ``uint`` (*u*\\nsigned *int*\\eger of *256* bits). You can think of it as a single slot in a database that you can query and alter by calling functions of the code that manages the database. In this example, the contract defines the functions ``set`` and ``get`` that can be used to modify or retrieve the value of the variable."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:54
#: 0b0a817eb2ae46fb8210af722ca3234a
msgid "To access a member (like a state variable) of the current contract, you do not typically add the ``this.`` prefix, you just access it directly via its name. Unlike in some other languages, omitting it is not just a matter of style, it results in a completely different way to access the member, but more on this later."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:59
#: af501c9d35d743f5bd89ca4cd92eaf1e
msgid "This contract does not do much yet apart from (due to the infrastructure built by Ethereum) allowing anyone to store a single number that is accessible by anyone in the world without a (feasible) way to prevent you from publishing this number. Anyone could call ``set`` again with a different value and overwrite your number, but the number is still stored in the history of the blockchain. Later, you will see how you can impose access restrictions so that only you can alter the number."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:68
#: d67dad08f83542aa82cd2c7ba2342df8
msgid "Be careful with using Unicode text, as similar looking (or even identical) characters can have different code points and as such are encoded as a different byte array."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:72
#: ad7b1096e872467c8140f62f9b653b8b
msgid "All identifiers (contract names, function names and variable names) are restricted to the ASCII character set. It is possible to store UTF-8 encoded data in string variables."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:78
#: fe1f019642a4470fb323ca0c8dfa5c2f
msgid "Subcurrency Example"
msgstr ""

#: ../../introduction-to-smart-contracts.rst:80
#: e8985c63eec9415a869105c9251543b1
msgid "The following contract implements the simplest form of a cryptocurrency. The contract allows only its creator to create new coins (different issuance schemes are possible). Anyone can send coins to each other without a need for registering with a username and password, all you need is an Ethereum keypair."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:133
#: e8864b9bed47451f8f35e4c9b7f32e6a
msgid "This contract introduces some new concepts, let us go through them one by one."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:135
#: 49d06aa66ab443ac9b26245c093d9fe2
msgid "The line ``address public minter;`` declares a state variable of type :ref:`address<address>`. The ``address`` type is a 160-bit value that does not allow any arithmetic operations. It is suitable for storing addresses of contracts, or a hash of the public half of a keypair belonging to :ref:`external accounts<accounts>`."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:140
#: 13044152681c449e90c15850bb09091b
msgid "The keyword ``public`` automatically generates a function that allows you to access the current value of the state variable from outside of the contract. Without this keyword, other contracts have no way to access the variable. The code of the function generated by the compiler is equivalent to the following (ignore ``external`` and ``view`` for now):"
msgstr ""

#: ../../introduction-to-smart-contracts.rst:149
#: a670062f071443939ce6b971e73f46c9
msgid "You could add a function like the above yourself, but you would have a function and state variable with the same name. You do not need to do this, the compiler figures it out for you."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:154
#: 6e725f239a2d4bf5a8a94da7dd7bf6df
msgid "The next line, ``mapping (address => uint) public balances;`` also creates a public state variable, but it is a more complex datatype. The :ref:`mapping <mapping-types>` type maps addresses to :ref:`unsigned integers <integers>`."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:158
#: ba6ecc681a0b4728aa87483ad79c9c5c
msgid "Mappings can be seen as `hash tables <https://en.wikipedia.org/wiki/Hash_table>`_ which are virtually initialised such that every possible key exists from the start and is mapped to a value whose byte-representation is all zeros. However, it is neither possible to obtain a list of all keys of a mapping, nor a list of all values. Record what you added to the mapping, or use it in a context where this is not needed. Or even better, keep a list, or use a more suitable data type."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:165
#: eea567757aa44702b6c69e7dc7bac7ea
msgid "The :ref:`getter function<getter-functions>` created by the ``public`` keyword is more complex in the case of a mapping. It looks like the following:"
msgstr ""

#: ../../introduction-to-smart-contracts.rst:175
#: 167bf133e83347dd83c55e7c7eefe98c
msgid "You can use this function to query the balance of a single account."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:179
#: fdf01a6396094854a17e368a44bec82f
msgid "The line ``event Sent(address from, address to, uint amount);`` declares an :ref:`\"event\" <events>`, which is emitted in the last line of the function ``send``. Ethereum clients such as web applications can listen for these events emitted on the blockchain without much cost. As soon as it is emitted, the listener receives the arguments ``from``, ``to`` and ``amount``, which makes it possible to track transactions."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:187
#: 276a04cbf5ab459b894d1f488d5d5e1e
msgid "To listen for this event, you could use the following JavaScript code, which uses `web3.js <https://github.com/ethereum/web3.js/>`_ to create the ``Coin`` contract object, and any user interface calls the automatically generated ``balances`` function from above::"
msgstr ""

#: ../../introduction-to-smart-contracts.rst:204
#: 83240a7a5ad7452891873969bea6e472
msgid "The :ref:`constructor<constructor>` is a special function that is executed during the creation of the contract and cannot be called afterwards. In this case, it permanently stores the address of the person creating the contract. The ``msg`` variable (together with ``tx`` and ``block``) is a :ref:`special global variable <special-variables-functions>` that contains properties which allow access to the blockchain. ``msg.sender`` is always the address where the current (external) function call came from."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:211
#: 8e78d46f52804799a94f0185702d6b87
msgid "The functions that make up the contract, and that users and contracts can call are ``mint`` and ``send``."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:213
#: 1c0e1f3bc0f2479cbc34a86ae38d550d
msgid "The ``mint`` function sends an amount of newly created coins to another address. The :ref:`require <assert-and-require>` function call defines conditions that reverts all changes if not met. In this example, ``require(msg.sender == minter);`` ensures that only the creator of the contract can call ``mint``. In general, the creator can mint as many tokens as they like, but at some point, this will lead to a phenomenon called \"overflow\". Note that because of the default :ref:`Checked arithmetic <unchecked>`, the transaction would revert if the expression ``balances[receiver] += amount;`` overflows, i.e., when ``balances[receiver] + amount`` in arbitrary precision arithmetic is larger than the maximum value of ``uint`` (``2**256 - 1``). This is also true for the statement ``balances[receiver] += amount;`` in the function ``send``."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:223
#: 76d650e68b0e40279b00d32643b2e20f
msgid ":ref:`Errors <errors>` allow you to provide more information to the caller about why a condition or operation failed. Errors are used together with the :ref:`revert statement <revert-statement>`. The revert statement unconditionally aborts and reverts all changes similar to the ``require`` function, but it also allows you to provide the name of an error and additional data which will be supplied to the caller (and eventually to the front-end application or block explorer) so that a failure can more easily be debugged or reacted upon."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:231
#: 0c60255142b44d48a7af51d0665dc8ef
msgid "The ``send`` function can be used by anyone (who already has some of these coins) to send coins to anyone else. If the sender does not have enough coins to send, the ``if`` condition evaluates to true. As a result, the ``revert`` will cause the operation to fail while providing the sender with error details using the ``InsufficientBalance`` error."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:237
#: 2ee77d892aeb4451bab5b2278d65fe95
msgid "If you use this contract to send coins to an address, you will not see anything when you look at that address on a blockchain explorer, because the record that you sent coins and the changed balances are only stored in the data storage of this particular coin contract. By using events, you can create a \"blockchain explorer\" that tracks transactions and balances of your new coin, but you have to inspect the coin contract address and not the addresses of the coin owners."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:250
#: 7aa3a0b0b52d4a72afa0144e847ba655
msgid "Blockchain Basics"
msgstr ""

#: ../../introduction-to-smart-contracts.rst:252
#: e30ec08208734e33a795565683d35a11
msgid "Blockchains as a concept are not too hard to understand for programmers. The reason is that most of the complications (mining, `hashing <https://en.wikipedia.org/wiki/Cryptographic_hash_function>`_, `elliptic-curve cryptography <https://en.wikipedia.org/wiki/Elliptic_curve_cryptography>`_, `peer-to-peer networks <https://en.wikipedia.org/wiki/Peer-to-peer>`_, etc.) are just there to provide a certain set of features and promises for the platform. Once you accept these features as given, you do not have to worry about the underlying technology - or do you have to know how Amazon's AWS works internally in order to use it?"
msgstr ""

#: ../../introduction-to-smart-contracts.rst:263
#: ../../introduction-to-smart-contracts.rst:366
#: 30fed54577ad4102a932e42f398a3a89 8c4982cdd3b14a8e849d7e44be684412
msgid "Transactions"
msgstr ""

#: ../../introduction-to-smart-contracts.rst:265
#: ca60149247d842e18b15046e0c62b24d
msgid "A blockchain is a globally shared, transactional database. This means that everyone can read entries in the database just by participating in the network. If you want to change something in the database, you have to create a so-called transaction which has to be accepted by all others. The word transaction implies that the change you want to make (assume you want to change two values at the same time) is either not done at all or completely applied. Furthermore, while your transaction is being applied to the database, no other transaction can alter it."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:273
#: ee7985f6e34a485e9e23c3391860f2e2
msgid "As an example, imagine a table that lists the balances of all accounts in an electronic currency. If a transfer from one account to another is requested, the transactional nature of the database ensures that if the amount is subtracted from one account, it is always added to the other account. If due to whatever reason, adding the amount to the target account is not possible, the source account is also not modified."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:280
#: 95f228c3614140719648a31ac80a3212
msgid "Furthermore, a transaction is always cryptographically signed by the sender (creator). This makes it straightforward to guard access to specific modifications of the database. In the example of the electronic currency, a simple check ensures that only the person holding the keys to the account can transfer money from it."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:288
#: ae0b9d97ccb04b77b207c686e1a789a0
msgid "Blocks"
msgstr ""

#: ../../introduction-to-smart-contracts.rst:290
#: 48312bd256a8423aa590ce1f53ca1f34
msgid "One major obstacle to overcome is what (in Bitcoin terms) is called a \"double-spend attack\": What happens if two transactions exist in the network that both want to empty an account? Only one of the transactions can be valid, typically the one that is accepted first. The problem is that \"first\" is not an objective term in a peer-to-peer network."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:295
#: 4690e25acb9b465586160a80cc8e7215
msgid "The abstract answer to this is that you do not have to care. A globally accepted order of the transactions will be selected for you, solving the conflict. The transactions will be bundled into what is called a \"block\" and then they will be executed and distributed among all participating nodes. If two transactions contradict each other, the one that ends up being second will be rejected and not become part of the block."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:301
#: 878fe03be8db426991d12084acf9a9f2
msgid "These blocks form a linear sequence in time and that is where the word \"blockchain\" derives from. Blocks are added to the chain in rather regular intervals - for Ethereum this is roughly every 17 seconds."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:305
#: a6450ff9e8a541508396d1fb88d0d393
msgid "As part of the \"order selection mechanism\" (which is called \"mining\") it may happen that blocks are reverted from time to time, but only at the \"tip\" of the chain. The more blocks are added on top of a particular block, the less likely this block will be reverted. So it might be that your transactions are reverted and even removed from the blockchain, but the longer you wait, the less likely it will be."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:312
#: 169ea4fc72b948fd8574de68878de7b7
msgid "Transactions are not guaranteed to be included in the next block or any specific future block, since it is not up to the submitter of a transaction, but up to the miners to determine in which block the transaction is included."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:315
#: a7fd3d6bf0184cb1a8ba9ed7733bb317
msgid "If you want to schedule future calls of your contract, you can use a smart contract automation tool or an oracle service."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:324
#: cb88ee59dc494198b1e4c804350220eb
msgid "The Ethereum Virtual Machine"
msgstr ""

#: ../../introduction-to-smart-contracts.rst:327
#: f0e965f031be4144948cc15e9d8e01b0
msgid "Overview"
msgstr ""

#: ../../introduction-to-smart-contracts.rst:329
#: 971380fe930b4cd2a04ebcfbe23ffa44
msgid "The Ethereum Virtual Machine or EVM is the runtime environment for smart contracts in Ethereum. It is not only sandboxed but actually completely isolated, which means that code running inside the EVM has no access to network, filesystem or other processes. Smart contracts even have limited access to other smart contracts."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:340
#: 4bdce7a35cbc4ad197e606378e7deb25
msgid "Accounts"
msgstr ""

#: ../../introduction-to-smart-contracts.rst:342
#: d1d58f63b5f644f09aef2c920187f85c
msgid "There are two kinds of accounts in Ethereum which share the same address space: **External accounts** that are controlled by public-private key pairs (i.e. humans) and **contract accounts** which are controlled by the code stored together with the account."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:347
#: be9ed50d18dd4e9087f680ed2033b084
msgid "The address of an external account is determined from the public key while the address of a contract is determined at the time the contract is created (it is derived from the creator address and the number of transactions sent from that address, the so-called \"nonce\")."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:353
#: 51c3be541a97438291ed62a9e894b742
msgid "Regardless of whether or not the account stores code, the two types are treated equally by the EVM."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:356
#: 8a8d5ff3f90c4621bf85d9f523552a62
msgid "Every account has a persistent key-value store mapping 256-bit words to 256-bit words called **storage**."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:359
#: 984df3dc50b744b885b52339c3d60d71
msgid "Furthermore, every account has a **balance** in Ether (in \"Wei\" to be exact, ``1 ether`` is ``10**18 wei``) which can be modified by sending transactions that include Ether."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:368
#: cb3862a1e7d04f499b3b7c0e02509959
msgid "A transaction is a message that is sent from one account to another account (which might be the same or empty, see below). It can include binary data (which is called \"payload\") and Ether."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:372
#: df60c93b2dac49cb9d296392d5822ea2
msgid "If the target account contains code, that code is executed and the payload is provided as input data."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:375
#: 37e556ab9d174caf8fb6e081dc169cc1
msgid "If the target account is not set (the transaction does not have a recipient or the recipient is set to ``null``), the transaction creates a **new contract**. As already mentioned, the address of that contract is not the zero address but an address derived from the sender and its number of transactions sent (the \"nonce\"). The payload of such a contract creation transaction is taken to be EVM bytecode and executed. The output data of this execution is permanently stored as the code of the contract. This means that in order to create a contract, you do not send the actual code of the contract, but in fact code that returns that code when executed."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:389
#: 206d39bd996d42a2ad814fc6c2d99b04
msgid "While a contract is being created, its code is still empty. Because of that, you should not call back into the contract under construction until its constructor has finished executing."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:397
#: 37895a994b8f4e568b72aca88451f5af
msgid "Gas"
msgstr ""

#: ../../introduction-to-smart-contracts.rst:399
#: e58c8d07bb2e4cada26b070434794222
msgid "Upon creation, each transaction is charged with a certain amount of **gas**, whose purpose is to limit the amount of work that is needed to execute the transaction and to pay for this execution at the same time. While the EVM executes the transaction, the gas is gradually depleted according to specific rules."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:404
#: 2503e321e7bf4367b7adfd1ef277c7a9
msgid "The **gas price** is a value set by the creator of the transaction, who has to pay ``gas_price * gas`` up front from the sending account. If some gas is left after the execution, it is refunded to the creator in the same way."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:408
#: 091979a07b1c4117a208d44c77929645
msgid "If the gas is used up at any point (i.e. it would be negative), an out-of-gas exception is triggered, which reverts all modifications made to the state in the current call frame."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:415
#: 4f96f251fa56477595b5292a744052c2
msgid "Storage, Memory and the Stack"
msgstr ""

#: ../../introduction-to-smart-contracts.rst:417
#: 4307f18fdcd9434b93824989d269770b
msgid "The Ethereum Virtual Machine has three areas where it can store data- storage, memory and the stack, which are explained in the following paragraphs."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:421
#: 9c2804f835da4e3ab0f8fd5eb8cf6382
msgid "Each account has a data area called **storage**, which is persistent between function calls and transactions. Storage is a key-value store that maps 256-bit words to 256-bit words. It is not possible to enumerate storage from within a contract, it is comparatively costly to read, and even more to initialise and modify storage. Because of this cost, you should minimize what you store in persistent storage to what the contract needs to run. Store data like derived calculations, caching, and aggregates outside of the contract. A contract can neither read nor write to any storage apart from its own."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:430
#: 836d97201d3d4147b1056e886b0e09c1
msgid "The second data area is called **memory**, of which a contract obtains a freshly cleared instance for each message call. Memory is linear and can be addressed at byte level, but reads are limited to a width of 256 bits, while writes can be either 8 bits or 256 bits wide. Memory is expanded by a word (256-bit), when accessing (either reading or writing) a previously untouched memory word (i.e. any offset within a word). At the time of expansion, the cost in gas must be paid. Memory is more costly the larger it grows (it scales quadratically)."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:438
#: eb8927d5b7d94d15b5a6875656bcc89a
msgid "The EVM is not a register machine but a stack machine, so all computations are performed on a data area called the **stack**. It has a maximum size of 1024 elements and contains words of 256 bits. Access to the stack is limited to the top end in the following way: It is possible to copy one of the topmost 16 elements to the top of the stack or swap the topmost element with one of the 16 elements below it. All other operations take the topmost two (or one, or more, depending on the operation) elements from the stack and push the result onto the stack. Of course it is possible to move stack elements to storage or memory in order to get deeper access to the stack, but it is not possible to just access arbitrary elements deeper in the stack without first removing the top of the stack."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:455
#: 0faf15574d7740d4be0b4b4af591b980
msgid "Instruction Set"
msgstr ""

#: ../../introduction-to-smart-contracts.rst:457
#: 1e85e592d4294e9e8f38abefafc8cf59
msgid "The instruction set of the EVM is kept minimal in order to avoid incorrect or inconsistent implementations which could cause consensus problems. All instructions operate on the basic data type, 256-bit words or on slices of memory (or other byte arrays). The usual arithmetic, bit, logical and comparison operations are present. Conditional and unconditional jumps are possible. Furthermore, contracts can access relevant properties of the current block like its number and timestamp."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:466
#: daa984e61c88424aa440b8604a5d56e7
msgid "For a complete list, please see the :ref:`list of opcodes <opcodes>` as part of the inline assembly documentation."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:472
#: 9798176b30624989abe1a17c1067ae47
msgid "Message Calls"
msgstr ""

#: ../../introduction-to-smart-contracts.rst:474
#: 591a2776e4f54455b65d8e42839fb887
msgid "Contracts can call other contracts or send Ether to non-contract accounts by the means of message calls. Message calls are similar to transactions, in that they have a source, a target, data payload, Ether, gas and return data. In fact, every transaction consists of a top-level message call which in turn can create further message calls."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:480
#: 72f66e4788fd46ba848a72bf1872b2f4
msgid "A contract can decide how much of its remaining **gas** should be sent with the inner message call and how much it wants to retain. If an out-of-gas exception happens in the inner call (or any other exception), this will be signaled by an error value put onto the stack. In this case, only the gas sent together with the call is used up. In Solidity, the calling contract causes a manual exception by default in such situations, so that exceptions \"bubble up\" the call stack."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:488
#: 4e5bf472d3e34346babf8517fd0d6d64
msgid "As already said, the called contract (which can be the same as the caller) will receive a freshly cleared instance of memory and has access to the call payload - which will be provided in a separate area called the **calldata**. After it has finished execution, it can return data which will be stored at a location in the caller's memory preallocated by the caller. All such calls are fully synchronous."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:495
#: 51a560f3115648f68eada2df2343f8a0
msgid "Calls are **limited** to a depth of 1024, which means that for more complex operations, loops should be preferred over recursive calls. Furthermore, only 63/64th of the gas can be forwarded in a message call, which causes a depth limit of a little less than 1000 in practice."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:503
#: 44199b5ef5d045b091fa94edbb159990
msgid "Delegatecall / Callcode and Libraries"
msgstr ""

#: ../../introduction-to-smart-contracts.rst:505
#: b8c2f5f7a5854c5ea25d62c1c6a6401a
msgid "There exists a special variant of a message call, named **delegatecall** which is identical to a message call apart from the fact that the code at the target address is executed in the context of the calling contract and ``msg.sender`` and ``msg.value`` do not change their values."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:510
#: e37051be6e524c5988e4dfbcd706b8b1
msgid "This means that a contract can dynamically load code from a different address at runtime. Storage, current address and balance still refer to the calling contract, only the code is taken from the called address."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:514
#: d90ab3ea38a2429597d3d0f438c653ad
msgid "This makes it possible to implement the \"library\" feature in Solidity: Reusable library code that can be applied to a contract's storage, e.g. in order to implement a complex data structure."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:521
#: d462984315e14eb8aed710ceca0f081e
msgid "Logs"
msgstr ""

#: ../../introduction-to-smart-contracts.rst:523
#: 0145610ff5814655bbbb174157247707
msgid "It is possible to store data in a specially indexed data structure that maps all the way up to the block level. This feature called **logs** is used by Solidity in order to implement :ref:`events <events>`. Contracts cannot access log data after it has been created, but they can be efficiently accessed from outside the blockchain. Since some part of the log data is stored in `bloom filters <https://en.wikipedia.org/wiki/Bloom_filter>`_, it is possible to search for this data in an efficient and cryptographically secure way, so network peers that do not download the whole blockchain (so-called \"light clients\") can still find these logs."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:536
#: 7f5bc20ef0c34331bb708d836f1d7c7b
msgid "Create"
msgstr ""

#: ../../introduction-to-smart-contracts.rst:538
#: 1778ff8ef66541f4a8fe9a5384079428
msgid "Contracts can even create other contracts using a special opcode (i.e. they do not simply call the zero address as a transaction would). The only difference between these **create calls** and normal message calls is that the payload data is executed and the result stored as code and the caller / creator receives the address of the new contract on the stack."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:547
#: c7e699cbed7542239404f443e3a9f4bc
msgid "Deactivate and Self-destruct"
msgstr ""

#: ../../introduction-to-smart-contracts.rst:549
#: b7bc6e571dae441d9d1ee1e9786b867d
msgid "The only way to remove code from the blockchain is when a contract at that address performs the ``selfdestruct`` operation. The remaining Ether stored at that address is sent to a designated target and then the storage and code is removed from the state. Removing the contract in theory sounds like a good idea, but it is potentially dangerous, as if someone sends Ether to removed contracts, the Ether is forever lost."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:557
#: ae1795eef17c447c8f03d1751956d273
msgid "Even if a contract is removed by ``selfdestruct``, it is still part of the history of the blockchain and probably retained by most Ethereum nodes. So using ``selfdestruct`` is not the same as deleting data from a hard disk."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:562
#: 59f8aa742c69454eba526bbb29afc3be
msgid "Even if a contract's code does not contain a call to ``selfdestruct``, it can still perform that operation using ``delegatecall`` or ``callcode``."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:565
#: 23cb35a11e304de1a099a89eee21f4e8
msgid "If you want to deactivate your contracts, you should instead **disable** them by changing some internal state which causes all functions to revert. This makes it impossible to use the contract, as it returns Ether immediately."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:575
#: c33c9f2365e94fd59692bfe627b6944c
msgid "Precompiled Contracts"
msgstr ""

#: ../../introduction-to-smart-contracts.rst:577
#: e52ccc9666464d4eabe1ea0482cc7459
msgid "There is a small set of contract addresses that are special: The address range between ``1`` and (including) ``8`` contains \"precompiled contracts\" that can be called as any other contract but their behaviour (and their gas consumption) is not defined by EVM code stored at that address (they do not contain code) but instead is implemented in the EVM execution environment itself."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:584
#: c4836b69ff5f4ba0a712e50f987f840b
msgid "Different EVM-compatible chains might use a different set of precompiled contracts. It might also be possible that new precompiled contracts are added to the Ethereum main chain in the future, but you can reasonably expect them to always be in the range between ``1`` and ``0xffff`` (inclusive)."
msgstr ""

