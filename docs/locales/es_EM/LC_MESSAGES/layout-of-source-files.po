msgid ""
msgstr ""
"Project-Id-Version: solidity-test\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-01-13 16:47+0100\n"
"PO-Revision-Date: 2022-01-13 16:14\n"
"Last-Translator: \n"
"Language-Team: Spanish (Modern)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Crowdin-Project: solidity-test\n"
"X-Crowdin-Project-ID: 494285\n"
"X-Crowdin-Language: es-EM\n"
"X-Crowdin-File: layout-of-source-files.po\n"
"X-Crowdin-File-ID: 13\n"
"Language: es_EM\n"

#: ../../layout-of-source-files.rst:3 5f0a396fa4e84286bc60814e5fa72f8b
msgid "Layout of a Solidity Source File"
msgstr ""

#: ../../layout-of-source-files.rst:5 ca94ac1eaa3e4254882caf45775bf989
msgid "Source files can contain an arbitrary number of :ref:`contract definitions<contract_structure>`, import_ directives, :ref:`pragma directives<pragma>` and :ref:`struct<structs>`, :ref:`enum<enums>`, :ref:`function<functions>`, :ref:`error<errors>` and :ref:`constant variable<constants>` definitions."
msgstr ""

#: ../../layout-of-source-files.rst:14 7b4db72fd2f24764b56bffc54ea76004
msgid "SPDX License Identifier"
msgstr ""

#: ../../layout-of-source-files.rst:16 f1031187f3af4a3d9c4e9105b61bbc9c
msgid "Trust in smart contracts can be better established if their source code is available. Since making source code available always touches on legal problems with regards to copyright, the Solidity compiler encourages the use of machine-readable `SPDX license identifiers <https://spdx.org>`_. Every source file should start with a comment indicating its license:"
msgstr ""

#: ../../layout-of-source-files.rst:22 766906a41e3e4c2da1931531ed105ce3
msgid "``// SPDX-License-Identifier: MIT``"
msgstr ""

#: ../../layout-of-source-files.rst:24 cfa492e127314c9584e3d24b2b8de15c
msgid "The compiler does not validate that the license is part of the `list allowed by SPDX <https://spdx.org/licenses/>`_, but it does include the supplied string in the :ref:`bytecode metadata <metadata>`."
msgstr ""

#: ../../layout-of-source-files.rst:28 f9c4d79572ec4ff7869f8df147e9b41f
msgid "If you do not want to specify a license or if the source code is not open-source, please use the special value ``UNLICENSED``."
msgstr ""

#: ../../layout-of-source-files.rst:31 d9f255be05c74887a70cb20222d048c8
msgid "Supplying this comment of course does not free you from other obligations related to licensing like having to mention a specific license header in each source file or the original copyright holder."
msgstr ""

#: ../../layout-of-source-files.rst:36 4bebed273ef547b989f9bcb01f9162b9
msgid "The comment is recognized by the compiler anywhere in the file at the file level, but it is recommended to put it at the top of the file."
msgstr ""

#: ../../layout-of-source-files.rst:39 6ea11af1c8fb42488ff227122bc738ad
msgid "More information about how to use SPDX license identifiers can be found at the `SPDX website <https://spdx.org/ids-how>`_."
msgstr ""

#: ../../layout-of-source-files.rst:48 1e2a6ee117674102941e2e351b039357
msgid "Pragmas"
msgstr ""

#: ../../layout-of-source-files.rst:50 0b70a58b8b5c43838baa7f1a234b8b90
msgid "The ``pragma`` keyword is used to enable certain compiler features or checks. A pragma directive is always local to a source file, so you have to add the pragma to all your files if you want to enable it in your whole project. If you :ref:`import<import>` another file, the pragma from that file does *not* automatically apply to the importing file."
msgstr ""

#: ../../layout-of-source-files.rst:61 f18e3a37675b44fa86673702d72371bc
msgid "Version Pragma"
msgstr ""

#: ../../layout-of-source-files.rst:63 d05a9b579a814b8cb4649677aa937d86
msgid "Source files can (and should) be annotated with a version pragma to reject compilation with future compiler versions that might introduce incompatible changes. We try to keep these to an absolute minimum and introduce them in a way that changes in semantics also require changes in the syntax, but this is not always possible. Because of this, it is always a good idea to read through the changelog at least for releases that contain breaking changes. These releases always have versions of the form ``0.x.0`` or ``x.0.0``."
msgstr ""

#: ../../layout-of-source-files.rst:72 13ba8612000d44ea8a44b042ea0b8139
msgid "The version pragma is used as follows: ``pragma solidity ^0.5.2;``"
msgstr ""

#: ../../layout-of-source-files.rst:74 2fcf975c3b144756865107cbc875a4d2
msgid "A source file with the line above does not compile with a compiler earlier than version 0.5.2, and it also does not work on a compiler starting from version 0.6.0 (this second condition is added by using ``^``). Because there will be no breaking changes until version ``0.6.0``, you can be sure that your code compiles the way you intended. The exact version of the compiler is not fixed, so that bugfix releases are still possible."
msgstr ""

#: ../../layout-of-source-files.rst:81 a4aedf9201914551874d2d8949fae36e
msgid "It is possible to specify more complex rules for the compiler version, these follow the same syntax used by `npm <https://docs.npmjs.com/cli/v6/using-npm/semver>`_."
msgstr ""

#: ../../layout-of-source-files.rst:85 1c806b1d8dbd4c8cb8628db4dabfa19f
msgid "Using the version pragma *does not* change the version of the compiler. It also *does not* enable or disable features of the compiler. It just instructs the compiler to check whether its version matches the one required by the pragma. If it does not match, the compiler issues an error."
msgstr ""

#: ../../layout-of-source-files.rst:92 057d55954d26455aaca7cc2faf41bd8c
msgid "ABI Coder Pragma"
msgstr ""

#: ../../layout-of-source-files.rst:94 63ba7d805368481f8c9f55d314e37a6f
msgid "By using ``pragma abicoder v1`` or ``pragma abicoder v2`` you can select between the two implementations of the ABI encoder and decoder."
msgstr ""

#: ../../layout-of-source-files.rst:97 d42204276f2449009150242b4b50b35e
msgid "The new ABI coder (v2) is able to encode and decode arbitrarily nested arrays and structs. It might produce less optimal code and has not received as much testing as the old encoder, but is considered non-experimental as of Solidity 0.6.0. You still have to explicitly activate it using ``pragma abicoder v2;``. Since it will be activated by default starting from Solidity 0.8.0, there is the option to select the old coder using ``pragma abicoder v1;``."
msgstr ""

#: ../../layout-of-source-files.rst:105 0627bc2aac7d45389923da837d03c80c
msgid "The set of types supported by the new encoder is a strict superset of the ones supported by the old one. Contracts that use it can interact with ones that do not without limitations. The reverse is possible only as long as the non-``abicoder v2`` contract does not try to make calls that would require decoding types only supported by the new encoder. The compiler can detect this and will issue an error. Simply enabling ``abicoder v2`` for your contract is enough to make the error go away."
msgstr ""

#: ../../layout-of-source-files.rst:114 ab05e81501754fa19b6349255e603727
msgid "This pragma applies to all the code defined in the file where it is activated, regardless of where that code ends up eventually. This means that a contract whose source file is selected to compile with ABI coder v1 can still contain code that uses the new encoder by inheriting it from another contract. This is allowed if the new types are only used internally and not in external function signatures."
msgstr ""

#: ../../layout-of-source-files.rst:122 b0bd3a33724d4d7b9fda89b7148d270e
msgid "Up to Solidity 0.7.4, it was possible to select the ABI coder v2 by using ``pragma experimental ABIEncoderV2``, but it was not possible to explicitly select coder v1 because it was the default."
msgstr ""

#: ../../layout-of-source-files.rst:131 b72e814710404ea08277709c8ffb1cc5
msgid "Experimental Pragma"
msgstr ""

#: ../../layout-of-source-files.rst:133 4c79149d296b42c0998ed99ca6e7cd83
msgid "The second pragma is the experimental pragma. It can be used to enable features of the compiler or language that are not yet enabled by default. The following experimental pragmas are currently supported:"
msgstr ""

#: ../../layout-of-source-files.rst:139 33d87d45fab64ae4a8ad52ae161bef2d
msgid "ABIEncoderV2"
msgstr ""

#: ../../layout-of-source-files.rst:141 52298c216c264fafb1f2cabe17bd3515
msgid "Because the ABI coder v2 is not considered experimental anymore, it can be selected via ``pragma abicoder v2`` (please see above) since Solidity 0.7.4."
msgstr ""

#: ../../layout-of-source-files.rst:148 cfe34b3695c34a988459168dcff23e3c
msgid "SMTChecker"
msgstr ""

#: ../../layout-of-source-files.rst:150 32db02b5909641acad253ea83be4925b
msgid "This component has to be enabled when the Solidity compiler is built and therefore it is not available in all Solidity binaries. The :ref:`build instructions<smt_solvers_build>` explain how to activate this option. It is activated for the Ubuntu PPA releases in most versions, but not for the Docker images, Windows binaries or the statically-built Linux binaries. It can be activated for solc-js via the `smtCallback <https://github.com/ethereum/solc-js#example-usage-with-smtsolver-callback>`_ if you have an SMT solver installed locally and run solc-js via node (not via the browser)."
msgstr ""

#: ../../layout-of-source-files.rst:159 507beac7aad24aacbe028a7343de730a
msgid "If you use ``pragma experimental SMTChecker;``, then you get additional :ref:`safety warnings<formal_verification>` which are obtained by querying an SMT solver. The component does not yet support all features of the Solidity language and likely outputs many warnings. In case it reports unsupported features, the analysis may not be fully sound."
msgstr ""

#: ../../layout-of-source-files.rst:171 a5c98ac76c11421f8175329997107e31
msgid "Importing other Source Files"
msgstr ""

#: ../../layout-of-source-files.rst:174 4827614c26194a65b63d97d4c9ee14ac
msgid "Syntax and Semantics"
msgstr ""

#: ../../layout-of-source-files.rst:176 aa5fe81ed49f4132b9fd3f017aca8733
msgid "Solidity supports import statements to help modularise your code that are similar to those available in JavaScript (from ES6 on). However, Solidity does not support the concept of a `default export <https://developer.mozilla.org/en-US/docs/web/javascript/reference/statements/export#Description>`_."
msgstr ""

#: ../../layout-of-source-files.rst:181 66805977a4bf4114b54a29f813966440
msgid "At a global level, you can use import statements of the following form:"
msgstr ""

#: ../../layout-of-source-files.rst:187 6eaaa6c7f04e49799e11ba4567bc873d
msgid "The ``filename`` part is called an *import path*. This statement imports all global symbols from \"filename\" (and symbols imported there) into the current global scope (different than in ES6 but backwards-compatible for Solidity). This form is not recommended for use, because it unpredictably pollutes the namespace. If you add new top-level items inside \"filename\", they automatically appear in all files that import like this from \"filename\". It is better to import specific symbols explicitly."
msgstr ""

#: ../../layout-of-source-files.rst:195 e34d473b1d0143749a187b4d937b2aa1
msgid "The following example creates a new global symbol ``symbolName`` whose members are all the global symbols from ``\"filename\"``:"
msgstr ""

#: ../../layout-of-source-files.rst:202 5e4a2c3d0a1644f48a0b75847c9eff3a
msgid "which results in all global symbols being available in the format ``symbolName.symbol``."
msgstr ""

#: ../../layout-of-source-files.rst:204 b101c4741fb748048d3bfc2354daf463
msgid "A variant of this syntax that is not part of ES6, but possibly useful is:"
msgstr ""

#: ../../layout-of-source-files.rst:210 2e949bc8f16943bb8a5258fef0bcd091
msgid "which is equivalent to ``import * as symbolName from \"filename\";``."
msgstr ""

#: ../../layout-of-source-files.rst:212 5387d349fe9a4d1d9fd401b4a1c46773
msgid "If there is a naming collision, you can rename symbols while importing. For example, the code below creates new global symbols ``alias`` and ``symbol2`` which reference ``symbol1`` and ``symbol2`` from inside ``\"filename\"``, respectively."
msgstr ""

#: ../../layout-of-source-files.rst:223 d3a62105b083471f9ee7f0464f7f13f0
msgid "Import Paths"
msgstr ""

#: ../../layout-of-source-files.rst:225 56fe874cfbef41c5b37d06ba28ff83b8
msgid "In order to be able to support reproducible builds on all platforms, the Solidity compiler has to abstract away the details of the filesystem where source files are stored. For this reason import paths do not refer directly to files in the host filesystem. Instead the compiler maintains an internal database (*virtual filesystem* or *VFS* for short) where each source unit is assigned a unique *source unit name* which is an opaque and unstructured identifier. The import path specified in an import statement is translated into a source unit name and used to find the corresponding source unit in this database."
msgstr ""

#: ../../layout-of-source-files.rst:233 d97f91f38ebe483d967d60b28b3d9e7f
msgid "Using the :ref:`Standard JSON <compiler-api>` API it is possible to directly provide the names and content of all the source files as a part of the compiler input. In this case source unit names are truly arbitrary. If, however, you want the compiler to automatically find and load source code into the VFS, your source unit names need to be structured in a way that makes it possible for an :ref:`import callback <import-callback>` to locate them. When using the command-line compiler the default import callback supports only loading source code from the host filesystem, which means that your source unit names must be paths. Some environments provide custom callbacks that are more versatile. For example the `Remix IDE <https://remix.ethereum.org/>`_ provides one that lets you `import files from HTTP, IPFS and Swarm URLs or refer directly to packages in NPM registry <https://remix-ide.readthedocs.io/en/latest/import.html>`_."
msgstr ""

#: ../../layout-of-source-files.rst:246 5deb3fdde3a44772a23f61a36cb04526
msgid "For a complete description of the virtual filesystem and the path resolution logic used by the compiler see :ref:`Path Resolution <path-resolution>`."
msgstr ""

#: ../../layout-of-source-files.rst:252 7a4e2c3f368640d6aab80160342f7421
msgid "Comments"
msgstr ""

#: ../../layout-of-source-files.rst:254 28588593dc134c1598ac429549133a9d
msgid "Single-line comments (``//``) and multi-line comments (``/*...*/``) are possible."
msgstr ""

#: ../../layout-of-source-files.rst:266 15176ed1f09b45eea3df320dfd0cee62
msgid "A single-line comment is terminated by any unicode line terminator (LF, VF, FF, CR, NEL, LS or PS) in UTF-8 encoding. The terminator is still part of the source code after the comment, so if it is not an ASCII symbol (these are NEL, LS and PS), it will lead to a parser error."
msgstr ""

#: ../../layout-of-source-files.rst:271 d96fd4c4a95a47178bedc3214c06cf03
msgid "Additionally, there is another type of comment called a NatSpec comment, which is detailed in the :ref:`style guide<style_guide_natspec>`. They are written with a triple slash (``///``) or a double asterisk block (``/** ... */``) and they should be used directly above function declarations or statements."
msgstr ""

